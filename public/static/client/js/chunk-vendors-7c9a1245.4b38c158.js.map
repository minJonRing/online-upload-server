{"version":3,"file":"static/client/js/chunk-vendors-7c9a1245.4b38c158.js","mappings":"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","sources":["webpack://d1/./node_modules/claygl/src/picking/RayPicking.js","webpack://d1/./node_modules/claygl/src/shader/source/skybox.glsl.js","webpack://d1/./node_modules/claygl/src/plugin/Skybox.js","webpack://d1/./node_modules/claygl/src/plugin/Skydome.js","webpack://d1/./node_modules/claygl/src/prePass/EnvironmentMap.js","webpack://d1/./node_modules/claygl/src/shader/source/shadowmap.glsl.js","webpack://d1/./node_modules/claygl/src/prePass/ShadowMap.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/coloradjust.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/lum.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/vignette.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/lensflare.glsl.js","webpack://d1/./node_modules/claygl/src/shader/registerBuiltinCompositor.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/blend.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/blur.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/bright.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/downsample.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/fxaa.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/hdr.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/lut.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/output.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/upsample.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/compositor/vertex.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/header/calcAmbientSHLight.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/header/light.js","webpack://d1/./node_modules/claygl/src/shader/source/prez.glsl.js","webpack://d1/./node_modules/claygl/src/shader/source/util.glsl.js"],"sourcesContent":["import Base from '../core/Base';\nimport Ray from '../math/Ray';\nimport Vector2 from '../math/Vector2';\nimport Vector3 from '../math/Vector3';\nimport Matrix4 from '../math/Matrix4';\nimport Renderable from '../Renderable';\nimport glenum from '../core/glenum';\nimport vec3 from '../glmatrix/vec3';\n\n/**\n * @constructor clay.picking.RayPicking\n * @extends clay.core.Base\n */\nvar RayPicking = Base.extend(/** @lends clay.picking.RayPicking# */{\n    /**\n     * Target scene\n     * @type {clay.Scene}\n     */\n    scene: null,\n    /**\n     * Target camera\n     * @type {clay.Camera}\n     */\n    camera: null,\n    /**\n     * Target renderer\n     * @type {clay.Renderer}\n     */\n    renderer: null\n}, function () {\n    this._ray = new Ray();\n    this._ndc = new Vector2();\n},\n/** @lends clay.picking.RayPicking.prototype */\n{\n\n    /**\n     * Pick the nearest intersection object in the scene\n     * @param  {number} x Mouse position x\n     * @param  {number} y Mouse position y\n     * @param  {boolean} [forcePickAll=false] ignore ignorePicking\n     * @return {clay.picking.RayPicking~Intersection}\n     */\n    pick: function (x, y, forcePickAll) {\n        var out = this.pickAll(x, y, [], forcePickAll);\n        return out[0] || null;\n    },\n\n    /**\n     * Pick all intersection objects, wich will be sorted from near to far\n     * @param  {number} x Mouse position x\n     * @param  {number} y Mouse position y\n     * @param  {Array} [output]\n     * @param  {boolean} [forcePickAll=false] ignore ignorePicking\n     * @return {Array.<clay.picking.RayPicking~Intersection>}\n     */\n    pickAll: function (x, y, output, forcePickAll) {\n        this.renderer.screenToNDC(x, y, this._ndc);\n        this.camera.castRay(this._ndc, this._ray);\n\n        output = output || [];\n\n        this._intersectNode(this.scene, output, forcePickAll || false);\n\n        output.sort(this._intersectionCompareFunc);\n\n        return output;\n    },\n\n    _intersectNode: function (node, out, forcePickAll) {\n        if ((node instanceof Renderable) && node.isRenderable()) {\n            if ((!node.ignorePicking || forcePickAll)\n                && (\n                    // Only triangle mesh support ray picking\n                    (node.mode === glenum.TRIANGLES && node.geometry.isUseIndices())\n                    // Or if geometry has it's own pickByRay, pick, implementation\n                    || node.geometry.pickByRay\n                    || node.geometry.pick\n                )\n            ) {\n                this._intersectRenderable(node, out);\n            }\n        }\n        for (var i = 0; i < node._children.length; i++) {\n            this._intersectNode(node._children[i], out, forcePickAll);\n        }\n    },\n\n    _intersectRenderable: (function () {\n\n        var v1 = new Vector3();\n        var v2 = new Vector3();\n        var v3 = new Vector3();\n        var ray = new Ray();\n        var worldInverse = new Matrix4();\n\n        return function (renderable, out) {\n\n            var isSkinnedMesh = renderable.isSkinnedMesh();\n            ray.copy(this._ray);\n            Matrix4.invert(worldInverse, renderable.worldTransform);\n\n            // Skinned mesh will ignore the world transform.\n            if (!isSkinnedMesh) {\n                ray.applyTransform(worldInverse);\n            }\n\n            var geometry = renderable.geometry;\n\n            var bbox = isSkinnedMesh ? renderable.skeleton.boundingBox : geometry.boundingBox;\n\n            if (bbox && !ray.intersectBoundingBox(bbox)) {\n                return;\n            }\n            // Use user defined picking algorithm\n            if (geometry.pick) {\n                geometry.pick(\n                    this._ndc.x, this._ndc.y,\n                    this.renderer,\n                    this.camera,\n                    renderable, out\n                );\n                return;\n            }\n            // Use user defined ray picking algorithm\n            else if (geometry.pickByRay) {\n                geometry.pickByRay(ray, renderable, out);\n                return;\n            }\n\n            var cullBack = (renderable.cullFace === glenum.BACK && renderable.frontFace === glenum.CCW)\n                        || (renderable.cullFace === glenum.FRONT && renderable.frontFace === glenum.CW);\n\n            var point;\n            var indices = geometry.indices;\n            var positionAttr = geometry.attributes.position;\n            var weightAttr = geometry.attributes.weight;\n            var jointAttr = geometry.attributes.joint;\n            var skinMatricesArray;\n            var skinMatrices = [];\n            // Check if valid.\n            if (!positionAttr || !positionAttr.value || !indices) {\n                return;\n            }\n            if (isSkinnedMesh) {\n                skinMatricesArray = renderable.skeleton.getSubSkinMatrices(renderable.__uid__, renderable.joints);\n                for (var i = 0; i < renderable.joints.length; i++) {\n                    skinMatrices[i] = skinMatrices[i] || [];\n                    for (var k = 0; k < 16; k++) {\n                        skinMatrices[i][k] = skinMatricesArray[i * 16 + k];\n                    }\n                }\n                var pos = [];\n                var weight = [];\n                var joint = [];\n                var skinnedPos = [];\n                var tmp = [];\n                var skinnedPositionAttr = geometry.attributes.skinnedPosition;\n                if (!skinnedPositionAttr || !skinnedPositionAttr.value) {\n                    geometry.createAttribute('skinnedPosition', 'f', 3);\n                    skinnedPositionAttr = geometry.attributes.skinnedPosition;\n                    skinnedPositionAttr.init(geometry.vertexCount);\n                }\n                for (var i = 0; i < geometry.vertexCount; i++) {\n                    positionAttr.get(i, pos);\n                    weightAttr.get(i, weight);\n                    jointAttr.get(i, joint);\n                    weight[3] = 1 - weight[0] - weight[1] - weight[2];\n                    vec3.set(skinnedPos, 0, 0, 0);\n                    for (var k = 0; k < 4; k++) {\n                        if (joint[k] >= 0 && weight[k] > 1e-4) {\n                            vec3.transformMat4(tmp, pos, skinMatrices[joint[k]]);\n                            vec3.scaleAndAdd(skinnedPos, skinnedPos, tmp, weight[k]);\n                        }\n                    }\n                    skinnedPositionAttr.set(i, skinnedPos);\n                }\n            }\n\n            for (var i = 0; i < indices.length; i += 3) {\n                var i1 = indices[i];\n                var i2 = indices[i + 1];\n                var i3 = indices[i + 2];\n                var finalPosAttr = isSkinnedMesh\n                    ? geometry.attributes.skinnedPosition\n                    : positionAttr;\n                finalPosAttr.get(i1, v1.array);\n                finalPosAttr.get(i2, v2.array);\n                finalPosAttr.get(i3, v3.array);\n\n                if (cullBack) {\n                    point = ray.intersectTriangle(v1, v2, v3, renderable.culling);\n                }\n                else {\n                    point = ray.intersectTriangle(v1, v3, v2, renderable.culling);\n                }\n                if (point) {\n                    var pointW = new Vector3();\n                    if (!isSkinnedMesh) {\n                        Vector3.transformMat4(pointW, point, renderable.worldTransform);\n                    }\n                    else {\n                        // TODO point maybe not right.\n                        Vector3.copy(pointW, point);\n                    }\n                    out.push(new RayPicking.Intersection(\n                        point, pointW, renderable, [i1, i2, i3], i / 3,\n                        Vector3.dist(pointW, this._ray.origin)\n                    ));\n                }\n            }\n        };\n    })(),\n\n    _intersectionCompareFunc: function (a, b) {\n        return a.distance - b.distance;\n    }\n});\n\n/**\n * @constructor clay.picking.RayPicking~Intersection\n * @param {clay.Vector3} point\n * @param {clay.Vector3} pointWorld\n * @param {clay.Node} target\n * @param {Array.<number>} triangle\n * @param {number} triangleIndex\n * @param {number} distance\n */\nRayPicking.Intersection = function (point, pointWorld, target, triangle, triangleIndex, distance) {\n    /**\n     * Intersection point in local transform coordinates\n     * @type {clay.Vector3}\n     */\n    this.point = point;\n    /**\n     * Intersection point in world transform coordinates\n     * @type {clay.Vector3}\n     */\n    this.pointWorld = pointWorld;\n    /**\n     * Intersection scene node\n     * @type {clay.Node}\n     */\n    this.target = target;\n    /**\n     * Intersection triangle, which is an array of vertex index\n     * @type {Array.<number>}\n     */\n    this.triangle = triangle;\n    /**\n     * Index of intersection triangle.\n     */\n    this.triangleIndex = triangleIndex;\n    /**\n     * Distance from intersection point to ray origin\n     * @type {number}\n     */\n    this.distance = distance;\n};\n\nexport default RayPicking;\n","export default \"@export clay.skybox.vertex\\n#define SHADER_NAME skybox\\nuniform mat4 world : WORLD;\\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\\nattribute vec3 position : POSITION;\\nvarying vec3 v_WorldPosition;\\nvoid main()\\n{\\n v_WorldPosition = (world * vec4(position, 1.0)).xyz;\\n gl_Position = worldViewProjection * vec4(position, 1.0);\\n}\\n@end\\n@export clay.skybox.fragment\\n#define PI 3.1415926\\nuniform mat4 viewInverse : VIEWINVERSE;\\n#ifdef EQUIRECTANGULAR\\nuniform sampler2D environmentMap;\\n#else\\nuniform samplerCube environmentMap;\\n#endif\\nuniform float lod: 0.0;\\nvarying vec3 v_WorldPosition;\\n@import clay.util.rgbm\\n@import clay.util.srgb\\n@import clay.util.ACES\\nvoid main()\\n{\\n vec3 eyePos = viewInverse[3].xyz;\\n vec3 V = normalize(v_WorldPosition - eyePos);\\n#ifdef EQUIRECTANGULAR\\n float phi = acos(V.y);\\n float theta = atan(-V.x, V.z) + PI * 0.5;\\n vec2 uv = vec2(theta / 2.0 / PI, phi / PI);\\n vec4 texel = decodeHDR(texture2D(environmentMap, fract(uv)));\\n#else\\n #if defined(LOD) || defined(SUPPORT_TEXTURE_LOD)\\n vec4 texel = decodeHDR(textureCubeLodEXT(environmentMap, V, lod));\\n #else\\n vec4 texel = decodeHDR(textureCube(environmentMap, V));\\n #endif\\n#endif\\n#ifdef SRGB_DECODE\\n texel = sRGBToLinear(texel);\\n#endif\\n#ifdef TONEMAPPING\\n texel.rgb = ACESToneMapping(texel.rgb);\\n#endif\\n#ifdef SRGB_ENCODE\\n texel = linearTosRGB(texel);\\n#endif\\n gl_FragColor = encodeHDR(vec4(texel.rgb, 1.0));\\n}\\n@end\";\n","// TODO Should not derived from mesh?\nimport Mesh from '../Mesh';\nimport CubeGeometry from '../geometry/Cube';\nimport Shader from '../Shader';\nimport Material from '../Material';\nimport Texture from '../Texture';\nimport PerspectiveCamera from '../camera/Perspective';\nimport Matrix4 from '../math/Matrix4';\n\nimport skyboxEssl from '../shader/source/skybox.glsl.js';\nShader.import(skyboxEssl);\n/**\n * @constructor clay.plugin.Skybox\n *\n * @example\n *     var skyTex = new clay.TextureCube();\n *     skyTex.load({\n *         'px': 'assets/textures/sky/px.jpg',\n *         'nx': 'assets/textures/sky/nx.jpg'\n *         'py': 'assets/textures/sky/py.jpg'\n *         'ny': 'assets/textures/sky/ny.jpg'\n *         'pz': 'assets/textures/sky/pz.jpg'\n *         'nz': 'assets/textures/sky/nz.jpg'\n *     });\n *     var skybox = new clay.plugin.Skybox({\n *         scene: scene\n *     });\n *     skybox.material.set('environmentMap', skyTex);\n */\nvar Skybox = Mesh.extend(function () {\n\n    var skyboxShader = new Shader({\n        vertex: Shader.source('clay.skybox.vertex'),\n        fragment: Shader.source('clay.skybox.fragment')\n    });\n    var material = new Material({\n        shader: skyboxShader,\n        depthMask: false\n    });\n\n    return {\n        /**\n         * @type {clay.Scene}\n         * @memberOf clay.plugin.Skybox.prototype\n         */\n        scene: null,\n\n        geometry: new CubeGeometry(),\n\n        material: material,\n\n        environmentMap: null,\n\n        culling: false,\n\n        _dummyCamera: new PerspectiveCamera()\n    };\n}, function () {\n    var scene = this.scene;\n    if (scene) {\n        this.attachScene(scene);\n    }\n    if (this.environmentMap) {\n        this.setEnvironmentMap(this.environmentMap);\n    }\n}, /** @lends clay.plugin.Skybox# */ {\n    /**\n     * Attach the skybox to the scene\n     * @param  {clay.Scene} scene\n     */\n    attachScene: function (scene) {\n        if (this.scene) {\n            this.detachScene();\n        }\n        scene.skybox = this;\n\n        this.scene = scene;\n        scene.on('beforerender', this._beforeRenderScene, this);\n    },\n    /**\n     * Detach from scene\n     */\n    detachScene: function () {\n        if (this.scene) {\n            this.scene.off('beforerender', this._beforeRenderScene);\n            this.scene.skybox = null;\n        }\n        this.scene = null;\n    },\n\n    /**\n     * Dispose skybox\n     * @param  {clay.Renderer} renderer\n     */\n    dispose: function (renderer) {\n        this.detachScene();\n        this.geometry.dispose(renderer);\n    },\n    /**\n     * Set environment map\n     * @param {clay.TextureCube} envMap\n     */\n    setEnvironmentMap: function (envMap) {\n        if (envMap.textureType === 'texture2D') {\n            this.material.define('EQUIRECTANGULAR');\n            // LINEAR filter can remove the artifacts in pole\n            envMap.minFilter = Texture.LINEAR;\n        }\n        else {\n            this.material.undefine('EQUIRECTANGULAR');\n        }\n        this.material.set('environmentMap', envMap);\n    },\n    /**\n     * Get environment map\n     * @return {clay.TextureCube}\n     */\n    getEnvironmentMap: function () {\n        return this.material.get('environmentMap');\n    },\n\n    _beforeRenderScene: function(renderer, scene, camera) {\n        this.renderSkybox(renderer, camera);\n    },\n\n    renderSkybox: function (renderer, camera) {\n        var dummyCamera = this._dummyCamera;\n        dummyCamera.aspect = renderer.getViewportAspect();\n        dummyCamera.fov = camera.fov || 50;\n        dummyCamera.updateProjectionMatrix();\n        Matrix4.invert(dummyCamera.invProjectionMatrix, dummyCamera.projectionMatrix);\n        dummyCamera.worldTransform.copy(camera.worldTransform);\n        dummyCamera.viewMatrix.copy(camera.viewMatrix);\n\n        this.position.copy(camera.getWorldPosition());\n        this.update();\n\n        // Don't remember to disable blend\n        renderer.gl.disable(renderer.gl.BLEND);\n        if (this.material.get('lod') > 0) {\n            this.material.define('fragment', 'LOD');\n        }\n        else {\n            this.material.undefine('fragment', 'LOD');\n        }\n        renderer.renderPass([this], dummyCamera);\n    }\n});\n\nexport default Skybox;\n","import Skybox from './Skybox';\n\nexport default Skybox;","import Base from '../core/Base';\nimport Vector3 from '../math/Vector3';\nimport PerspectiveCamera from '../camera/Perspective';\nimport FrameBuffer from '../FrameBuffer';\n\nvar targets = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];\n\n/**\n * Pass rendering scene to a environment cube map\n *\n * @constructor clay.prePass.EnvironmentMap\n * @extends clay.core.Base\n * @example\n *     // Example of car reflection\n *     var envMap = new clay.TextureCube({\n *         width: 256,\n *         height: 256\n *     });\n *     var envPass = new clay.prePass.EnvironmentMap({\n *         position: car.position,\n *         texture: envMap\n *     });\n *     var carBody = car.getChildByName('body');\n *     carBody.material.enableTexture('environmentMap');\n *     carBody.material.set('environmentMap', envMap);\n *     ...\n *     animation.on('frame', function(frameTime) {\n *         envPass.render(renderer, scene);\n *         renderer.render(scene, camera);\n *     });\n */\nvar EnvironmentMapPass = Base.extend(function() {\n    var ret = /** @lends clay.prePass.EnvironmentMap# */ {\n        /**\n         * Camera position\n         * @type {clay.Vector3}\n         * @memberOf clay.prePass.EnvironmentMap#\n         */\n        position: new Vector3(),\n        /**\n         * Camera far plane\n         * @type {number}\n         * @memberOf clay.prePass.EnvironmentMap#\n         */\n        far: 1000,\n        /**\n         * Camera near plane\n         * @type {number}\n         * @memberOf clay.prePass.EnvironmentMap#\n         */\n        near: 0.1,\n        /**\n         * Environment cube map\n         * @type {clay.TextureCube}\n         * @memberOf clay.prePass.EnvironmentMap#\n         */\n        texture: null,\n\n        /**\n         * Used if you wan't have shadow in environment map\n         * @type {clay.prePass.ShadowMap}\n         */\n        shadowMapPass: null,\n    };\n    var cameras = ret._cameras = {\n        px: new PerspectiveCamera({ fov: 90 }),\n        nx: new PerspectiveCamera({ fov: 90 }),\n        py: new PerspectiveCamera({ fov: 90 }),\n        ny: new PerspectiveCamera({ fov: 90 }),\n        pz: new PerspectiveCamera({ fov: 90 }),\n        nz: new PerspectiveCamera({ fov: 90 })\n    };\n    cameras.px.lookAt(Vector3.POSITIVE_X, Vector3.NEGATIVE_Y);\n    cameras.nx.lookAt(Vector3.NEGATIVE_X, Vector3.NEGATIVE_Y);\n    cameras.py.lookAt(Vector3.POSITIVE_Y, Vector3.POSITIVE_Z);\n    cameras.ny.lookAt(Vector3.NEGATIVE_Y, Vector3.NEGATIVE_Z);\n    cameras.pz.lookAt(Vector3.POSITIVE_Z, Vector3.NEGATIVE_Y);\n    cameras.nz.lookAt(Vector3.NEGATIVE_Z, Vector3.NEGATIVE_Y);\n\n    // FIXME In windows, use one framebuffer only renders one side of cubemap\n    ret._frameBuffer = new FrameBuffer();\n\n    return ret;\n},  /** @lends clay.prePass.EnvironmentMap# */ {\n    /**\n     * @param  {string} target\n     * @return  {clay.Camera}\n     */\n    getCamera: function (target) {\n        return this._cameras[target];\n    },\n    /**\n     * @param  {clay.Renderer} renderer\n     * @param  {clay.Scene} scene\n     * @param  {boolean} [notUpdateScene=false]\n     */\n    render: function(renderer, scene, notUpdateScene) {\n        var _gl = renderer.gl;\n        if (!notUpdateScene) {\n            scene.update();\n        }\n        // Tweak fov\n        // http://the-witness.net/news/2012/02/seamless-cube-map-filtering/\n        var n = this.texture.width;\n        var fov = 2 * Math.atan(n / (n - 0.5)) / Math.PI * 180;\n\n        for (var i = 0; i < 6; i++) {\n            var target = targets[i];\n            var camera = this._cameras[target];\n            Vector3.copy(camera.position, this.position);\n\n            camera.far = this.far;\n            camera.near = this.near;\n            camera.fov = fov;\n\n            if (this.shadowMapPass) {\n                camera.update();\n\n                // update boundingBoxLastFrame\n                var bbox = scene.getBoundingBox();\n                bbox.applyTransform(camera.viewMatrix);\n                scene.viewBoundingBoxLastFrame.copy(bbox);\n\n                this.shadowMapPass.render(renderer, scene, camera, true);\n            }\n            this._frameBuffer.attach(\n                this.texture, _gl.COLOR_ATTACHMENT0,\n                _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i\n            );\n            this._frameBuffer.bind(renderer);\n            renderer.render(scene, camera, true);\n            this._frameBuffer.unbind(renderer);\n        }\n    },\n    /**\n     * @param {clay.Renderer} renderer\n     */\n    dispose: function (renderer) {\n        this._frameBuffer.dispose(renderer);\n    }\n});\n\nexport default EnvironmentMapPass;\n","export default \"@export clay.sm.depth.vertex\\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\\nattribute vec3 position : POSITION;\\nattribute vec2 texcoord : TEXCOORD_0;\\nuniform vec2 uvRepeat = vec2(1.0, 1.0);\\nuniform vec2 uvOffset = vec2(0.0, 0.0);\\n@import clay.chunk.skinning_header\\n@import clay.chunk.instancing_header\\nvarying vec4 v_ViewPosition;\\nvarying vec2 v_Texcoord;\\nvoid main(){\\n vec4 P = vec4(position, 1.0);\\n#ifdef SKINNING\\n @import clay.chunk.skin_matrix\\n P = skinMatrixWS * P;\\n#endif\\n#ifdef INSTANCING\\n @import clay.chunk.instancing_matrix\\n P = instanceMat * P;\\n#endif\\n v_ViewPosition = worldViewProjection * P;\\n gl_Position = v_ViewPosition;\\n v_Texcoord = texcoord * uvRepeat + uvOffset;\\n}\\n@end\\n@export clay.sm.depth.fragment\\nvarying vec4 v_ViewPosition;\\nvarying vec2 v_Texcoord;\\nuniform float bias : 0.001;\\nuniform float slopeScale : 1.0;\\nuniform sampler2D alphaMap;\\nuniform float alphaCutoff: 0.0;\\n@import clay.util.encode_float\\nvoid main(){\\n float depth = v_ViewPosition.z / v_ViewPosition.w;\\n if (alphaCutoff > 0.0) {\\n if (texture2D(alphaMap, v_Texcoord).a <= alphaCutoff) {\\n discard;\\n }\\n }\\n#ifdef USE_VSM\\n depth = depth * 0.5 + 0.5;\\n float moment1 = depth;\\n float moment2 = depth * depth;\\n #ifdef SUPPORT_STANDARD_DERIVATIVES\\n float dx = dFdx(depth);\\n float dy = dFdy(depth);\\n moment2 += 0.25*(dx*dx+dy*dy);\\n #endif\\n gl_FragColor = vec4(moment1, moment2, 0.0, 1.0);\\n#else\\n #ifdef SUPPORT_STANDARD_DERIVATIVES\\n float dx = dFdx(depth);\\n float dy = dFdy(depth);\\n depth += sqrt(dx*dx + dy*dy) * slopeScale + bias;\\n #else\\n depth += bias;\\n #endif\\n gl_FragColor = encodeFloat(depth * 0.5 + 0.5);\\n#endif\\n}\\n@end\\n@export clay.sm.debug_depth\\nuniform sampler2D depthMap;\\nvarying vec2 v_Texcoord;\\n@import clay.util.decode_float\\nvoid main() {\\n vec4 tex = texture2D(depthMap, v_Texcoord);\\n#ifdef USE_VSM\\n gl_FragColor = vec4(tex.rgb, 1.0);\\n#else\\n float depth = decodeFloat(tex);\\n gl_FragColor = vec4(depth, depth, depth, 1.0);\\n#endif\\n}\\n@end\\n@export clay.sm.distance.vertex\\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\\nuniform mat4 world : WORLD;\\nattribute vec3 position : POSITION;\\n@import clay.chunk.skinning_header\\nvarying vec3 v_WorldPosition;\\nvoid main (){\\n vec4 P = vec4(position, 1.0);\\n#ifdef SKINNING\\n @import clay.chunk.skin_matrix\\n P = skinMatrixWS * P;\\n#endif\\n#ifdef INSTANCING\\n @import clay.chunk.instancing_matrix\\n P = instanceMat * P;\\n#endif\\n gl_Position = worldViewProjection * P;\\n v_WorldPosition = (world * P).xyz;\\n}\\n@end\\n@export clay.sm.distance.fragment\\nuniform vec3 lightPosition;\\nuniform float range : 100;\\nvarying vec3 v_WorldPosition;\\n@import clay.util.encode_float\\nvoid main(){\\n float dist = distance(lightPosition, v_WorldPosition);\\n#ifdef USE_VSM\\n gl_FragColor = vec4(dist, dist * dist, 0.0, 0.0);\\n#else\\n dist = dist / range;\\n gl_FragColor = encodeFloat(dist);\\n#endif\\n}\\n@end\\n@export clay.plugin.shadow_map_common\\n@import clay.util.decode_float\\nfloat tapShadowMap(sampler2D map, vec2 uv, float z){\\n vec4 tex = texture2D(map, uv);\\n return step(z, decodeFloat(tex) * 2.0 - 1.0);\\n}\\nfloat pcf(sampler2D map, vec2 uv, float z, float textureSize, vec2 scale) {\\n float shadowContrib = tapShadowMap(map, uv, z);\\n vec2 offset = vec2(1.0 / textureSize) * scale;\\n#ifdef PCF_KERNEL_SIZE\\n for (int _idx_ = 0; _idx_ < PCF_KERNEL_SIZE; _idx_++) {{\\n shadowContrib += tapShadowMap(map, uv + offset * pcfKernel[_idx_], z);\\n }}\\n return shadowContrib / float(PCF_KERNEL_SIZE + 1);\\n#else\\n shadowContrib += tapShadowMap(map, uv+vec2(offset.x, 0.0), z);\\n shadowContrib += tapShadowMap(map, uv+vec2(offset.x, offset.y), z);\\n shadowContrib += tapShadowMap(map, uv+vec2(-offset.x, offset.y), z);\\n shadowContrib += tapShadowMap(map, uv+vec2(0.0, offset.y), z);\\n shadowContrib += tapShadowMap(map, uv+vec2(-offset.x, 0.0), z);\\n shadowContrib += tapShadowMap(map, uv+vec2(-offset.x, -offset.y), z);\\n shadowContrib += tapShadowMap(map, uv+vec2(offset.x, -offset.y), z);\\n shadowContrib += tapShadowMap(map, uv+vec2(0.0, -offset.y), z);\\n return shadowContrib / 9.0;\\n#endif\\n}\\nfloat pcf(sampler2D map, vec2 uv, float z, float textureSize) {\\n return pcf(map, uv, z, textureSize, vec2(1.0));\\n}\\nfloat chebyshevUpperBound(vec2 moments, float z){\\n float p = 0.0;\\n z = z * 0.5 + 0.5;\\n if (z <= moments.x) {\\n p = 1.0;\\n }\\n float variance = moments.y - moments.x * moments.x;\\n variance = max(variance, 0.0000001);\\n float mD = moments.x - z;\\n float pMax = variance / (variance + mD * mD);\\n pMax = clamp((pMax-0.4)/(1.0-0.4), 0.0, 1.0);\\n return max(p, pMax);\\n}\\nfloat computeShadowContrib(\\n sampler2D map, mat4 lightVPM, vec3 position, float textureSize, vec2 scale, vec2 offset\\n) {\\n vec4 posInLightSpace = lightVPM * vec4(position, 1.0);\\n posInLightSpace.xyz /= posInLightSpace.w;\\n float z = posInLightSpace.z;\\n if(all(greaterThan(posInLightSpace.xyz, vec3(-0.99, -0.99, -1.0))) &&\\n all(lessThan(posInLightSpace.xyz, vec3(0.99, 0.99, 1.0)))){\\n vec2 uv = (posInLightSpace.xy+1.0) / 2.0;\\n #ifdef USE_VSM\\n vec2 moments = texture2D(map, uv * scale + offset).xy;\\n return chebyshevUpperBound(moments, z);\\n #else\\n return pcf(map, uv * scale + offset, z, textureSize, scale);\\n #endif\\n }\\n return 1.0;\\n}\\nfloat computeShadowContrib(sampler2D map, mat4 lightVPM, vec3 position, float textureSize) {\\n return computeShadowContrib(map, lightVPM, position, textureSize, vec2(1.0), vec2(0.0));\\n}\\nfloat computeShadowContribOmni(samplerCube map, vec3 direction, float range)\\n{\\n float dist = length(direction);\\n vec4 shadowTex = textureCube(map, direction);\\n#ifdef USE_VSM\\n vec2 moments = shadowTex.xy;\\n float variance = moments.y - moments.x * moments.x;\\n float mD = moments.x - dist;\\n float p = variance / (variance + mD * mD);\\n if(moments.x + 0.001 < dist){\\n return clamp(p, 0.0, 1.0);\\n }else{\\n return 1.0;\\n }\\n#else\\n return step(dist, (decodeFloat(shadowTex) + 0.0002) * range);\\n#endif\\n}\\n@end\\n@export clay.plugin.compute_shadow_map\\n#if defined(SPOT_LIGHT_SHADOWMAP_COUNT) || defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT) || defined(POINT_LIGHT_SHADOWMAP_COUNT)\\n#ifdef SPOT_LIGHT_SHADOWMAP_COUNT\\nuniform sampler2D spotLightShadowMaps[SPOT_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\\nuniform mat4 spotLightMatrices[SPOT_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\\nuniform float spotLightShadowMapSizes[SPOT_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\\n#endif\\n#ifdef DIRECTIONAL_LIGHT_SHADOWMAP_COUNT\\n#if defined(SHADOW_CASCADE)\\nuniform sampler2D directionalLightShadowMaps[1]:unconfigurable;\\nuniform mat4 directionalLightMatrices[SHADOW_CASCADE]:unconfigurable;\\nuniform float directionalLightShadowMapSizes[1]:unconfigurable;\\nuniform float shadowCascadeClipsNear[SHADOW_CASCADE]:unconfigurable;\\nuniform float shadowCascadeClipsFar[SHADOW_CASCADE]:unconfigurable;\\n#else\\nuniform sampler2D directionalLightShadowMaps[DIRECTIONAL_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\\nuniform mat4 directionalLightMatrices[DIRECTIONAL_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\\nuniform float directionalLightShadowMapSizes[DIRECTIONAL_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\\n#endif\\n#endif\\n#ifdef POINT_LIGHT_SHADOWMAP_COUNT\\nuniform samplerCube pointLightShadowMaps[POINT_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\\n#endif\\nuniform bool shadowEnabled : true;\\n#ifdef PCF_KERNEL_SIZE\\nuniform vec2 pcfKernel[PCF_KERNEL_SIZE];\\n#endif\\n@import clay.plugin.shadow_map_common\\n#if defined(SPOT_LIGHT_SHADOWMAP_COUNT)\\nvoid computeShadowOfSpotLights(vec3 position, inout float shadowContribs[SPOT_LIGHT_COUNT] ) {\\n float shadowContrib;\\n for(int _idx_ = 0; _idx_ < SPOT_LIGHT_SHADOWMAP_COUNT; _idx_++) {{\\n shadowContrib = computeShadowContrib(\\n spotLightShadowMaps[_idx_], spotLightMatrices[_idx_], position,\\n spotLightShadowMapSizes[_idx_]\\n );\\n shadowContribs[_idx_] = shadowContrib;\\n }}\\n for(int _idx_ = SPOT_LIGHT_SHADOWMAP_COUNT; _idx_ < SPOT_LIGHT_COUNT; _idx_++){{\\n shadowContribs[_idx_] = 1.0;\\n }}\\n}\\n#endif\\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\\n#ifdef SHADOW_CASCADE\\nvoid computeShadowOfDirectionalLights(vec3 position, inout float shadowContribs[DIRECTIONAL_LIGHT_COUNT]){\\n float depth = (2.0 * gl_FragCoord.z - gl_DepthRange.near - gl_DepthRange.far)\\n / (gl_DepthRange.far - gl_DepthRange.near);\\n float shadowContrib;\\n shadowContribs[0] = 1.0;\\n for (int _idx_ = 0; _idx_ < SHADOW_CASCADE; _idx_++) {{\\n if (\\n depth >= shadowCascadeClipsNear[_idx_] &&\\n depth <= shadowCascadeClipsFar[_idx_]\\n ) {\\n shadowContrib = computeShadowContrib(\\n directionalLightShadowMaps[0], directionalLightMatrices[_idx_], position,\\n directionalLightShadowMapSizes[0],\\n vec2(1.0 / float(SHADOW_CASCADE), 1.0),\\n vec2(float(_idx_) / float(SHADOW_CASCADE), 0.0)\\n );\\n shadowContribs[0] = shadowContrib;\\n }\\n }}\\n for(int _idx_ = DIRECTIONAL_LIGHT_SHADOWMAP_COUNT; _idx_ < DIRECTIONAL_LIGHT_COUNT; _idx_++) {{\\n shadowContribs[_idx_] = 1.0;\\n }}\\n}\\n#else\\nvoid computeShadowOfDirectionalLights(vec3 position, inout float shadowContribs[DIRECTIONAL_LIGHT_COUNT]){\\n float shadowContrib;\\n for(int _idx_ = 0; _idx_ < DIRECTIONAL_LIGHT_SHADOWMAP_COUNT; _idx_++) {{\\n shadowContrib = computeShadowContrib(\\n directionalLightShadowMaps[_idx_], directionalLightMatrices[_idx_], position,\\n directionalLightShadowMapSizes[_idx_]\\n );\\n shadowContribs[_idx_] = shadowContrib;\\n }}\\n for(int _idx_ = DIRECTIONAL_LIGHT_SHADOWMAP_COUNT; _idx_ < DIRECTIONAL_LIGHT_COUNT; _idx_++) {{\\n shadowContribs[_idx_] = 1.0;\\n }}\\n}\\n#endif\\n#endif\\n#if defined(POINT_LIGHT_SHADOWMAP_COUNT)\\nvoid computeShadowOfPointLights(vec3 position, inout float shadowContribs[POINT_LIGHT_COUNT] ){\\n vec3 lightPosition;\\n vec3 direction;\\n for(int _idx_ = 0; _idx_ < POINT_LIGHT_SHADOWMAP_COUNT; _idx_++) {{\\n lightPosition = pointLightPosition[_idx_];\\n direction = position - lightPosition;\\n shadowContribs[_idx_] = computeShadowContribOmni(pointLightShadowMaps[_idx_], direction, pointLightRange[_idx_]);\\n }}\\n for(int _idx_ = POINT_LIGHT_SHADOWMAP_COUNT; _idx_ < POINT_LIGHT_COUNT; _idx_++) {{\\n shadowContribs[_idx_] = 1.0;\\n }}\\n}\\n#endif\\n#endif\\n@end\";\n","import Base from '../core/Base';\nimport glenum from '../core/glenum';\nimport Vector3 from '../math/Vector3';\nimport BoundingBox from '../math/BoundingBox';\nimport Frustum from '../math/Frustum';\nimport Matrix4 from '../math/Matrix4';\nimport Renderer from '../Renderer';\nimport Shader from '../Shader';\nimport Material from '../Material';\nimport FrameBuffer from '../FrameBuffer';\nimport Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nimport TextureCube from '../TextureCube';\nimport PerspectiveCamera from '../camera/Perspective';\nimport OrthoCamera from '../camera/Orthographic';\n\nimport Pass from '../compositor/Pass';\nimport TexturePool from '../compositor/TexturePool';\n\nimport mat4 from '../glmatrix/mat4';\n\nvar targets = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];\n\nimport shadowmapEssl from '../shader/source/shadowmap.glsl.js';\nShader['import'](shadowmapEssl);\n\nfunction getDepthMaterialUniform(renderable, depthMaterial, symbol) {\n    if (symbol === 'alphaMap') {\n        return renderable.material.get('diffuseMap');\n    }\n    else if (symbol === 'alphaCutoff') {\n        if (renderable.material.isDefined('fragment', 'ALPHA_TEST')\n            && renderable.material.get('diffuseMap')\n        ) {\n            var alphaCutoff = renderable.material.get('alphaCutoff');\n            return alphaCutoff || 0;\n        }\n        return 0;\n    }\n    else if (symbol === 'uvRepeat') {\n        return renderable.material.get('uvRepeat');\n    }\n    else if (symbol === 'uvOffset') {\n        return renderable.material.get('uvOffset');\n    }\n    else {\n        return depthMaterial.get(symbol);\n    }\n}\n\nfunction isDepthMaterialChanged(renderable, prevRenderable) {\n    var matA = renderable.material;\n    var matB = prevRenderable.material;\n    return matA.get('diffuseMap') !== matB.get('diffuseMap')\n        || (matA.get('alphaCutoff') || 0) !== (matB.get('alphaCutoff') || 0);\n}\n\n/**\n * Pass rendering shadow map.\n *\n * @constructor clay.prePass.ShadowMap\n * @extends clay.core.Base\n * @example\n *     var shadowMapPass = new clay.prePass.ShadowMap({\n *         softShadow: clay.prePass.ShadowMap.VSM\n *     });\n *     ...\n *     animation.on('frame', function (frameTime) {\n *         shadowMapPass.render(renderer, scene, camera);\n *         renderer.render(scene, camera);\n *     });\n */\nvar ShadowMapPass = Base.extend(function () {\n    return /** @lends clay.prePass.ShadowMap# */ {\n        /**\n         * Soft shadow technique.\n         * Can be {@link clay.prePass.ShadowMap.PCF} or {@link clay.prePass.ShadowMap.VSM}\n         * @type {number}\n         */\n        softShadow: ShadowMapPass.PCF,\n\n        /**\n         * Soft shadow blur size\n         * @type {number}\n         */\n        shadowBlur: 1.0,\n\n        lightFrustumBias: 'auto',\n\n        kernelPCF: new Float32Array([\n            1, 0,\n            1, 1,\n            -1, 1,\n            0, 1,\n            -1, 0,\n            -1, -1,\n            1, -1,\n            0, -1\n        ]),\n\n        precision: 'highp',\n\n        _lastRenderNotCastShadow: false,\n\n        _frameBuffer: new FrameBuffer(),\n\n        _textures: {},\n        _shadowMapNumber: {\n            'POINT_LIGHT': 0,\n            'DIRECTIONAL_LIGHT': 0,\n            'SPOT_LIGHT': 0\n        },\n\n        _depthMaterials: {},\n        _distanceMaterials: {},\n\n        _receivers: [],\n        _lightsCastShadow: [],\n\n        _lightCameras: {},\n        _lightMaterials: {},\n\n        _texturePool: new TexturePool()\n    };\n}, function () {\n    // Gaussian filter pass for VSM\n    this._gaussianPassH = new Pass({\n        fragment: Shader.source('clay.compositor.gaussian_blur')\n    });\n    this._gaussianPassV = new Pass({\n        fragment: Shader.source('clay.compositor.gaussian_blur')\n    });\n    this._gaussianPassH.setUniform('blurSize', this.shadowBlur);\n    this._gaussianPassH.setUniform('blurDir', 0.0);\n    this._gaussianPassV.setUniform('blurSize', this.shadowBlur);\n    this._gaussianPassV.setUniform('blurDir', 1.0);\n\n    this._outputDepthPass = new Pass({\n        fragment: Shader.source('clay.sm.debug_depth')\n    });\n}, {\n    /**\n     * Render scene to shadow textures\n     * @param  {clay.Renderer} renderer\n     * @param  {clay.Scene} scene\n     * @param  {clay.Camera} sceneCamera\n     * @param  {boolean} [notUpdateScene=false]\n     * @memberOf clay.prePass.ShadowMap.prototype\n     */\n    render: function (renderer, scene, sceneCamera, notUpdateScene) {\n        if (!sceneCamera) {\n            sceneCamera = scene.getMainCamera();\n        }\n        this.trigger('beforerender', this, renderer, scene, sceneCamera);\n        this._renderShadowPass(renderer, scene, sceneCamera, notUpdateScene);\n        this.trigger('afterrender', this, renderer, scene, sceneCamera);\n    },\n\n    /**\n     * Debug rendering of shadow textures\n     * @param  {clay.Renderer} renderer\n     * @param  {number} size\n     * @memberOf clay.prePass.ShadowMap.prototype\n     */\n    renderDebug: function (renderer, size) {\n        renderer.saveClear();\n        var viewport = renderer.viewport;\n        var x = 0, y = 0;\n        var width = size || viewport.width / 4;\n        var height = width;\n        if (this.softShadow === ShadowMapPass.VSM) {\n            this._outputDepthPass.material.define('fragment', 'USE_VSM');\n        }\n        else {\n            this._outputDepthPass.material.undefine('fragment', 'USE_VSM');\n        }\n        for (var name in this._textures) {\n            var texture = this._textures[name];\n            renderer.setViewport(x, y, width * texture.width / texture.height, height);\n            this._outputDepthPass.setUniform('depthMap', texture);\n            this._outputDepthPass.render(renderer);\n            x += width * texture.width / texture.height;\n        }\n        renderer.setViewport(viewport);\n        renderer.restoreClear();\n    },\n\n    _updateReceivers: function (renderer, mesh) {\n        if (mesh.receiveShadow) {\n            this._receivers.push(mesh);\n            mesh.material.set('shadowEnabled', 1);\n\n            mesh.material.set('pcfKernel', this.kernelPCF);\n        }\n        else {\n            mesh.material.set('shadowEnabled', 0);\n        }\n\n        if (this.softShadow === ShadowMapPass.VSM) {\n            mesh.material.define('fragment', 'USE_VSM');\n            mesh.material.undefine('fragment', 'PCF_KERNEL_SIZE');\n        }\n        else {\n            mesh.material.undefine('fragment', 'USE_VSM');\n            var kernelPCF = this.kernelPCF;\n            if (kernelPCF && kernelPCF.length) {\n                mesh.material.define('fragment', 'PCF_KERNEL_SIZE', kernelPCF.length / 2);\n            }\n            else {\n                mesh.material.undefine('fragment', 'PCF_KERNEL_SIZE');\n            }\n        }\n    },\n\n    _update: function (renderer, scene) {\n        var self = this;\n        scene.traverse(function (renderable) {\n            if (renderable.isRenderable()) {\n                self._updateReceivers(renderer, renderable);\n            }\n        });\n\n        for (var i = 0; i < scene.lights.length; i++) {\n            var light = scene.lights[i];\n            if (light.castShadow && !light.invisible) {\n                this._lightsCastShadow.push(light);\n            }\n        }\n    },\n\n    _renderShadowPass: function (renderer, scene, sceneCamera, notUpdateScene) {\n        // reset\n        for (var name in this._shadowMapNumber) {\n            this._shadowMapNumber[name] = 0;\n        }\n        this._lightsCastShadow.length = 0;\n        this._receivers.length = 0;\n\n        var _gl = renderer.gl;\n\n        if (!notUpdateScene) {\n            scene.update();\n        }\n        if (sceneCamera) {\n            sceneCamera.update();\n        }\n\n        scene.updateLights();\n        this._update(renderer, scene);\n\n        // Needs to update the receivers again if shadows come from 1 to 0.\n        if (!this._lightsCastShadow.length && this._lastRenderNotCastShadow) {\n            return;\n        }\n\n        this._lastRenderNotCastShadow = this._lightsCastShadow === 0;\n\n        _gl.enable(_gl.DEPTH_TEST);\n        _gl.depthMask(true);\n        _gl.disable(_gl.BLEND);\n\n        // Clear with high-z, so the part not rendered will not been shadowed\n        // TODO\n        // TODO restore\n        _gl.clearColor(1.0, 1.0, 1.0, 1.0);\n\n        // Shadow uniforms\n        var spotLightShadowMaps = [];\n        var spotLightMatrices = [];\n        var directionalLightShadowMaps = [];\n        var directionalLightMatrices = [];\n        var shadowCascadeClips = [];\n        var pointLightShadowMaps = [];\n\n        var dirLightHasCascade;\n        // Create textures for shadow map\n        for (var i = 0; i < this._lightsCastShadow.length; i++) {\n            var light = this._lightsCastShadow[i];\n            if (light.type === 'DIRECTIONAL_LIGHT') {\n\n                if (dirLightHasCascade) {\n                    console.warn('Only one direectional light supported with shadow cascade');\n                    continue;\n                }\n                if (light.shadowCascade > 4) {\n                    console.warn('Support at most 4 cascade');\n                    continue;\n                }\n                if (light.shadowCascade > 1) {\n                    dirLightHasCascade = light;\n                }\n\n                this.renderDirectionalLightShadow(\n                    renderer,\n                    scene,\n                    sceneCamera,\n                    light,\n                    shadowCascadeClips,\n                    directionalLightMatrices,\n                    directionalLightShadowMaps\n                );\n            }\n            else if (light.type === 'SPOT_LIGHT') {\n                this.renderSpotLightShadow(\n                    renderer,\n                    scene,\n                    light,\n                    spotLightMatrices,\n                    spotLightShadowMaps\n                );\n            }\n            else if (light.type === 'POINT_LIGHT') {\n                this.renderPointLightShadow(\n                    renderer,\n                    scene,\n                    light,\n                    pointLightShadowMaps\n                );\n            }\n\n            this._shadowMapNumber[light.type]++;\n        }\n\n        for (var lightType in this._shadowMapNumber) {\n            var number = this._shadowMapNumber[lightType];\n            var key = lightType + '_SHADOWMAP_COUNT';\n            for (var i = 0; i < this._receivers.length; i++) {\n                var mesh = this._receivers[i];\n                var material = mesh.material;\n                if (material.fragmentDefines[key] !== number) {\n                    if (number > 0) {\n                        material.define('fragment', key, number);\n                    }\n                    else if (material.isDefined('fragment', key)) {\n                        material.undefine('fragment', key);\n                    }\n                }\n            }\n        }\n        for (var i = 0; i < this._receivers.length; i++) {\n            var mesh = this._receivers[i];\n            var material = mesh.material;\n            if (dirLightHasCascade) {\n                material.define('fragment', 'SHADOW_CASCADE', dirLightHasCascade.shadowCascade);\n            }\n            else {\n                material.undefine('fragment', 'SHADOW_CASCADE');\n            }\n        }\n\n        var shadowUniforms = scene.shadowUniforms;\n\n        function getSize(texture) {\n            return texture.height;\n        }\n        if (directionalLightShadowMaps.length > 0) {\n            var directionalLightShadowMapSizes = directionalLightShadowMaps.map(getSize);\n            shadowUniforms.directionalLightShadowMaps = { value: directionalLightShadowMaps, type: 'tv' };\n            shadowUniforms.directionalLightMatrices = { value: directionalLightMatrices, type: 'm4v' };\n            shadowUniforms.directionalLightShadowMapSizes = { value: directionalLightShadowMapSizes, type: '1fv' };\n            if (dirLightHasCascade) {\n                var shadowCascadeClipsNear = shadowCascadeClips.slice();\n                var shadowCascadeClipsFar = shadowCascadeClips.slice();\n                shadowCascadeClipsNear.pop();\n                shadowCascadeClipsFar.shift();\n\n                // Iterate from far to near\n                shadowCascadeClipsNear.reverse();\n                shadowCascadeClipsFar.reverse();\n                // directionalLightShadowMaps.reverse();\n                directionalLightMatrices.reverse();\n                shadowUniforms.shadowCascadeClipsNear = { value: shadowCascadeClipsNear, type: '1fv' };\n                shadowUniforms.shadowCascadeClipsFar = { value: shadowCascadeClipsFar, type: '1fv' };\n            }\n        }\n\n        if (spotLightShadowMaps.length > 0) {\n            var spotLightShadowMapSizes = spotLightShadowMaps.map(getSize);\n            var shadowUniforms = scene.shadowUniforms;\n            shadowUniforms.spotLightShadowMaps = { value: spotLightShadowMaps, type: 'tv' };\n            shadowUniforms.spotLightMatrices = { value: spotLightMatrices, type: 'm4v' };\n            shadowUniforms.spotLightShadowMapSizes = { value: spotLightShadowMapSizes, type: '1fv' };\n        }\n\n        if (pointLightShadowMaps.length > 0) {\n            shadowUniforms.pointLightShadowMaps = { value: pointLightShadowMaps, type: 'tv' };\n        }\n    },\n\n    renderDirectionalLightShadow: (function () {\n\n        var splitFrustum = new Frustum();\n        var splitProjMatrix = new Matrix4();\n        var cropBBox = new BoundingBox();\n        var cropMatrix = new Matrix4();\n        var lightViewMatrix = new Matrix4();\n        var lightViewProjMatrix = new Matrix4();\n        var lightProjMatrix = new Matrix4();\n\n        return function (renderer, scene, sceneCamera, light, shadowCascadeClips, directionalLightMatrices, directionalLightShadowMaps) {\n\n            var defaultShadowMaterial = this._getDepthMaterial(light);\n            var passConfig = {\n                getMaterial: function (renderable) {\n                    return renderable.shadowDepthMaterial || defaultShadowMaterial;\n                },\n                isMaterialChanged: isDepthMaterialChanged,\n                getUniform: getDepthMaterialUniform,\n                ifRender: function (renderable) {\n                    return renderable.castShadow;\n                },\n                sortCompare: Renderer.opaqueSortCompare\n            };\n\n            // First frame\n            if (!scene.viewBoundingBoxLastFrame.isFinite()) {\n                var boundingBox = scene.getBoundingBox();\n                scene.viewBoundingBoxLastFrame\n                    .copy(boundingBox).applyTransform(sceneCamera.viewMatrix);\n            }\n            // Considering moving speed since the bounding box is from last frame\n            // TODO: add a bias\n            var clippedFar = Math.min(-scene.viewBoundingBoxLastFrame.min.z, sceneCamera.far);\n            var clippedNear = Math.max(-scene.viewBoundingBoxLastFrame.max.z, sceneCamera.near);\n\n            var lightCamera = this._getDirectionalLightCamera(light, scene, sceneCamera);\n\n            var lvpMat4Arr = lightViewProjMatrix.array;\n            lightProjMatrix.copy(lightCamera.projectionMatrix);\n            mat4.invert(lightViewMatrix.array, lightCamera.worldTransform.array);\n            mat4.multiply(lightViewMatrix.array, lightViewMatrix.array, sceneCamera.worldTransform.array);\n            mat4.multiply(lvpMat4Arr, lightProjMatrix.array, lightViewMatrix.array);\n\n            var clipPlanes = [];\n            var isPerspective = sceneCamera instanceof PerspectiveCamera;\n\n            var scaleZ = (sceneCamera.near + sceneCamera.far) / (sceneCamera.near - sceneCamera.far);\n            var offsetZ = 2 * sceneCamera.near * sceneCamera.far / (sceneCamera.near - sceneCamera.far);\n            for (var i = 0; i <= light.shadowCascade; i++) {\n                var clog = clippedNear * Math.pow(clippedFar / clippedNear, i / light.shadowCascade);\n                var cuni = clippedNear + (clippedFar - clippedNear) * i / light.shadowCascade;\n                var c = clog * light.cascadeSplitLogFactor + cuni * (1 - light.cascadeSplitLogFactor);\n                clipPlanes.push(c);\n                shadowCascadeClips.push(-(-c * scaleZ + offsetZ) / -c);\n            }\n            var texture = this._getTexture(light, light.shadowCascade);\n            directionalLightShadowMaps.push(texture);\n\n            var viewport = renderer.viewport;\n\n            var _gl = renderer.gl;\n            this._frameBuffer.attach(texture);\n            this._frameBuffer.bind(renderer);\n            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n            for (var i = 0; i < light.shadowCascade; i++) {\n                // Get the splitted frustum\n                var nearPlane = clipPlanes[i];\n                var farPlane = clipPlanes[i + 1];\n                if (isPerspective) {\n                    mat4.perspective(splitProjMatrix.array, sceneCamera.fov / 180 * Math.PI, sceneCamera.aspect, nearPlane, farPlane);\n                }\n                else {\n                    mat4.ortho(\n                        splitProjMatrix.array,\n                        sceneCamera.left, sceneCamera.right, sceneCamera.bottom, sceneCamera.top,\n                        nearPlane, farPlane\n                    );\n                }\n                splitFrustum.setFromProjection(splitProjMatrix);\n                splitFrustum.getTransformedBoundingBox(cropBBox, lightViewMatrix);\n                cropBBox.applyProjection(lightProjMatrix);\n                var _min = cropBBox.min.array;\n                var _max = cropBBox.max.array;\n                _min[0] = Math.max(_min[0], -1);\n                _min[1] = Math.max(_min[1], -1);\n                _max[0] = Math.min(_max[0], 1);\n                _max[1] = Math.min(_max[1], 1);\n                cropMatrix.ortho(_min[0], _max[0], _min[1], _max[1], 1, -1);\n                lightCamera.projectionMatrix.multiplyLeft(cropMatrix);\n\n                var shadowSize = light.shadowResolution || 512;\n\n                // Reversed, left to right => far to near\n                renderer.setViewport((light.shadowCascade - i - 1) * shadowSize, 0, shadowSize, shadowSize, 1);\n\n                var renderList = scene.updateRenderList(lightCamera);\n                renderer.renderPass(renderList.opaque, lightCamera, passConfig);\n\n                // Filter for VSM\n                if (this.softShadow === ShadowMapPass.VSM) {\n                    this._gaussianFilter(renderer, texture, texture.width);\n                }\n\n                var matrix = new Matrix4();\n                matrix.copy(lightCamera.viewMatrix)\n                    .multiplyLeft(lightCamera.projectionMatrix);\n\n                directionalLightMatrices.push(matrix.array);\n\n                lightCamera.projectionMatrix.copy(lightProjMatrix);\n            }\n\n            this._frameBuffer.unbind(renderer);\n\n            renderer.setViewport(viewport);\n        };\n    })(),\n\n    renderSpotLightShadow: function (renderer, scene, light, spotLightMatrices, spotLightShadowMaps) {\n\n        var texture = this._getTexture(light);\n        var lightCamera = this._getSpotLightCamera(light);\n        var _gl = renderer.gl;\n\n        this._frameBuffer.attach(texture);\n        this._frameBuffer.bind(renderer);\n\n        _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n        var defaultShadowMaterial = this._getDepthMaterial(light);\n        var passConfig = {\n            getMaterial: function (renderable) {\n                return renderable.shadowDepthMaterial || defaultShadowMaterial;\n            },\n            isMaterialChanged: isDepthMaterialChanged,\n            getUniform: getDepthMaterialUniform,\n            ifRender: function (renderable) {\n                return renderable.castShadow;\n            },\n            sortCompare: Renderer.opaqueSortCompare\n        };\n\n        var renderList = scene.updateRenderList(lightCamera);\n        renderer.renderPass(renderList.opaque, lightCamera, passConfig);\n\n        this._frameBuffer.unbind(renderer);\n\n        // Filter for VSM\n        if (this.softShadow === ShadowMapPass.VSM) {\n            this._gaussianFilter(renderer, texture, texture.width);\n        }\n\n        var matrix = new Matrix4();\n        matrix.copy(lightCamera.worldTransform)\n            .invert()\n            .multiplyLeft(lightCamera.projectionMatrix);\n\n        spotLightShadowMaps.push(texture);\n        spotLightMatrices.push(matrix.array);\n    },\n\n    renderPointLightShadow: function (renderer, scene, light, pointLightShadowMaps) {\n        var texture = this._getTexture(light);\n        var _gl = renderer.gl;\n        pointLightShadowMaps.push(texture);\n\n        var defaultShadowMaterial = this._getDepthMaterial(light);\n        var passConfig = {\n            getMaterial: function (renderable) {\n                return renderable.shadowDepthMaterial || defaultShadowMaterial;\n            },\n            getUniform: getDepthMaterialUniform,\n            sortCompare: Renderer.opaqueSortCompare\n        };\n\n        var renderListEachSide = {\n            px: [], py: [], pz: [], nx: [], ny: [], nz: []\n        };\n        var bbox = new BoundingBox();\n        var lightWorldPosition = light.getWorldPosition().array;\n        var lightBBox = new BoundingBox();\n        var range = light.range;\n        lightBBox.min.setArray(lightWorldPosition);\n        lightBBox.max.setArray(lightWorldPosition);\n        var extent = new Vector3(range, range, range);\n        lightBBox.max.add(extent);\n        lightBBox.min.sub(extent);\n\n        var targetsNeedRender = { px: false, py: false, pz: false, nx: false, ny: false, nz: false };\n        scene.traverse(function (renderable) {\n            if (renderable.isRenderable() && renderable.castShadow) {\n                var geometry = renderable.geometry;\n                if (!geometry.boundingBox) {\n                    for (var i = 0; i < targets.length; i++) {\n                        renderListEachSide[targets[i]].push(renderable);\n                    }\n                    return;\n                }\n                bbox.transformFrom(geometry.boundingBox, renderable.worldTransform);\n                if (!bbox.intersectBoundingBox(lightBBox)) {\n                    return;\n                }\n\n                bbox.updateVertices();\n                for (var i = 0; i < targets.length; i++) {\n                    targetsNeedRender[targets[i]] = false;\n                }\n                for (var i = 0; i < 8; i++) {\n                    var vtx = bbox.vertices[i];\n                    var x = vtx[0] - lightWorldPosition[0];\n                    var y = vtx[1] - lightWorldPosition[1];\n                    var z = vtx[2] - lightWorldPosition[2];\n                    var absx = Math.abs(x);\n                    var absy = Math.abs(y);\n                    var absz = Math.abs(z);\n                    if (absx > absy) {\n                        if (absx > absz) {\n                            targetsNeedRender[x > 0 ? 'px' : 'nx'] = true;\n                        }\n                        else {\n                            targetsNeedRender[z > 0 ? 'pz' : 'nz'] = true;\n                        }\n                    }\n                    else {\n                        if (absy > absz) {\n                            targetsNeedRender[y > 0 ? 'py' : 'ny'] = true;\n                        }\n                        else {\n                            targetsNeedRender[z > 0 ? 'pz' : 'nz'] = true;\n                        }\n                    }\n                }\n                for (var i = 0; i < targets.length; i++) {\n                    if (targetsNeedRender[targets[i]]) {\n                        renderListEachSide[targets[i]].push(renderable);\n                    }\n                }\n            }\n        });\n\n        for (var i = 0; i < 6; i++) {\n            var target = targets[i];\n            var camera = this._getPointLightCamera(light, target);\n\n            this._frameBuffer.attach(texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n            this._frameBuffer.bind(renderer);\n            _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);\n\n            renderer.renderPass(renderListEachSide[target], camera, passConfig);\n        }\n\n        this._frameBuffer.unbind(renderer);\n    },\n\n    _getDepthMaterial: function (light) {\n        var shadowMaterial = this._lightMaterials[light.__uid__];\n        var isPointLight = light.type === 'POINT_LIGHT';\n        if (!shadowMaterial) {\n            var shaderPrefix = isPointLight ? 'clay.sm.distance.' : 'clay.sm.depth.';\n            shadowMaterial = new Material({\n                precision: this.precision,\n                shader: new Shader(Shader.source(shaderPrefix + 'vertex'), Shader.source(shaderPrefix + 'fragment'))\n            });\n\n            this._lightMaterials[light.__uid__] = shadowMaterial;\n        }\n        if (light.shadowSlopeScale != null) {\n            shadowMaterial.setUniform('slopeScale', light.shadowSlopeScale);\n        }\n        if (light.shadowBias != null) {\n            shadowMaterial.setUniform('bias', light.shadowBias);\n        }\n        if (this.softShadow === ShadowMapPass.VSM) {\n            shadowMaterial.define('fragment', 'USE_VSM');\n        }\n        else {\n            shadowMaterial.undefine('fragment', 'USE_VSM');\n        }\n\n        if (isPointLight) {\n            shadowMaterial.set('lightPosition', light.getWorldPosition().array);\n            shadowMaterial.set('range', light.range);\n        }\n\n        return shadowMaterial;\n    },\n\n    _gaussianFilter: function (renderer, texture, size) {\n        var parameter = {\n            width: size,\n            height: size,\n            type: Texture.FLOAT\n        };\n        var tmpTexture = this._texturePool.get(parameter);\n\n        this._frameBuffer.attach(tmpTexture);\n        this._frameBuffer.bind(renderer);\n        this._gaussianPassH.setUniform('texture', texture);\n        this._gaussianPassH.setUniform('textureWidth', size);\n        this._gaussianPassH.render(renderer);\n\n        this._frameBuffer.attach(texture);\n        this._gaussianPassV.setUniform('texture', tmpTexture);\n        this._gaussianPassV.setUniform('textureHeight', size);\n        this._gaussianPassV.render(renderer);\n        this._frameBuffer.unbind(renderer);\n\n        this._texturePool.put(tmpTexture);\n    },\n\n    _getTexture: function (light, cascade) {\n        var key = light.__uid__;\n        var texture = this._textures[key];\n        var resolution = light.shadowResolution || 512;\n        cascade = cascade || 1;\n        if (!texture) {\n            if (light.type === 'POINT_LIGHT') {\n                texture = new TextureCube();\n            }\n            else {\n                texture = new Texture2D();\n            }\n            // At most 4 cascade\n            // TODO share with height ?\n            texture.width = resolution * cascade;\n            texture.height = resolution;\n            if (this.softShadow === ShadowMapPass.VSM) {\n                texture.type = Texture.FLOAT;\n                texture.anisotropic = 4;\n            }\n            else {\n                texture.minFilter = glenum.NEAREST;\n                texture.magFilter = glenum.NEAREST;\n                texture.useMipmap = false;\n            }\n            this._textures[key] = texture;\n        }\n\n        return texture;\n    },\n\n    _getPointLightCamera: function (light, target) {\n        if (!this._lightCameras.point) {\n            this._lightCameras.point = {\n                px: new PerspectiveCamera(),\n                nx: new PerspectiveCamera(),\n                py: new PerspectiveCamera(),\n                ny: new PerspectiveCamera(),\n                pz: new PerspectiveCamera(),\n                nz: new PerspectiveCamera()\n            };\n        }\n        var camera = this._lightCameras.point[target];\n\n        camera.far = light.range;\n        camera.fov = 90;\n        camera.position.set(0, 0, 0);\n        switch (target) {\n            case 'px':\n                camera.lookAt(Vector3.POSITIVE_X, Vector3.NEGATIVE_Y);\n                break;\n            case 'nx':\n                camera.lookAt(Vector3.NEGATIVE_X, Vector3.NEGATIVE_Y);\n                break;\n            case 'py':\n                camera.lookAt(Vector3.POSITIVE_Y, Vector3.POSITIVE_Z);\n                break;\n            case 'ny':\n                camera.lookAt(Vector3.NEGATIVE_Y, Vector3.NEGATIVE_Z);\n                break;\n            case 'pz':\n                camera.lookAt(Vector3.POSITIVE_Z, Vector3.NEGATIVE_Y);\n                break;\n            case 'nz':\n                camera.lookAt(Vector3.NEGATIVE_Z, Vector3.NEGATIVE_Y);\n                break;\n        }\n        light.getWorldPosition(camera.position);\n        camera.update();\n\n        return camera;\n    },\n\n    _getDirectionalLightCamera: (function () {\n        var lightViewMatrix = new Matrix4();\n        var sceneViewBoundingBox = new BoundingBox();\n        var lightViewBBox = new BoundingBox();\n        // Camera of directional light will be adjusted\n        // to contain the view frustum and scene bounding box as tightly as possible\n        return function (light, scene, sceneCamera) {\n            if (!this._lightCameras.directional) {\n                this._lightCameras.directional = new OrthoCamera();\n            }\n            var camera = this._lightCameras.directional;\n\n            sceneViewBoundingBox.copy(scene.viewBoundingBoxLastFrame);\n            sceneViewBoundingBox.intersection(sceneCamera.frustum.boundingBox);\n            // Move to the center of frustum(in world space)\n            camera.position\n                .copy(sceneViewBoundingBox.min)\n                .add(sceneViewBoundingBox.max)\n                .scale(0.5)\n                .transformMat4(sceneCamera.worldTransform);\n            camera.rotation.copy(light.rotation);\n            camera.scale.copy(light.scale);\n            camera.updateWorldTransform();\n\n            // Transform to light view space\n            Matrix4.invert(lightViewMatrix, camera.worldTransform);\n            Matrix4.multiply(lightViewMatrix, lightViewMatrix, sceneCamera.worldTransform);\n\n            lightViewBBox.copy(sceneViewBoundingBox).applyTransform(lightViewMatrix);\n\n            var min = lightViewBBox.min.array;\n            var max = lightViewBBox.max.array;\n\n            // Move camera to adjust the near to 0\n            camera.position.set((min[0] + max[0]) / 2, (min[1] + max[1]) / 2, max[2])\n                .transformMat4(camera.worldTransform);\n            camera.near = 0;\n            camera.far = -min[2] + max[2];\n            // Make sure receivers not in the frustum will stil receive the shadow.\n            if (isNaN(this.lightFrustumBias)) {\n                camera.far *= 4;\n            }\n            else {\n                camera.far += this.lightFrustumBias;\n            }\n            camera.left = min[0];\n            camera.right = max[0];\n            camera.top = max[1];\n            camera.bottom = min[1];\n            camera.update(true);\n\n            return camera;\n        };\n    })(),\n\n    _getSpotLightCamera: function (light) {\n        if (!this._lightCameras.spot) {\n            this._lightCameras.spot = new PerspectiveCamera();\n        }\n        var camera = this._lightCameras.spot;\n        // Update properties\n        camera.fov = light.penumbraAngle * 2;\n        camera.far = light.range;\n        camera.worldTransform.copy(light.worldTransform);\n        camera.updateProjectionMatrix();\n        mat4.invert(camera.viewMatrix.array, camera.worldTransform.array);\n\n        return camera;\n    },\n\n    /**\n     * @param  {clay.Renderer|WebGLRenderingContext} [renderer]\n     * @memberOf clay.prePass.ShadowMap.prototype\n     */\n    // PENDING Renderer or WebGLRenderingContext\n    dispose: function (renderer) {\n        var _gl = renderer.gl || renderer;\n\n        if (this._frameBuffer) {\n            this._frameBuffer.dispose(_gl);\n        }\n\n        for (var name in this._textures) {\n            this._textures[name].dispose(_gl);\n        }\n\n        this._texturePool.clear(renderer.gl);\n\n        this._depthMaterials = {};\n        this._distanceMaterials = {};\n        this._textures = {};\n        this._lightCameras = {};\n        this._shadowMapNumber = {\n            'POINT_LIGHT': 0,\n            'DIRECTIONAL_LIGHT': 0,\n            'SPOT_LIGHT': 0\n        };\n        this._meshMaterials = {};\n\n        for (var i = 0; i < this._receivers.length; i++) {\n            var mesh = this._receivers[i];\n            // Mesh may be disposed\n            if (mesh.material) {\n                var material = mesh.material;\n                material.undefine('fragment', 'POINT_LIGHT_SHADOW_COUNT');\n                material.undefine('fragment', 'DIRECTIONAL_LIGHT_SHADOW_COUNT');\n                material.undefine('fragment', 'AMBIENT_LIGHT_SHADOW_COUNT');\n                material.set('shadowEnabled', 0);\n            }\n        }\n\n        this._receivers = [];\n        this._lightsCastShadow = [];\n    }\n});\n\n/**\n * @name clay.prePass.ShadowMap.VSM\n * @type {number}\n */\nShadowMapPass.VSM = 1;\n\n/**\n * @name clay.prePass.ShadowMap.PCF\n * @type {number}\n */\nShadowMapPass.PCF = 2;\n\nexport default ShadowMapPass;\n","export default \"@export clay.compositor.coloradjust\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\nuniform float brightness : 0.0;\\nuniform float contrast : 1.0;\\nuniform float exposure : 0.0;\\nuniform float gamma : 1.0;\\nuniform float saturation : 1.0;\\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\\nvoid main()\\n{\\n vec4 tex = texture2D( texture, v_Texcoord);\\n vec3 color = clamp(tex.rgb + vec3(brightness), 0.0, 1.0);\\n color = clamp( (color-vec3(0.5))*contrast+vec3(0.5), 0.0, 1.0);\\n color = clamp( color * pow(2.0, exposure), 0.0, 1.0);\\n color = clamp( pow(color, vec3(gamma)), 0.0, 1.0);\\n float luminance = dot( color, w );\\n color = mix(vec3(luminance), color, saturation);\\n gl_FragColor = vec4(color, tex.a);\\n}\\n@end\\n@export clay.compositor.brightness\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\nuniform float brightness : 0.0;\\nvoid main()\\n{\\n vec4 tex = texture2D( texture, v_Texcoord);\\n vec3 color = tex.rgb + vec3(brightness);\\n gl_FragColor = vec4(color, tex.a);\\n}\\n@end\\n@export clay.compositor.contrast\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\nuniform float contrast : 1.0;\\nvoid main()\\n{\\n vec4 tex = texture2D( texture, v_Texcoord);\\n vec3 color = (tex.rgb-vec3(0.5))*contrast+vec3(0.5);\\n gl_FragColor = vec4(color, tex.a);\\n}\\n@end\\n@export clay.compositor.exposure\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\nuniform float exposure : 0.0;\\nvoid main()\\n{\\n vec4 tex = texture2D(texture, v_Texcoord);\\n vec3 color = tex.rgb * pow(2.0, exposure);\\n gl_FragColor = vec4(color, tex.a);\\n}\\n@end\\n@export clay.compositor.gamma\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\nuniform float gamma : 1.0;\\nvoid main()\\n{\\n vec4 tex = texture2D(texture, v_Texcoord);\\n vec3 color = pow(tex.rgb, vec3(gamma));\\n gl_FragColor = vec4(color, tex.a);\\n}\\n@end\\n@export clay.compositor.saturation\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\nuniform float saturation : 1.0;\\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\\nvoid main()\\n{\\n vec4 tex = texture2D(texture, v_Texcoord);\\n vec3 color = tex.rgb;\\n float luminance = dot(color, w);\\n color = mix(vec3(luminance), color, saturation);\\n gl_FragColor = vec4(color, tex.a);\\n}\\n@end\";\n","export default \"@export clay.compositor.hdr.log_lum\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\\n@import clay.util.rgbm\\nvoid main()\\n{\\n vec4 tex = decodeHDR(texture2D(texture, v_Texcoord));\\n float luminance = dot(tex.rgb, w);\\n luminance = log(luminance + 0.001);\\n gl_FragColor = encodeHDR(vec4(vec3(luminance), 1.0));\\n}\\n@end\\n@export clay.compositor.hdr.lum_adaption\\nvarying vec2 v_Texcoord;\\nuniform sampler2D adaptedLum;\\nuniform sampler2D currentLum;\\nuniform float frameTime : 0.02;\\n@import clay.util.rgbm\\nvoid main()\\n{\\n float fAdaptedLum = decodeHDR(texture2D(adaptedLum, vec2(0.5, 0.5))).r;\\n float fCurrentLum = exp(encodeHDR(texture2D(currentLum, vec2(0.5, 0.5))).r);\\n fAdaptedLum += (fCurrentLum - fAdaptedLum) * (1.0 - pow(0.98, 30.0 * frameTime));\\n gl_FragColor = encodeHDR(vec4(vec3(fAdaptedLum), 1.0));\\n}\\n@end\\n@export clay.compositor.lum\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\\nvoid main()\\n{\\n vec4 tex = texture2D( texture, v_Texcoord );\\n float luminance = dot(tex.rgb, w);\\n gl_FragColor = vec4(vec3(luminance), 1.0);\\n}\\n@end\";\n","export default \"@export clay.compositor.vignette\\n#define OUTPUT_ALPHA\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\nuniform float darkness: 1;\\nuniform float offset: 1;\\n@import clay.util.rgbm\\nvoid main()\\n{\\n vec4 texel = decodeHDR(texture2D(texture, v_Texcoord));\\n gl_FragColor.rgb = texel.rgb;\\n vec2 uv = (v_Texcoord - vec2(0.5)) * vec2(offset);\\n gl_FragColor = encodeHDR(vec4(mix(texel.rgb, vec3(1.0 - darkness), dot(uv, uv)), texel.a));\\n}\\n@end\";\n","export default \"@export clay.compositor.lensflare\\n#define SAMPLE_NUMBER 8\\nuniform sampler2D texture;\\nuniform sampler2D lenscolor;\\nuniform vec2 textureSize : [512, 512];\\nuniform float dispersal : 0.3;\\nuniform float haloWidth : 0.4;\\nuniform float distortion : 1.0;\\nvarying vec2 v_Texcoord;\\n@import clay.util.rgbm\\nvec4 textureDistorted(\\n in vec2 texcoord,\\n in vec2 direction,\\n in vec3 distortion\\n) {\\n return vec4(\\n decodeHDR(texture2D(texture, texcoord + direction * distortion.r)).r,\\n decodeHDR(texture2D(texture, texcoord + direction * distortion.g)).g,\\n decodeHDR(texture2D(texture, texcoord + direction * distortion.b)).b,\\n 1.0\\n );\\n}\\nvoid main()\\n{\\n vec2 texcoord = -v_Texcoord + vec2(1.0); vec2 textureOffset = 1.0 / textureSize;\\n vec2 ghostVec = (vec2(0.5) - texcoord) * dispersal;\\n vec2 haloVec = normalize(ghostVec) * haloWidth;\\n vec3 distortion = vec3(-textureOffset.x * distortion, 0.0, textureOffset.x * distortion);\\n vec4 result = vec4(0.0);\\n for (int i = 0; i < SAMPLE_NUMBER; i++)\\n {\\n vec2 offset = fract(texcoord + ghostVec * float(i));\\n float weight = length(vec2(0.5) - offset) / length(vec2(0.5));\\n weight = pow(1.0 - weight, 10.0);\\n result += textureDistorted(offset, normalize(ghostVec), distortion) * weight;\\n }\\n result *= texture2D(lenscolor, vec2(length(vec2(0.5) - texcoord)) / length(vec2(0.5)));\\n float weight = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5));\\n weight = pow(1.0 - weight, 10.0);\\n vec2 offset = fract(texcoord + haloVec);\\n result += textureDistorted(offset, normalize(ghostVec), distortion) * weight;\\n gl_FragColor = result;\\n}\\n@end\";\n","import coloradjustEssl from './source/compositor/coloradjust.glsl.js';\nimport blurEssl from './source/compositor/blur.glsl.js';\nimport lumEssl from './source/compositor/lum.glsl.js';\nimport lutEssl from './source/compositor/lut.glsl.js';\nimport vigentteEssl from './source/compositor/vignette.glsl.js';\nimport outputEssl from './source/compositor/output.glsl.js';\nimport brightEssl from './source/compositor/bright.glsl.js';\nimport downsampleEssl from './source/compositor/downsample.glsl.js';\nimport upsampleEssl from './source/compositor/upsample.glsl.js';\nimport hdrEssl from './source/compositor/hdr.glsl.js';\nimport lensflareEssl from './source/compositor/lensflare.glsl.js';\nimport blendEssl from './source/compositor/blend.glsl.js';\nimport fxaaEssl from './source/compositor/fxaa.glsl.js';\n// import fxaa3Essl from './source/compositor/fxaa3.glsl.js';\n\n// TODO Must export a module and be used in the other modules. Or it will be tree shaked\nexport default function register(Shader) {\n    // Some build in shaders\n    Shader['import'](coloradjustEssl);\n    Shader['import'](blurEssl);\n    Shader['import'](lumEssl);\n    Shader['import'](lutEssl);\n    Shader['import'](vigentteEssl);\n    Shader['import'](outputEssl);\n    Shader['import'](brightEssl);\n    Shader['import'](downsampleEssl);\n    Shader['import'](upsampleEssl);\n    Shader['import'](hdrEssl);\n    Shader['import'](lensflareEssl);\n    Shader['import'](blendEssl);\n\n    Shader['import'](fxaaEssl);\n\n}","export default \"@export clay.compositor.blend\\n#define SHADER_NAME blend\\n#ifdef TEXTURE1_ENABLED\\nuniform sampler2D texture1;\\nuniform float weight1 : 1.0;\\n#endif\\n#ifdef TEXTURE2_ENABLED\\nuniform sampler2D texture2;\\nuniform float weight2 : 1.0;\\n#endif\\n#ifdef TEXTURE3_ENABLED\\nuniform sampler2D texture3;\\nuniform float weight3 : 1.0;\\n#endif\\n#ifdef TEXTURE4_ENABLED\\nuniform sampler2D texture4;\\nuniform float weight4 : 1.0;\\n#endif\\n#ifdef TEXTURE5_ENABLED\\nuniform sampler2D texture5;\\nuniform float weight5 : 1.0;\\n#endif\\n#ifdef TEXTURE6_ENABLED\\nuniform sampler2D texture6;\\nuniform float weight6 : 1.0;\\n#endif\\nvarying vec2 v_Texcoord;\\n@import clay.util.rgbm\\nvoid main()\\n{\\n vec4 tex = vec4(0.0);\\n#ifdef TEXTURE1_ENABLED\\n tex += decodeHDR(texture2D(texture1, v_Texcoord)) * weight1;\\n#endif\\n#ifdef TEXTURE2_ENABLED\\n tex += decodeHDR(texture2D(texture2, v_Texcoord)) * weight2;\\n#endif\\n#ifdef TEXTURE3_ENABLED\\n tex += decodeHDR(texture2D(texture3, v_Texcoord)) * weight3;\\n#endif\\n#ifdef TEXTURE4_ENABLED\\n tex += decodeHDR(texture2D(texture4, v_Texcoord)) * weight4;\\n#endif\\n#ifdef TEXTURE5_ENABLED\\n tex += decodeHDR(texture2D(texture5, v_Texcoord)) * weight5;\\n#endif\\n#ifdef TEXTURE6_ENABLED\\n tex += decodeHDR(texture2D(texture6, v_Texcoord)) * weight6;\\n#endif\\n gl_FragColor = encodeHDR(tex);\\n}\\n@end\";\n","export default \"@export clay.compositor.kernel.gaussian_9\\nfloat gaussianKernel[9];\\ngaussianKernel[0] = 0.07;\\ngaussianKernel[1] = 0.09;\\ngaussianKernel[2] = 0.12;\\ngaussianKernel[3] = 0.14;\\ngaussianKernel[4] = 0.16;\\ngaussianKernel[5] = 0.14;\\ngaussianKernel[6] = 0.12;\\ngaussianKernel[7] = 0.09;\\ngaussianKernel[8] = 0.07;\\n@end\\n@export clay.compositor.kernel.gaussian_13\\nfloat gaussianKernel[13];\\ngaussianKernel[0] = 0.02;\\ngaussianKernel[1] = 0.03;\\ngaussianKernel[2] = 0.06;\\ngaussianKernel[3] = 0.08;\\ngaussianKernel[4] = 0.11;\\ngaussianKernel[5] = 0.13;\\ngaussianKernel[6] = 0.14;\\ngaussianKernel[7] = 0.13;\\ngaussianKernel[8] = 0.11;\\ngaussianKernel[9] = 0.08;\\ngaussianKernel[10] = 0.06;\\ngaussianKernel[11] = 0.03;\\ngaussianKernel[12] = 0.02;\\n@end\\n@export clay.compositor.gaussian_blur\\n#define SHADER_NAME gaussian_blur\\nuniform sampler2D texture;varying vec2 v_Texcoord;\\nuniform float blurSize : 2.0;\\nuniform vec2 textureSize : [512.0, 512.0];\\nuniform float blurDir : 0.0;\\n@import clay.util.rgbm\\n@import clay.util.clamp_sample\\nvoid main (void)\\n{\\n @import clay.compositor.kernel.gaussian_9\\n vec2 off = blurSize / textureSize;\\n off *= vec2(1.0 - blurDir, blurDir);\\n vec4 sum = vec4(0.0);\\n float weightAll = 0.0;\\n for (int i = 0; i < 9; i++) {\\n float w = gaussianKernel[i];\\n vec4 texel = decodeHDR(clampSample(texture, v_Texcoord + float(i - 4) * off));\\n sum += texel * w;\\n weightAll += w;\\n }\\n gl_FragColor = encodeHDR(sum / max(weightAll, 0.01));\\n}\\n@end\\n\";\n","export default \"@export clay.compositor.bright\\nuniform sampler2D texture;\\nuniform float threshold : 1;\\nuniform float scale : 1.0;\\nuniform vec2 textureSize: [512, 512];\\nvarying vec2 v_Texcoord;\\nconst vec3 lumWeight = vec3(0.2125, 0.7154, 0.0721);\\n@import clay.util.rgbm\\nvec4 median(vec4 a, vec4 b, vec4 c)\\n{\\n return a + b + c - min(min(a, b), c) - max(max(a, b), c);\\n}\\nvoid main()\\n{\\n vec4 texel = decodeHDR(texture2D(texture, v_Texcoord));\\n#ifdef ANTI_FLICKER\\n vec3 d = 1.0 / textureSize.xyx * vec3(1.0, 1.0, 0.0);\\n vec4 s1 = decodeHDR(texture2D(texture, v_Texcoord - d.xz));\\n vec4 s2 = decodeHDR(texture2D(texture, v_Texcoord + d.xz));\\n vec4 s3 = decodeHDR(texture2D(texture, v_Texcoord - d.zy));\\n vec4 s4 = decodeHDR(texture2D(texture, v_Texcoord + d.zy));\\n texel = median(median(texel, s1, s2), s3, s4);\\n#endif\\n float lum = dot(texel.rgb , lumWeight);\\n vec4 color;\\n if (lum > threshold && texel.a > 0.0)\\n {\\n color = vec4(texel.rgb * scale, texel.a * scale);\\n }\\n else\\n {\\n color = vec4(0.0);\\n }\\n gl_FragColor = encodeHDR(color);\\n}\\n@end\\n\";\n","export default \"@export clay.compositor.downsample\\nuniform sampler2D texture;\\nuniform vec2 textureSize : [512, 512];\\nvarying vec2 v_Texcoord;\\n@import clay.util.rgbm\\nfloat brightness(vec3 c)\\n{\\n return max(max(c.r, c.g), c.b);\\n}\\n@import clay.util.clamp_sample\\nvoid main()\\n{\\n vec4 d = vec4(-1.0, -1.0, 1.0, 1.0) / textureSize.xyxy;\\n#ifdef ANTI_FLICKER\\n vec3 s1 = decodeHDR(clampSample(texture, v_Texcoord + d.xy)).rgb;\\n vec3 s2 = decodeHDR(clampSample(texture, v_Texcoord + d.zy)).rgb;\\n vec3 s3 = decodeHDR(clampSample(texture, v_Texcoord + d.xw)).rgb;\\n vec3 s4 = decodeHDR(clampSample(texture, v_Texcoord + d.zw)).rgb;\\n float s1w = 1.0 / (brightness(s1) + 1.0);\\n float s2w = 1.0 / (brightness(s2) + 1.0);\\n float s3w = 1.0 / (brightness(s3) + 1.0);\\n float s4w = 1.0 / (brightness(s4) + 1.0);\\n float oneDivideSum = 1.0 / (s1w + s2w + s3w + s4w);\\n vec4 color = vec4(\\n (s1 * s1w + s2 * s2w + s3 * s3w + s4 * s4w) * oneDivideSum,\\n 1.0\\n );\\n#else\\n vec4 color = decodeHDR(clampSample(texture, v_Texcoord + d.xy));\\n color += decodeHDR(clampSample(texture, v_Texcoord + d.zy));\\n color += decodeHDR(clampSample(texture, v_Texcoord + d.xw));\\n color += decodeHDR(clampSample(texture, v_Texcoord + d.zw));\\n color *= 0.25;\\n#endif\\n gl_FragColor = encodeHDR(color);\\n}\\n@end\";\n","export default \"@export clay.compositor.fxaa\\nuniform sampler2D texture;\\nuniform vec4 viewport : VIEWPORT;\\nvarying vec2 v_Texcoord;\\n#define FXAA_REDUCE_MIN (1.0/128.0)\\n#define FXAA_REDUCE_MUL (1.0/8.0)\\n#define FXAA_SPAN_MAX 8.0\\n@import clay.util.rgbm\\nvoid main()\\n{\\n vec2 resolution = 1.0 / viewport.zw;\\n vec3 rgbNW = decodeHDR( texture2D( texture, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ) ).xyz;\\n vec3 rgbNE = decodeHDR( texture2D( texture, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ) ).xyz;\\n vec3 rgbSW = decodeHDR( texture2D( texture, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ) ).xyz;\\n vec3 rgbSE = decodeHDR( texture2D( texture, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ) ).xyz;\\n vec4 rgbaM = decodeHDR( texture2D( texture, gl_FragCoord.xy * resolution ) );\\n vec3 rgbM = rgbaM.xyz;\\n float opacity = rgbaM.w;\\n vec3 luma = vec3( 0.299, 0.587, 0.114 );\\n float lumaNW = dot( rgbNW, luma );\\n float lumaNE = dot( rgbNE, luma );\\n float lumaSW = dot( rgbSW, luma );\\n float lumaSE = dot( rgbSE, luma );\\n float lumaM = dot( rgbM, luma );\\n float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\\n float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\\n vec2 dir;\\n dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\n dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\n float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\\n float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\\n dir = min( vec2( FXAA_SPAN_MAX, FXAA_SPAN_MAX),\\n max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\\n dir * rcpDirMin)) * resolution;\\n vec3 rgbA = decodeHDR( texture2D( texture, gl_FragCoord.xy * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ) ).xyz;\\n rgbA += decodeHDR( texture2D( texture, gl_FragCoord.xy * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ) ).xyz;\\n rgbA *= 0.5;\\n vec3 rgbB = decodeHDR( texture2D( texture, gl_FragCoord.xy * resolution + dir * -0.5 ) ).xyz;\\n rgbB += decodeHDR( texture2D( texture, gl_FragCoord.xy * resolution + dir * 0.5 ) ).xyz;\\n rgbB *= 0.25;\\n rgbB += rgbA * 0.5;\\n float lumaB = dot( rgbB, luma );\\n if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) )\\n {\\n gl_FragColor = vec4( rgbA, opacity );\\n }\\n else {\\n gl_FragColor = vec4( rgbB, opacity );\\n }\\n}\\n@end\";\n","export default \"@export clay.compositor.hdr.composite\\n#define TONEMAPPING\\nuniform sampler2D texture;\\n#ifdef BLOOM_ENABLED\\nuniform sampler2D bloom;\\n#endif\\n#ifdef LENSFLARE_ENABLED\\nuniform sampler2D lensflare;\\nuniform sampler2D lensdirt;\\n#endif\\n#ifdef LUM_ENABLED\\nuniform sampler2D lum;\\n#endif\\n#ifdef LUT_ENABLED\\nuniform sampler2D lut;\\n#endif\\n#ifdef COLOR_CORRECTION\\nuniform float brightness : 0.0;\\nuniform float contrast : 1.0;\\nuniform float saturation : 1.0;\\n#endif\\n#ifdef VIGNETTE\\nuniform float vignetteDarkness: 1.0;\\nuniform float vignetteOffset: 1.0;\\n#endif\\nuniform float exposure : 1.0;\\nuniform float bloomIntensity : 0.25;\\nuniform float lensflareIntensity : 1;\\nvarying vec2 v_Texcoord;\\n@import clay.util.srgb\\nvec3 ACESToneMapping(vec3 color)\\n{\\n const float A = 2.51;\\n const float B = 0.03;\\n const float C = 2.43;\\n const float D = 0.59;\\n const float E = 0.14;\\n return (color * (A * color + B)) / (color * (C * color + D) + E);\\n}\\nfloat eyeAdaption(float fLum)\\n{\\n return mix(0.2, fLum, 0.5);\\n}\\n#ifdef LUT_ENABLED\\nvec3 lutTransform(vec3 color) {\\n float blueColor = color.b * 63.0;\\n vec2 quad1;\\n quad1.y = floor(floor(blueColor) / 8.0);\\n quad1.x = floor(blueColor) - (quad1.y * 8.0);\\n vec2 quad2;\\n quad2.y = floor(ceil(blueColor) / 8.0);\\n quad2.x = ceil(blueColor) - (quad2.y * 8.0);\\n vec2 texPos1;\\n texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);\\n texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);\\n vec2 texPos2;\\n texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);\\n texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);\\n vec4 newColor1 = texture2D(lut, texPos1);\\n vec4 newColor2 = texture2D(lut, texPos2);\\n vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\\n return newColor.rgb;\\n}\\n#endif\\n@import clay.util.rgbm\\nvoid main()\\n{\\n vec4 texel = vec4(0.0);\\n vec4 originalTexel = vec4(0.0);\\n#ifdef TEXTURE_ENABLED\\n texel = decodeHDR(texture2D(texture, v_Texcoord));\\n originalTexel = texel;\\n#endif\\n#ifdef BLOOM_ENABLED\\n vec4 bloomTexel = decodeHDR(texture2D(bloom, v_Texcoord));\\n texel.rgb += bloomTexel.rgb * bloomIntensity;\\n texel.a += bloomTexel.a * bloomIntensity;\\n#endif\\n#ifdef LENSFLARE_ENABLED\\n texel += decodeHDR(texture2D(lensflare, v_Texcoord)) * texture2D(lensdirt, v_Texcoord) * lensflareIntensity;\\n#endif\\n texel.a = min(texel.a, 1.0);\\n#ifdef LUM_ENABLED\\n float fLum = texture2D(lum, vec2(0.5, 0.5)).r;\\n float adaptedLumDest = 3.0 / (max(0.1, 1.0 + 10.0*eyeAdaption(fLum)));\\n float exposureBias = adaptedLumDest * exposure;\\n#else\\n float exposureBias = exposure;\\n#endif\\n#ifdef TONEMAPPING\\n texel.rgb *= exposureBias;\\n texel.rgb = ACESToneMapping(texel.rgb);\\n#endif\\n texel = linearTosRGB(texel);\\n#ifdef LUT_ENABLED\\n texel.rgb = lutTransform(clamp(texel.rgb,vec3(0.0),vec3(1.0)));\\n#endif\\n#ifdef COLOR_CORRECTION\\n texel.rgb = clamp(texel.rgb + vec3(brightness), 0.0, 1.0);\\n texel.rgb = clamp((texel.rgb - vec3(0.5))*contrast+vec3(0.5), 0.0, 1.0);\\n float lum = dot(texel.rgb, vec3(0.2125, 0.7154, 0.0721));\\n texel.rgb = mix(vec3(lum), texel.rgb, saturation);\\n#endif\\n#ifdef VIGNETTE\\n vec2 uv = (v_Texcoord - vec2(0.5)) * vec2(vignetteOffset);\\n texel.rgb = mix(texel.rgb, vec3(1.0 - vignetteDarkness), dot(uv, uv));\\n#endif\\n gl_FragColor = encodeHDR(texel);\\n#ifdef DEBUG\\n #if DEBUG == 1\\n gl_FragColor = encodeHDR(decodeHDR(texture2D(texture, v_Texcoord)));\\n #elif DEBUG == 2\\n gl_FragColor = encodeHDR(decodeHDR(texture2D(bloom, v_Texcoord)) * bloomIntensity);\\n #elif DEBUG == 3\\n gl_FragColor = encodeHDR(decodeHDR(texture2D(lensflare, v_Texcoord) * lensflareIntensity));\\n #endif\\n#endif\\n if (originalTexel.a <= 0.01 && gl_FragColor.a > 1e-5) {\\n gl_FragColor.a = dot(gl_FragColor.rgb, vec3(0.2125, 0.7154, 0.0721));\\n }\\n#ifdef PREMULTIPLY_ALPHA\\n gl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n}\\n@end\";\n","export default \"\\n@export clay.compositor.lut\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\nuniform sampler2D lookup;\\nvoid main()\\n{\\n vec4 tex = texture2D(texture, v_Texcoord);\\n float blueColor = tex.b * 63.0;\\n vec2 quad1;\\n quad1.y = floor(floor(blueColor) / 8.0);\\n quad1.x = floor(blueColor) - (quad1.y * 8.0);\\n vec2 quad2;\\n quad2.y = floor(ceil(blueColor) / 8.0);\\n quad2.x = ceil(blueColor) - (quad2.y * 8.0);\\n vec2 texPos1;\\n texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.r);\\n texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.g);\\n vec2 texPos2;\\n texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.r);\\n texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.g);\\n vec4 newColor1 = texture2D(lookup, texPos1);\\n vec4 newColor2 = texture2D(lookup, texPos2);\\n vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\\n gl_FragColor = vec4(newColor.rgb, tex.w);\\n}\\n@end\";\n","export default \"@export clay.compositor.output\\n#define OUTPUT_ALPHA\\nvarying vec2 v_Texcoord;\\nuniform sampler2D texture;\\n@import clay.util.rgbm\\nvoid main()\\n{\\n vec4 tex = decodeHDR(texture2D(texture, v_Texcoord));\\n gl_FragColor.rgb = tex.rgb;\\n#ifdef OUTPUT_ALPHA\\n gl_FragColor.a = tex.a;\\n#else\\n gl_FragColor.a = 1.0;\\n#endif\\n gl_FragColor = encodeHDR(gl_FragColor);\\n#ifdef PREMULTIPLY_ALPHA\\n gl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n}\\n@end\";\n","export default \"\\n@export clay.compositor.upsample\\n#define HIGH_QUALITY\\nuniform sampler2D texture;\\nuniform vec2 textureSize : [512, 512];\\nuniform float sampleScale: 0.5;\\nvarying vec2 v_Texcoord;\\n@import clay.util.rgbm\\n@import clay.util.clamp_sample\\nvoid main()\\n{\\n#ifdef HIGH_QUALITY\\n vec4 d = vec4(1.0, 1.0, -1.0, 0.0) / textureSize.xyxy * sampleScale;\\n vec4 s;\\n s = decodeHDR(clampSample(texture, v_Texcoord - d.xy));\\n s += decodeHDR(clampSample(texture, v_Texcoord - d.wy)) * 2.0;\\n s += decodeHDR(clampSample(texture, v_Texcoord - d.zy));\\n s += decodeHDR(clampSample(texture, v_Texcoord + d.zw)) * 2.0;\\n s += decodeHDR(clampSample(texture, v_Texcoord )) * 4.0;\\n s += decodeHDR(clampSample(texture, v_Texcoord + d.xw)) * 2.0;\\n s += decodeHDR(clampSample(texture, v_Texcoord + d.zy));\\n s += decodeHDR(clampSample(texture, v_Texcoord + d.wy)) * 2.0;\\n s += decodeHDR(clampSample(texture, v_Texcoord + d.xy));\\n gl_FragColor = encodeHDR(s / 16.0);\\n#else\\n vec4 d = vec4(-1.0, -1.0, +1.0, +1.0) / textureSize.xyxy;\\n vec4 s;\\n s = decodeHDR(clampSample(texture, v_Texcoord + d.xy));\\n s += decodeHDR(clampSample(texture, v_Texcoord + d.zy));\\n s += decodeHDR(clampSample(texture, v_Texcoord + d.xw));\\n s += decodeHDR(clampSample(texture, v_Texcoord + d.zw));\\n gl_FragColor = encodeHDR(s / 4.0);\\n#endif\\n}\\n@end\";\n","export default \"\\n@export clay.compositor.vertex\\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\\nattribute vec3 position : POSITION;\\nattribute vec2 texcoord : TEXCOORD_0;\\nvarying vec2 v_Texcoord;\\nvoid main()\\n{\\n v_Texcoord = texcoord;\\n gl_Position = worldViewProjection * vec4(position, 1.0);\\n}\\n@end\";\n","export default \"vec3 calcAmbientSHLight(int idx, vec3 N) {\\n int offset = 9 * idx;\\n return ambientSHLightCoefficients[0]\\n + ambientSHLightCoefficients[1] * N.x\\n + ambientSHLightCoefficients[2] * N.y\\n + ambientSHLightCoefficients[3] * N.z\\n + ambientSHLightCoefficients[4] * N.x * N.z\\n + ambientSHLightCoefficients[5] * N.z * N.y\\n + ambientSHLightCoefficients[6] * N.y * N.x\\n + ambientSHLightCoefficients[7] * (3.0 * N.z * N.z - 1.0)\\n + ambientSHLightCoefficients[8] * (N.x * N.x - N.y * N.y);\\n}\";\n","import calcAmbientSHLightEssl from './calcAmbientSHLight.glsl.js';\n\nvar uniformVec3Prefix = 'uniform vec3 ';\nvar uniformFloatPrefix = 'uniform float ';\nvar exportHeaderPrefix = '@export clay.header.';\nvar exportEnd = '@end';\nvar unconfigurable = ':unconfigurable;';\nexport default [\n    exportHeaderPrefix + 'directional_light',\n    uniformVec3Prefix + 'directionalLightDirection[DIRECTIONAL_LIGHT_COUNT]' + unconfigurable,\n    uniformVec3Prefix + 'directionalLightColor[DIRECTIONAL_LIGHT_COUNT]' + unconfigurable,\n    exportEnd,\n\n    exportHeaderPrefix + 'ambient_light',\n    uniformVec3Prefix + 'ambientLightColor[AMBIENT_LIGHT_COUNT]' + unconfigurable,\n    exportEnd,\n\n    exportHeaderPrefix + 'ambient_sh_light',\n    uniformVec3Prefix + 'ambientSHLightColor[AMBIENT_SH_LIGHT_COUNT]' + unconfigurable,\n    uniformVec3Prefix + 'ambientSHLightCoefficients[AMBIENT_SH_LIGHT_COUNT * 9]' + unconfigurable,\n    calcAmbientSHLightEssl,\n    exportEnd,\n\n    exportHeaderPrefix + 'ambient_cubemap_light',\n    uniformVec3Prefix + 'ambientCubemapLightColor[AMBIENT_CUBEMAP_LIGHT_COUNT]' + unconfigurable,\n    'uniform samplerCube ambientCubemapLightCubemap[AMBIENT_CUBEMAP_LIGHT_COUNT]' + unconfigurable,\n    'uniform sampler2D ambientCubemapLightBRDFLookup[AMBIENT_CUBEMAP_LIGHT_COUNT]' + unconfigurable,\n    exportEnd,\n\n    exportHeaderPrefix + 'point_light',\n    uniformVec3Prefix + 'pointLightPosition[POINT_LIGHT_COUNT]' + unconfigurable,\n    uniformFloatPrefix + 'pointLightRange[POINT_LIGHT_COUNT]' + unconfigurable,\n    uniformVec3Prefix + 'pointLightColor[POINT_LIGHT_COUNT]' + unconfigurable,\n    exportEnd,\n\n    exportHeaderPrefix + 'spot_light',\n    uniformVec3Prefix + 'spotLightPosition[SPOT_LIGHT_COUNT]' + unconfigurable,\n    uniformVec3Prefix + 'spotLightDirection[SPOT_LIGHT_COUNT]' + unconfigurable,\n    uniformFloatPrefix + 'spotLightRange[SPOT_LIGHT_COUNT]' + unconfigurable,\n    uniformFloatPrefix + 'spotLightUmbraAngleCosine[SPOT_LIGHT_COUNT]' + unconfigurable,\n    uniformFloatPrefix + 'spotLightPenumbraAngleCosine[SPOT_LIGHT_COUNT]' + unconfigurable,\n    uniformFloatPrefix + 'spotLightFalloffFactor[SPOT_LIGHT_COUNT]' + unconfigurable,\n    uniformVec3Prefix + 'spotLightColor[SPOT_LIGHT_COUNT]' + unconfigurable,\n    exportEnd\n].join('\\n');\n","export default \"@export clay.prez.vertex\\nuniform mat4 WVP : WORLDVIEWPROJECTION;\\nattribute vec3 pos : POSITION;\\nattribute vec2 uv : TEXCOORD_0;\\nuniform vec2 uvRepeat : [1.0, 1.0];\\nuniform vec2 uvOffset : [0.0, 0.0];\\n@import clay.chunk.skinning_header\\n@import clay.chunk.instancing_header\\nvarying vec2 v_Texcoord;\\nvoid main()\\n{\\n vec4 P = vec4(pos, 1.0);\\n#ifdef SKINNING\\n @import clay.chunk.skin_matrix\\n P = skinMatrixWS * P;\\n#endif\\n#ifdef INSTANCING\\n @import clay.chunk.instancing_matrix\\n P = instanceMat * P;\\n#endif\\n gl_Position = WVP * P;\\n v_Texcoord = uv * uvRepeat + uvOffset;\\n}\\n@end\\n@export clay.prez.fragment\\nuniform sampler2D alphaMap;\\nuniform float alphaCutoff: 0.0;\\nvarying vec2 v_Texcoord;\\nvoid main()\\n{\\n if (alphaCutoff > 0.0) {\\n if (texture2D(alphaMap, v_Texcoord).a <= alphaCutoff) {\\n discard;\\n }\\n }\\n gl_FragColor = vec4(0.0,0.0,0.0,1.0);\\n}\\n@end\";\n","export default \"\\n@export clay.util.rand\\nhighp float rand(vec2 uv) {\\n const highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n highp float dt = dot(uv.xy, vec2(a,b)), sn = mod(dt, 3.141592653589793);\\n return fract(sin(sn) * c);\\n}\\n@end\\n@export clay.util.calculate_attenuation\\nuniform float attenuationFactor : 5.0;\\nfloat lightAttenuation(float dist, float range)\\n{\\n float attenuation = 1.0;\\n attenuation = dist*dist/(range*range+1.0);\\n float att_s = attenuationFactor;\\n attenuation = 1.0/(attenuation*att_s+1.0);\\n att_s = 1.0/(att_s+1.0);\\n attenuation = attenuation - att_s;\\n attenuation /= 1.0 - att_s;\\n return clamp(attenuation, 0.0, 1.0);\\n}\\n@end\\n@export clay.util.edge_factor\\n#ifdef SUPPORT_STANDARD_DERIVATIVES\\nfloat edgeFactor(float width)\\n{\\n vec3 d = fwidth(v_Barycentric);\\n vec3 a3 = smoothstep(vec3(0.0), d * width, v_Barycentric);\\n return min(min(a3.x, a3.y), a3.z);\\n}\\n#else\\nfloat edgeFactor(float width)\\n{\\n return 1.0;\\n}\\n#endif\\n@end\\n@export clay.util.encode_float\\nvec4 encodeFloat(const in float depth)\\n{\\n const vec4 bitShifts = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\\n const vec4 bit_mask = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\\n vec4 res = fract(depth * bitShifts);\\n res -= res.xxyz * bit_mask;\\n return res;\\n}\\n@end\\n@export clay.util.decode_float\\nfloat decodeFloat(const in vec4 color)\\n{\\n const vec4 bitShifts = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\\n return dot(color, bitShifts);\\n}\\n@end\\n@export clay.util.float\\n@import clay.util.encode_float\\n@import clay.util.decode_float\\n@end\\n@export clay.util.rgbm_decode\\nvec3 RGBMDecode(vec4 rgbm, float range) {\\n return range * rgbm.rgb * rgbm.a;\\n}\\n@end\\n@export clay.util.rgbm_encode\\nvec4 RGBMEncode(vec3 color, float range) {\\n if (dot(color, color) == 0.0) {\\n return vec4(0.0);\\n }\\n vec4 rgbm;\\n color /= range;\\n rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);\\n rgbm.a = ceil(rgbm.a * 255.0) / 255.0;\\n rgbm.rgb = color / rgbm.a;\\n return rgbm;\\n}\\n@end\\n@export clay.util.rgbm\\n@import clay.util.rgbm_decode\\n@import clay.util.rgbm_encode\\nvec4 decodeHDR(vec4 color)\\n{\\n#if defined(RGBM_DECODE) || defined(RGBM)\\n return vec4(RGBMDecode(color, 8.12), 1.0);\\n#else\\n return color;\\n#endif\\n}\\nvec4 encodeHDR(vec4 color)\\n{\\n#if defined(RGBM_ENCODE) || defined(RGBM)\\n return RGBMEncode(color.xyz, 8.12);\\n#else\\n return color;\\n#endif\\n}\\n@end\\n@export clay.util.srgb\\nvec4 sRGBToLinear(in vec4 value) {\\n return vec4(mix(pow(value.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), value.rgb * 0.0773993808, vec3(lessThanEqual(value.rgb, vec3(0.04045)))), value.w);\\n}\\nvec4 linearTosRGB(in vec4 value) {\\n return vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.w);\\n}\\n@end\\n@export clay.chunk.skinning_header\\n#ifdef SKINNING\\nattribute vec3 weight : WEIGHT;\\nattribute vec4 joint : JOINT;\\n#ifdef USE_SKIN_MATRICES_TEXTURE\\nuniform sampler2D skinMatricesTexture : ignore;\\nuniform float skinMatricesTextureSize: ignore;\\nmat4 getSkinMatrix(sampler2D tex, float idx) {\\n float j = idx * 4.0;\\n float x = mod(j, skinMatricesTextureSize);\\n float y = floor(j / skinMatricesTextureSize) + 0.5;\\n vec2 scale = vec2(skinMatricesTextureSize);\\n return mat4(\\n texture2D(tex, vec2(x + 0.5, y) / scale),\\n texture2D(tex, vec2(x + 1.5, y) / scale),\\n texture2D(tex, vec2(x + 2.5, y) / scale),\\n texture2D(tex, vec2(x + 3.5, y) / scale)\\n );\\n}\\nmat4 getSkinMatrix(float idx) {\\n return getSkinMatrix(skinMatricesTexture, idx);\\n}\\n#else\\nuniform mat4 skinMatrix[JOINT_COUNT] : SKIN_MATRIX;\\nmat4 getSkinMatrix(float idx) {\\n return skinMatrix[int(idx)];\\n}\\n#endif\\n#endif\\n@end\\n@export clay.chunk.skin_matrix\\nmat4 skinMatrixWS = getSkinMatrix(joint.x) * weight.x;\\nif (weight.y > 1e-4)\\n{\\n skinMatrixWS += getSkinMatrix(joint.y) * weight.y;\\n}\\nif (weight.z > 1e-4)\\n{\\n skinMatrixWS += getSkinMatrix(joint.z) * weight.z;\\n}\\nfloat weightW = 1.0-weight.x-weight.y-weight.z;\\nif (weightW > 1e-4)\\n{\\n skinMatrixWS += getSkinMatrix(joint.w) * weightW;\\n}\\n@end\\n@export clay.chunk.instancing_header\\n#ifdef INSTANCING\\nattribute vec4 instanceMat1;\\nattribute vec4 instanceMat2;\\nattribute vec4 instanceMat3;\\n#endif\\n@end\\n@export clay.chunk.instancing_matrix\\nmat4 instanceMat = mat4(\\n vec4(instanceMat1.xyz, 0.0),\\n vec4(instanceMat2.xyz, 0.0),\\n vec4(instanceMat3.xyz, 0.0),\\n vec4(instanceMat1.w, instanceMat2.w, instanceMat3.w, 1.0)\\n);\\n@end\\n@export clay.util.parallax_correct\\nvec3 parallaxCorrect(in vec3 dir, in vec3 pos, in vec3 boxMin, in vec3 boxMax) {\\n vec3 first = (boxMax - pos) / dir;\\n vec3 second = (boxMin - pos) / dir;\\n vec3 further = max(first, second);\\n float dist = min(further.x, min(further.y, further.z));\\n vec3 fixedPos = pos + dir * dist;\\n vec3 boxCenter = (boxMax + boxMin) * 0.5;\\n return normalize(fixedPos - boxCenter);\\n}\\n@end\\n@export clay.util.clamp_sample\\nvec4 clampSample(const in sampler2D texture, const in vec2 coord)\\n{\\n#ifdef STEREO\\n float eye = step(0.5, coord.x) * 0.5;\\n vec2 coordClamped = clamp(coord, vec2(eye, 0.0), vec2(0.5 + eye, 1.0));\\n#else\\n vec2 coordClamped = clamp(coord, vec2(0.0), vec2(1.0));\\n#endif\\n return texture2D(texture, coordClamped);\\n}\\n@end\\n@export clay.util.ACES\\nvec3 ACESToneMapping(vec3 color)\\n{\\n const float A = 2.51;\\n const float B = 0.03;\\n const float C = 2.43;\\n const float D = 0.59;\\n const float E = 0.14;\\n return (color * (A * color + B)) / (color * (C * color + D) + E);\\n}\\n@end\";\n"],"names":["RayPicking","Base","extend","scene","camera","renderer","this","_ray","Ray","_ndc","Vector2","pick","x","y","forcePickAll","out","pickAll","output","screenToNDC","castRay","_intersectNode","sort","_intersectionCompareFunc","node","Renderable","isRenderable","ignorePicking","mode","glenum","TRIANGLES","geometry","isUseIndices","pickByRay","_intersectRenderable","i","_children","length","v1","Vector3","v2","v3","ray","worldInverse","Matrix4","renderable","isSkinnedMesh","copy","invert","worldTransform","applyTransform","bbox","skeleton","boundingBox","intersectBoundingBox","point","skinMatricesArray","cullBack","cullFace","BACK","frontFace","CCW","FRONT","CW","indices","positionAttr","attributes","position","weightAttr","weight","jointAttr","joint","skinMatrices","value","getSubSkinMatrices","__uid__","joints","k","pos","skinnedPos","tmp","skinnedPositionAttr","skinnedPosition","createAttribute","init","vertexCount","get","vec3","set","transformMat4","scaleAndAdd","i1","i2","i3","finalPosAttr","array","intersectTriangle","culling","pointW","push","Intersection","dist","origin","a","b","distance","pointWorld","target","triangle","triangleIndex","Shader","import","skyboxEssl","Skybox","Mesh","skyboxShader","vertex","source","fragment","material","Material","shader","depthMask","CubeGeometry","environmentMap","_dummyCamera","PerspectiveCamera","attachScene","setEnvironmentMap","detachScene","skybox","on","_beforeRenderScene","off","dispose","envMap","textureType","define","minFilter","Texture","LINEAR","undefine","getEnvironmentMap","renderSkybox","dummyCamera","aspect","getViewportAspect","fov","updateProjectionMatrix","invProjectionMatrix","projectionMatrix","viewMatrix","getWorldPosition","update","gl","disable","BLEND","renderPass","targets","EnvironmentMapPass","ret","far","near","texture","shadowMapPass","cameras","_cameras","px","nx","py","ny","pz","nz","lookAt","POSITIVE_X","NEGATIVE_Y","NEGATIVE_X","POSITIVE_Y","POSITIVE_Z","NEGATIVE_Z","_frameBuffer","FrameBuffer","getCamera","render","notUpdateScene","_gl","n","width","Math","atan","PI","getBoundingBox","viewBoundingBoxLastFrame","attach","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","bind","unbind","getDepthMaterialUniform","depthMaterial","symbol","isDefined","alphaCutoff","isDepthMaterialChanged","prevRenderable","matA","matB","shadowmapEssl","ShadowMapPass","softShadow","PCF","shadowBlur","lightFrustumBias","kernelPCF","Float32Array","precision","_lastRenderNotCastShadow","_textures","_shadowMapNumber","_depthMaterials","_distanceMaterials","_receivers","_lightsCastShadow","_lightCameras","_lightMaterials","_texturePool","TexturePool","_gaussianPassH","Pass","_gaussianPassV","setUniform","_outputDepthPass","sceneCamera","getMainCamera","trigger","_renderShadowPass","renderDebug","size","saveClear","viewport","height","name","VSM","setViewport","restoreClear","_updateReceivers","mesh","receiveShadow","_update","self","traverse","lights","light","castShadow","invisible","updateLights","enable","DEPTH_TEST","clearColor","dirLightHasCascade","spotLightShadowMaps","spotLightMatrices","directionalLightShadowMaps","directionalLightMatrices","shadowCascadeClips","pointLightShadowMaps","type","console","warn","shadowCascade","renderDirectionalLightShadow","renderSpotLightShadow","renderPointLightShadow","lightType","number","key","fragmentDefines","shadowUniforms","directionalLightShadowMapSizes","map","getSize","shadowCascadeClipsNear","slice","shadowCascadeClipsFar","pop","shift","reverse","spotLightShadowMapSizes","splitFrustum","Frustum","splitProjMatrix","cropBBox","BoundingBox","cropMatrix","lightViewMatrix","lightViewProjMatrix","lightProjMatrix","defaultShadowMaterial","_getDepthMaterial","passConfig","getMaterial","shadowDepthMaterial","isMaterialChanged","getUniform","ifRender","sortCompare","Renderer","opaqueSortCompare","isFinite","clippedFar","min","z","clippedNear","max","lightCamera","_getDirectionalLightCamera","lvpMat4Arr","mat4","multiply","clipPlanes","isPerspective","scaleZ","offsetZ","clog","pow","cuni","c","cascadeSplitLogFactor","_getTexture","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","nearPlane","farPlane","perspective","ortho","left","right","bottom","top","setFromProjection","getTransformedBoundingBox","applyProjection","_min","_max","multiplyLeft","shadowSize","shadowResolution","renderList","updateRenderList","opaque","_gaussianFilter","matrix","_getSpotLightCamera","renderListEachSide","lightWorldPosition","lightBBox","range","setArray","extent","add","sub","targetsNeedRender","transformFrom","updateVertices","vtx","vertices","absx","abs","absy","absz","_getPointLightCamera","shadowMaterial","isPointLight","shaderPrefix","shadowSlopeScale","shadowBias","parameter","FLOAT","tmpTexture","put","cascade","resolution","TextureCube","Texture2D","anisotropic","NEAREST","magFilter","useMipmap","sceneViewBoundingBox","lightViewBBox","directional","OrthoCamera","intersection","frustum","scale","rotation","updateWorldTransform","isNaN","spot","penumbraAngle","_meshMaterials","register","coloradjustEssl","blurEssl","lumEssl","lutEssl","vigentteEssl","outputEssl","brightEssl","downsampleEssl","upsampleEssl","hdrEssl","lensflareEssl","blendEssl","fxaaEssl","uniformVec3Prefix","uniformFloatPrefix","exportHeaderPrefix","exportEnd","unconfigurable","calcAmbientSHLightEssl","join"],"sourceRoot":""}