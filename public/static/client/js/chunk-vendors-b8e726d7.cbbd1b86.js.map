{"version":3,"file":"static/client/js/chunk-vendors-b8e726d7.cbbd1b86.js","mappings":"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","sources":["webpack://d1/./node_modules/echarts/lib/data/DataDiffer.js","webpack://d1/./node_modules/echarts/lib/data/DataStore.js","webpack://d1/./node_modules/echarts/lib/data/Graph.js","webpack://d1/./node_modules/echarts/lib/data/OrdinalMeta.js","webpack://d1/./node_modules/echarts/lib/data/SeriesData.js","webpack://d1/./node_modules/echarts/lib/data/SeriesDimensionDefine.js","webpack://d1/./node_modules/echarts/lib/data/Source.js","webpack://d1/./node_modules/echarts/lib/data/Tree.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\nfunction defaultKeyGetter(item) {\n  return item;\n}\nvar DataDiffer = /** @class */function () {\n  /**\n   * @param context Can be visited by this.context in callback.\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context,\n  // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n    // Visible in callback via `this.context`;\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\n   * Callback function when add a data\n   */\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data\n   */\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when remove a data\n   */\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      // idx can never be empty array here. see 'set null' logic below.\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\n   * For example, consider the case:\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\n   * Where:\n   *     o0, o1, n0 has key 'a' (many to one)\n   *     o5, n4, n5, n6 has key 'b' (one to many)\n   *     o2, n1 has key 'c' (one to one)\n   *     n2, n3 has key 'd' (add)\n   *     o3, o4 has key 'e' (remove)\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\n   * Then:\n   *     (The order of the following directives are not ensured.)\n   *     this._updateManyToOne(n0, [o0, o1]);\n   *     this._updateOneToMany([n4, n5, n6], o5);\n   *     this._update(n1, o2);\n   *     this._remove(o3);\n   *     this._remove(o4);\n   *     this._remove(o6);\n   *     this._remove(o7);\n   *     this._add(n2);\n   *     this._add(n3);\n   *     this._add(n7);\n   *     this._add(n8);\n   */\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      }\n      // Support both `newDataKeyArr` are duplication removed or not removed.\n      newDataIndexMap[newKey] = null;\n    }\n  };\n  DataDiffer.prototype._initIndexMap = function (arr,\n  // Can be null.\n  map,\n  // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n      if (!map) {\n        continue;\n      }\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n  return DataDiffer;\n}();\nexport default DataDiffer;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, createHashMap, isFunction, keys, map, reduce } from 'zrender/lib/core/util.js';\nimport { parseDataValue } from './helper/dataValueHelper.js';\nimport { shouldRetrieveDataByName } from './Source.js';\nvar UNDEFINED = 'undefined';\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n// Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\nexport var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nexport var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nexport var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nexport var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;\n/**\n * Multi dimensional data store\n */\nvar dataCtors = {\n  'float': CtorFloat64Array,\n  'int': CtorInt32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': CtorFloat64Array\n};\nvar defaultDimValueGetters;\nfunction getIndicesCtor(rawCount) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n;\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n;\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor;\n  // Only shallow clone is enough when Array.\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\nfunction prepareStore(store, dimIdx, dimType, end, append) {\n  var DataCtor = dataCtors[dimType || 'float'];\n  if (append) {\n    var oldStore = store[dimIdx];\n    var oldLen = oldStore && oldStore.length;\n    if (!(oldLen === end)) {\n      var newStore = new DataCtor(end);\n      // The cost of the copy is probably inconsiderable\n      // within the initial chunkSize.\n      for (var j = 0; j < oldLen; j++) {\n        newStore[j] = oldStore[j];\n      }\n      store[dimIdx] = newStore;\n    }\n  } else {\n    store[dimIdx] = new DataCtor(end);\n  }\n}\n;\n/**\n * Basically, DataStore API keep immutable.\n */\nvar DataStore = /** @class */function () {\n  function DataStore() {\n    this._chunks = [];\n    // It will not be calculated until needed.\n    this._rawExtent = [];\n    this._extent = [];\n    this._count = 0;\n    this._rawCount = 0;\n    this._calcDimNameToIdx = createHashMap();\n  }\n  /**\n   * Initialize from data\n   */\n  DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isFunction(provider.getItem) && isFunction(provider.count), 'Invalid data provider.');\n    }\n    this._provider = provider;\n    // Clear\n    this._chunks = [];\n    this._indices = null;\n    this.getRawIndex = this._getRawIdxIdentity;\n    var source = provider.getSource();\n    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];\n    // Default dim value getter\n    this._dimValueGetter = dimValueGetter || defaultGetter;\n    // Reset raw extent.\n    this._rawExtent = [];\n    var willRetrieveDataByName = shouldRetrieveDataByName(source);\n    this._dimensions = map(inputDimensions, function (dim) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (willRetrieveDataByName) {\n          assert(dim.property != null);\n        }\n      }\n      return {\n        // Only pick these two props. Not leak other properties like orderMeta.\n        type: dim.type,\n        property: dim.property\n      };\n    });\n    this._initDataFromProvider(0, provider.count());\n  };\n  DataStore.prototype.getProvider = function () {\n    return this._provider;\n  };\n  /**\n   * Caution: even when a `source` instance owned by a series, the created data store\n   * may still be shared by different sereis (the source hash does not use all `source`\n   * props, see `sourceManager`). In this case, the `source` props that are not used in\n   * hash (like `source.dimensionDefine`) probably only belongs to a certain series and\n   * thus should not be fetch here.\n   */\n  DataStore.prototype.getSource = function () {\n    return this._provider.getSource();\n  };\n  /**\n   * @caution Only used in dataStack.\n   */\n  DataStore.prototype.ensureCalculationDimension = function (dimName, type) {\n    var calcDimNameToIdx = this._calcDimNameToIdx;\n    var dimensions = this._dimensions;\n    var calcDimIdx = calcDimNameToIdx.get(dimName);\n    if (calcDimIdx != null) {\n      if (dimensions[calcDimIdx].type === type) {\n        return calcDimIdx;\n      }\n    } else {\n      calcDimIdx = dimensions.length;\n    }\n    dimensions[calcDimIdx] = {\n      type: type\n    };\n    calcDimNameToIdx.set(dimName, calcDimIdx);\n    this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount);\n    this._rawExtent[calcDimIdx] = getInitialExtent();\n    return calcDimIdx;\n  };\n  DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {\n    var chunk = this._chunks[dimIdx];\n    var dim = this._dimensions[dimIdx];\n    var rawExtents = this._rawExtent;\n    var offset = dim.ordinalOffset || 0;\n    var len = chunk.length;\n    if (offset === 0) {\n      // We need to reset the rawExtent if collect is from start.\n      // Because this dimension may be guessed as number and calcuating a wrong extent.\n      rawExtents[dimIdx] = getInitialExtent();\n    }\n    var dimRawExtent = rawExtents[dimIdx];\n    // Parse from previous data offset. len may be changed after appendData\n    for (var i = offset; i < len; i++) {\n      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);\n      if (!isNaN(val)) {\n        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);\n        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);\n      }\n    }\n    dim.ordinalMeta = ordinalMeta;\n    dim.ordinalOffset = len;\n    dim.type = 'ordinal'; // Force to be ordinal\n  };\n\n  DataStore.prototype.getOrdinalMeta = function (dimIdx) {\n    var dimInfo = this._dimensions[dimIdx];\n    var ordinalMeta = dimInfo.ordinalMeta;\n    return ordinalMeta;\n  };\n  DataStore.prototype.getDimensionProperty = function (dimIndex) {\n    var item = this._dimensions[dimIndex];\n    return item && item.property;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n  DataStore.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n    var provider = this._provider;\n    var start = this.count();\n    provider.appendData(data);\n    var end = provider.count();\n    if (!provider.persistent) {\n      end += start;\n    }\n    if (start < end) {\n      this._initDataFromProvider(start, end, true);\n    }\n    return [start, end];\n  };\n  DataStore.prototype.appendValues = function (values, minFillLen) {\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, minFillLen || 0);\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      prepareStore(chunks, i, dim.type, end, true);\n    }\n    var emptyDataItem = [];\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start;\n      // Store the data by dimensions\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);\n        chunks[dimIdx][idx] = val;\n        var dimRawExtent = rawExtent[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n    }\n    this._rawCount = this._count = end;\n    return {\n      start: start,\n      end: end\n    };\n  };\n  DataStore.prototype._initDataFromProvider = function (start, end, append) {\n    var provider = this._provider;\n    var chunks = this._chunks;\n    var dimensions = this._dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var dimNames = map(dimensions, function (dim) {\n      return dim.property;\n    });\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n      if (!rawExtent[i]) {\n        rawExtent[i] = getInitialExtent();\n      }\n      prepareStore(chunks, i, dim.type, end, append);\n    }\n    if (provider.fillStorage) {\n      provider.fillStorage(start, end, chunks, rawExtent);\n    } else {\n      var dataItem = [];\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = provider.getItem(idx, dataItem);\n        // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dimStorage = chunks[dimIdx];\n          // PENDING NULL is empty or zero\n          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtent[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n      }\n    }\n    if (!provider.persistent && provider.clean) {\n      // Clean unused data if data source is typed array.\n      provider.clean();\n    }\n    this._rawCount = this._count = end;\n    // Reset data extent\n    this._extent = [];\n  };\n  DataStore.prototype.count = function () {\n    return this._count;\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   */\n  DataStore.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n  DataStore.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n    var dimArr = [];\n    if (idx == null) {\n      idx = dimensions;\n      // TODO get all from store?\n      dimensions = [];\n      // All dimensions\n      for (var i = 0; i < this._dimensions.length; i++) {\n        dimArr.push(i);\n      }\n    } else {\n      dimArr = dimensions;\n    }\n    for (var i = 0, len = dimArr.length; i < len; i++) {\n      values.push(this.get(dimArr[i], idx));\n    }\n    return values;\n  };\n  /**\n   * @param dim concrete dim\n   */\n  DataStore.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n    var dimStore = this._chunks[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n  /**\n   * Get sum of data in one dimension\n   */\n  DataStore.prototype.getSum = function (dim) {\n    var dimData = this._chunks[dim];\n    var sum = 0;\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n    return sum;\n  };\n  /**\n   * Get median of data in one dimension\n   */\n  DataStore.prototype.getMedian = function (dim) {\n    var dimDataArray = [];\n    // map all data of one dimension\n    this.each([dim], function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    });\n    // TODO\n    // Use quick select?\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count();\n    // calculate median\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n  /**\n   * Retrieve the index with given raw data index.\n   */\n  DataStore.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n    if (!this._indices) {\n      return rawIndex;\n    }\n    // Indices are ascending\n    var indices = this._indices;\n    // If rawIndex === dataIndex\n    var rawDataIndex = indices[rawIndex];\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n    var left = 0;\n    var right = this._count - 1;\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -1;\n  };\n  /**\n   * Retrieve the index of nearest value.\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices have\n   *         the same value, they are put to the result.\n   */\n  DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var chunks = this._chunks;\n    var dimData = chunks[dim];\n    var nearestIndices = [];\n    if (!dimData) {\n      return nearestIndices;\n    }\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0;\n    // Check the test case of `test/ut/spec/data/SeriesData.js`.\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we choose the one that `diff >= 0` in this case.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n  DataStore.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count;\n      // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this._rawCount);\n      newIndices = new Ctor(this.count());\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n    return newIndices;\n  };\n  /**\n   * Data filter.\n   */\n  DataStore.prototype.filter = function (dims, cb) {\n    if (!this._count) {\n      return this;\n    }\n    var newStore = this.clone();\n    var count = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dims.length;\n    var offset = 0;\n    var dim0 = dims[0];\n    var chunks = newStore._chunks;\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = newStore.getRawIndex(i);\n      // Simple optimization\n      if (dimSize === 0) {\n        keep = cb(i);\n      } else if (dimSize === 1) {\n        var val = chunks[dim0][rawIdx];\n        keep = cb(val, i);\n      } else {\n        var k = 0;\n        for (; k < dimSize; k++) {\n          value[k] = chunks[dims[k]][rawIdx];\n        }\n        value[k] = i;\n        keep = cb.apply(null, value);\n      }\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    }\n    // Set indices after filtered.\n    if (offset < count) {\n      newStore._indices = newIndices;\n    }\n    newStore._count = offset;\n    // Reset data extent\n    newStore._extent = [];\n    newStore._updateGetRawIdx();\n    return newStore;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n  DataStore.prototype.selectRange = function (range) {\n    var newStore = this.clone();\n    var len = newStore._count;\n    if (!len) {\n      return this;\n    }\n    var dims = keys(range);\n    var dimSize = dims.length;\n    if (!dimSize) {\n      return this;\n    }\n    var originalCount = newStore.count();\n    var Ctor = getIndicesCtor(newStore._rawCount);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dims[0];\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storeArr = newStore._chunks;\n    var quickFinished = false;\n    if (!newStore._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n      if (dimSize === 1) {\n        var dimStorage = storeArr[dims[0]];\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n          idx++;\n        }\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storeArr[dims[0]];\n        var dimStorage2 = storeArr[dims[1]];\n        var min2 = range[dims[1]][0];\n        var max2 = range[dims[1]][1];\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i];\n          // Do not filter NaN, see comment above.\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n          idx++;\n        }\n        quickFinished = true;\n      }\n    }\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = newStore.getRawIndex(i);\n          var val = storeArr[dims[0]][rawIndex];\n          // Do not filter NaN, see comment above.\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = newStore.getRawIndex(i);\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dims[k];\n            var val = storeArr[dimk][rawIndex];\n            // Do not filter NaN, see comment above.\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n          if (keep) {\n            newIndices[offset++] = newStore.getRawIndex(i);\n          }\n        }\n      }\n    }\n    // Set indices after filtered.\n    if (offset < originalCount) {\n      newStore._indices = newIndices;\n    }\n    newStore._count = offset;\n    // Reset data extent\n    newStore._extent = [];\n    newStore._updateGetRawIdx();\n    return newStore;\n  };\n  // /**\n  //  * Data mapping to a plain array\n  //  */\n  // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {\n  //     const result: any[] = [];\n  //     this.each(dims, function () {\n  //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));\n  //     });\n  //     return result;\n  // }\n  /**\n   * Data mapping to a new List with given dimensions\n   */\n  DataStore.prototype.map = function (dims, cb) {\n    // TODO only clone picked chunks.\n    var target = this.clone(dims);\n    this._updateDims(target, dims, cb);\n    return target;\n  };\n  /**\n   * @caution Danger!! Only used in dataStack.\n   */\n  DataStore.prototype.modify = function (dims, cb) {\n    this._updateDims(this, dims, cb);\n  };\n  DataStore.prototype._updateDims = function (target, dims, cb) {\n    var targetChunks = target._chunks;\n    var tmpRetValue = [];\n    var dimSize = dims.length;\n    var dataCount = target.count();\n    var values = [];\n    var rawExtent = target._rawExtent;\n    for (var i = 0; i < dims.length; i++) {\n      rawExtent[dims[i]] = getInitialExtent();\n    }\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      var rawIndex = target.getRawIndex(dataIndex);\n      for (var k = 0; k < dimSize; k++) {\n        values[k] = targetChunks[dims[k]][rawIndex];\n      }\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(null, values);\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dims[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = targetChunks[dim];\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n  DataStore.prototype.lttbDownSample = function (valueDimension, rate) {\n    var target = this.clone([valueDimension], true);\n    var targetStorage = target._chunks;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var sampledIndex = 0;\n    var frameSize = Math.floor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len));\n    // First frame use the first data.\n    newIndices[sampledIndex++] = currentRawIndex;\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n        if (isNaN(y)) {\n          continue;\n        }\n        avgY += y;\n      }\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n      var firstNaNIndex = -1;\n      var countNaN = 0;\n      // Find a point from current frame that construct a triangle with largest area with previous selected point\n      // And the average of next frame.\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n        if (isNaN(y)) {\n          countNaN++;\n          if (firstNaNIndex < 0) {\n            firstNaNIndex = rawIndex;\n          }\n          continue;\n        }\n        // Calculate triangle area over three buckets\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      if (countNaN > 0 && countNaN < frameEnd - frameStart) {\n        // Append first NaN point in every bucket.\n        // It is necessary to ensure the correct order of indices.\n        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);\n        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);\n      }\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    }\n    // First frame use the last data.\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    target._count = sampledIndex;\n    target._indices = newIndices;\n    target.getRawIndex = this._getRawIdx;\n    return target;\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n  DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var target = this.clone([dimension], true);\n    var targetStorage = target._chunks;\n    var frameValues = [];\n    var frameSize = Math.floor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();\n    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize));\n    var offset = 0;\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n      // Only write value on the filtered data\n      dimStore[sampleFrameIdx] = value;\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n      newIndices[offset++] = sampleFrameIdx;\n    }\n    target._count = offset;\n    target._indices = newIndices;\n    target._updateGetRawIdx();\n    return target;\n  };\n  /**\n   * Data iteration\n   * @param ctx default this\n   * @example\n   *  list.each('x', function (x, idx) {});\n   *  list.each(['x', 'y'], function (x, y, idx) {});\n   *  list.each(function (idx) {})\n   */\n  DataStore.prototype.each = function (dims, cb) {\n    if (!this._count) {\n      return;\n    }\n    var dimSize = dims.length;\n    var chunks = this._chunks;\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i);\n      // Simple optimization\n      switch (dimSize) {\n        case 0:\n          cb(i);\n          break;\n        case 1:\n          cb(chunks[dims[0]][rawIdx], i);\n          break;\n        case 2:\n          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);\n          break;\n        default:\n          var k = 0;\n          var value = [];\n          for (; k < dimSize; k++) {\n            value[k] = chunks[dims[k]][rawIdx];\n          }\n          // Index\n          value[k] = i;\n          cb.apply(null, value);\n      }\n    }\n  };\n  /**\n   * Get extent of data in one dimension\n   */\n  DataStore.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    var dimData = this._chunks[dim];\n    var initialExtent = getInitialExtent();\n    if (!dimData) {\n      return initialExtent;\n    }\n    // Make more strict checkings to ensure hitting cache.\n    var currEnd = this.count();\n    // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n    var useRaw = !this._indices;\n    var dimExtent;\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n    dimExtent = this._extent[dim];\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\n   * Get raw data item\n   */\n  DataStore.prototype.getRawDataItem = function (idx) {\n    var rawIdx = this.getRawIndex(idx);\n    if (!this._provider.persistent) {\n      var val = [];\n      var chunks = this._chunks;\n      for (var i = 0; i < chunks.length; i++) {\n        val.push(chunks[i][rawIdx]);\n      }\n      return val;\n    } else {\n      return this._provider.getItem(rawIdx);\n    }\n  };\n  /**\n   * Clone shallow.\n   *\n   * @param clonedDims Determine which dims to clone. Will share the data if not specified.\n   */\n  DataStore.prototype.clone = function (clonedDims, ignoreIndices) {\n    var target = new DataStore();\n    var chunks = this._chunks;\n    var clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {\n      obj[dimIdx] = true;\n      return obj;\n    }, {});\n    if (clonedDimsMap) {\n      for (var i = 0; i < chunks.length; i++) {\n        // Not clone if dim is not picked.\n        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);\n      }\n    } else {\n      target._chunks = chunks;\n    }\n    this._copyCommonProps(target);\n    if (!ignoreIndices) {\n      target._indices = this._cloneIndices();\n    }\n    target._updateGetRawIdx();\n    return target;\n  };\n  DataStore.prototype._copyCommonProps = function (target) {\n    target._count = this._count;\n    target._rawCount = this._rawCount;\n    target._provider = this._provider;\n    target._dimensions = this._dimensions;\n    target._extent = clone(this._extent);\n    target._rawExtent = clone(this._rawExtent);\n  };\n  DataStore.prototype._cloneIndices = function () {\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n      var indices = void 0;\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        indices = new Ctor(thisCount);\n        for (var i = 0; i < thisCount; i++) {\n          indices[i] = this._indices[i];\n        }\n      } else {\n        indices = new Ctor(this._indices);\n      }\n      return indices;\n    }\n    return null;\n  };\n  DataStore.prototype._getRawIdxIdentity = function (idx) {\n    return idx;\n  };\n  DataStore.prototype._getRawIdx = function (idx) {\n    if (idx < this._count && idx >= 0) {\n      return this._indices[idx];\n    }\n    return -1;\n  };\n  DataStore.prototype._updateGetRawIdx = function () {\n    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;\n  };\n  DataStore.internalField = function () {\n    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {\n      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);\n    }\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, property, dataIndex, dimIndex) {\n        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, property, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n        return parseDataValue(value instanceof Array ? value[dimIndex]\n        // If value is a single number or something else not array.\n        : value, this._dimensions[dimIndex]);\n      },\n      typedArray: function (dataItem, property, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n  }();\n  return DataStore;\n}();\nexport default DataStore;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\n// id may be function name of Object, add a prefix to avoid this problem.\nfunction generateNodeKey(id) {\n  return '_EC_' + id;\n}\nvar Graph = /** @class */function () {\n  function Graph(directed) {\n    this.type = 'graph';\n    this.nodes = [];\n    this.edges = [];\n    this._nodesMap = {};\n    /**\n     * @type {Object.<string, module:echarts/data/Graph.Edge>}\n     * @private\n     */\n    this._edgesMap = {};\n    this._directed = directed || false;\n  }\n  /**\n   * If is directed graph\n   */\n  Graph.prototype.isDirected = function () {\n    return this._directed;\n  };\n  ;\n  /**\n   * Add a new node\n   */\n  Graph.prototype.addNode = function (id, dataIndex) {\n    id = id == null ? '' + dataIndex : '' + id;\n    var nodesMap = this._nodesMap;\n    if (nodesMap[generateNodeKey(id)]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error('Graph nodes have duplicate name or id');\n      }\n      return;\n    }\n    var node = new GraphNode(id, dataIndex);\n    node.hostGraph = this;\n    this.nodes.push(node);\n    nodesMap[generateNodeKey(id)] = node;\n    return node;\n  };\n  ;\n  /**\n   * Get node by data index\n   */\n  Graph.prototype.getNodeByIndex = function (dataIndex) {\n    var rawIdx = this.data.getRawIndex(dataIndex);\n    return this.nodes[rawIdx];\n  };\n  ;\n  /**\n   * Get node by id\n   */\n  Graph.prototype.getNodeById = function (id) {\n    return this._nodesMap[generateNodeKey(id)];\n  };\n  ;\n  /**\n   * Add a new edge\n   */\n  Graph.prototype.addEdge = function (n1, n2, dataIndex) {\n    var nodesMap = this._nodesMap;\n    var edgesMap = this._edgesMap;\n    // PENDING\n    if (zrUtil.isNumber(n1)) {\n      n1 = this.nodes[n1];\n    }\n    if (zrUtil.isNumber(n2)) {\n      n2 = this.nodes[n2];\n    }\n    if (!(n1 instanceof GraphNode)) {\n      n1 = nodesMap[generateNodeKey(n1)];\n    }\n    if (!(n2 instanceof GraphNode)) {\n      n2 = nodesMap[generateNodeKey(n2)];\n    }\n    if (!n1 || !n2) {\n      return;\n    }\n    var key = n1.id + '-' + n2.id;\n    var edge = new GraphEdge(n1, n2, dataIndex);\n    edge.hostGraph = this;\n    if (this._directed) {\n      n1.outEdges.push(edge);\n      n2.inEdges.push(edge);\n    }\n    n1.edges.push(edge);\n    if (n1 !== n2) {\n      n2.edges.push(edge);\n    }\n    this.edges.push(edge);\n    edgesMap[key] = edge;\n    return edge;\n  };\n  ;\n  /**\n   * Get edge by data index\n   */\n  Graph.prototype.getEdgeByIndex = function (dataIndex) {\n    var rawIdx = this.edgeData.getRawIndex(dataIndex);\n    return this.edges[rawIdx];\n  };\n  ;\n  /**\n   * Get edge by two linked nodes\n   */\n  Graph.prototype.getEdge = function (n1, n2) {\n    if (n1 instanceof GraphNode) {\n      n1 = n1.id;\n    }\n    if (n2 instanceof GraphNode) {\n      n2 = n2.id;\n    }\n    var edgesMap = this._edgesMap;\n    if (this._directed) {\n      return edgesMap[n1 + '-' + n2];\n    } else {\n      return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1];\n    }\n  };\n  ;\n  /**\n   * Iterate all nodes\n   */\n  Graph.prototype.eachNode = function (cb, context) {\n    var nodes = this.nodes;\n    var len = nodes.length;\n    for (var i = 0; i < len; i++) {\n      if (nodes[i].dataIndex >= 0) {\n        cb.call(context, nodes[i], i);\n      }\n    }\n  };\n  ;\n  /**\n   * Iterate all edges\n   */\n  Graph.prototype.eachEdge = function (cb, context) {\n    var edges = this.edges;\n    var len = edges.length;\n    for (var i = 0; i < len; i++) {\n      if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {\n        cb.call(context, edges[i], i);\n      }\n    }\n  };\n  ;\n  /**\n   * Breadth first traverse\n   * Return true to stop traversing\n   */\n  Graph.prototype.breadthFirstTraverse = function (cb, startNode, direction, context) {\n    if (!(startNode instanceof GraphNode)) {\n      startNode = this._nodesMap[generateNodeKey(startNode)];\n    }\n    if (!startNode) {\n      return;\n    }\n    var edgeType = direction === 'out' ? 'outEdges' : direction === 'in' ? 'inEdges' : 'edges';\n    for (var i = 0; i < this.nodes.length; i++) {\n      this.nodes[i].__visited = false;\n    }\n    if (cb.call(context, startNode, null)) {\n      return;\n    }\n    var queue = [startNode];\n    while (queue.length) {\n      var currentNode = queue.shift();\n      var edges = currentNode[edgeType];\n      for (var i = 0; i < edges.length; i++) {\n        var e = edges[i];\n        var otherNode = e.node1 === currentNode ? e.node2 : e.node1;\n        if (!otherNode.__visited) {\n          if (cb.call(context, otherNode, currentNode)) {\n            // Stop traversing\n            return;\n          }\n          queue.push(otherNode);\n          otherNode.__visited = true;\n        }\n      }\n    }\n  };\n  ;\n  // TODO\n  // depthFirstTraverse(\n  //     cb, startNode, direction, context\n  // ) {\n  // };\n  // Filter update\n  Graph.prototype.update = function () {\n    var data = this.data;\n    var edgeData = this.edgeData;\n    var nodes = this.nodes;\n    var edges = this.edges;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n    edgeData.filterSelf(function (idx) {\n      var edge = edges[edgeData.getRawIndex(idx)];\n      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;\n    });\n    // Update edge\n    for (var i = 0, len = edges.length; i < len; i++) {\n      edges[i].dataIndex = -1;\n    }\n    for (var i = 0, len = edgeData.count(); i < len; i++) {\n      edges[edgeData.getRawIndex(i)].dataIndex = i;\n    }\n  };\n  ;\n  /**\n   * @return {module:echarts/data/Graph}\n   */\n  Graph.prototype.clone = function () {\n    var graph = new Graph(this._directed);\n    var nodes = this.nodes;\n    var edges = this.edges;\n    for (var i = 0; i < nodes.length; i++) {\n      graph.addNode(nodes[i].id, nodes[i].dataIndex);\n    }\n    for (var i = 0; i < edges.length; i++) {\n      var e = edges[i];\n      graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);\n    }\n    return graph;\n  };\n  ;\n  return Graph;\n}();\nvar GraphNode = /** @class */function () {\n  function GraphNode(id, dataIndex) {\n    this.inEdges = [];\n    this.outEdges = [];\n    this.edges = [];\n    this.dataIndex = -1;\n    this.id = id == null ? '' : id;\n    this.dataIndex = dataIndex == null ? -1 : dataIndex;\n  }\n  /**\n   * @return {number}\n   */\n  GraphNode.prototype.degree = function () {\n    return this.edges.length;\n  };\n  /**\n   * @return {number}\n   */\n  GraphNode.prototype.inDegree = function () {\n    return this.inEdges.length;\n  };\n  /**\n  * @return {number}\n  */\n  GraphNode.prototype.outDegree = function () {\n    return this.outEdges.length;\n  };\n  GraphNode.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n    var graph = this.hostGraph;\n    var itemModel = graph.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  };\n  GraphNode.prototype.getAdjacentDataIndices = function () {\n    var dataIndices = {\n      edge: [],\n      node: []\n    };\n    for (var i = 0; i < this.edges.length; i++) {\n      var adjacentEdge = this.edges[i];\n      if (adjacentEdge.dataIndex < 0) {\n        continue;\n      }\n      dataIndices.edge.push(adjacentEdge.dataIndex);\n      dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);\n    }\n    return dataIndices;\n  };\n  GraphNode.prototype.getTrajectoryDataIndices = function () {\n    var connectedEdgesMap = zrUtil.createHashMap();\n    var connectedNodesMap = zrUtil.createHashMap();\n    for (var i = 0; i < this.edges.length; i++) {\n      var adjacentEdge = this.edges[i];\n      if (adjacentEdge.dataIndex < 0) {\n        continue;\n      }\n      connectedEdgesMap.set(adjacentEdge.dataIndex, true);\n      var sourceNodesQueue = [adjacentEdge.node1];\n      var targetNodesQueue = [adjacentEdge.node2];\n      var nodeIteratorIndex = 0;\n      while (nodeIteratorIndex < sourceNodesQueue.length) {\n        var sourceNode = sourceNodesQueue[nodeIteratorIndex];\n        nodeIteratorIndex++;\n        connectedNodesMap.set(sourceNode.dataIndex, true);\n        for (var j = 0; j < sourceNode.inEdges.length; j++) {\n          connectedEdgesMap.set(sourceNode.inEdges[j].dataIndex, true);\n          sourceNodesQueue.push(sourceNode.inEdges[j].node1);\n        }\n      }\n      nodeIteratorIndex = 0;\n      while (nodeIteratorIndex < targetNodesQueue.length) {\n        var targetNode = targetNodesQueue[nodeIteratorIndex];\n        nodeIteratorIndex++;\n        connectedNodesMap.set(targetNode.dataIndex, true);\n        for (var j = 0; j < targetNode.outEdges.length; j++) {\n          connectedEdgesMap.set(targetNode.outEdges[j].dataIndex, true);\n          targetNodesQueue.push(targetNode.outEdges[j].node2);\n        }\n      }\n    }\n    return {\n      edge: connectedEdgesMap.keys(),\n      node: connectedNodesMap.keys()\n    };\n  };\n  return GraphNode;\n}();\nvar GraphEdge = /** @class */function () {\n  function GraphEdge(n1, n2, dataIndex) {\n    this.dataIndex = -1;\n    this.node1 = n1;\n    this.node2 = n2;\n    this.dataIndex = dataIndex == null ? -1 : dataIndex;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  GraphEdge.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n    var graph = this.hostGraph;\n    var itemModel = graph.edgeData.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  };\n  GraphEdge.prototype.getAdjacentDataIndices = function () {\n    return {\n      edge: [this.dataIndex],\n      node: [this.node1.dataIndex, this.node2.dataIndex]\n    };\n  };\n  GraphEdge.prototype.getTrajectoryDataIndices = function () {\n    var connectedEdgesMap = zrUtil.createHashMap();\n    var connectedNodesMap = zrUtil.createHashMap();\n    connectedEdgesMap.set(this.dataIndex, true);\n    var sourceNodes = [this.node1];\n    var targetNodes = [this.node2];\n    var nodeIteratorIndex = 0;\n    while (nodeIteratorIndex < sourceNodes.length) {\n      var sourceNode = sourceNodes[nodeIteratorIndex];\n      nodeIteratorIndex++;\n      connectedNodesMap.set(sourceNode.dataIndex, true);\n      for (var j = 0; j < sourceNode.inEdges.length; j++) {\n        connectedEdgesMap.set(sourceNode.inEdges[j].dataIndex, true);\n        sourceNodes.push(sourceNode.inEdges[j].node1);\n      }\n    }\n    nodeIteratorIndex = 0;\n    while (nodeIteratorIndex < targetNodes.length) {\n      var targetNode = targetNodes[nodeIteratorIndex];\n      nodeIteratorIndex++;\n      connectedNodesMap.set(targetNode.dataIndex, true);\n      for (var j = 0; j < targetNode.outEdges.length; j++) {\n        connectedEdgesMap.set(targetNode.outEdges[j].dataIndex, true);\n        targetNodes.push(targetNode.outEdges[j].node2);\n      }\n    }\n    return {\n      edge: connectedEdgesMap.keys(),\n      node: connectedNodesMap.keys()\n    };\n  };\n  return GraphEdge;\n}();\nfunction createGraphDataProxyMixin(hostName, dataName) {\n  return {\n    /**\n     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.\n     */\n    getValue: function (dimension) {\n      var data = this[hostName][dataName];\n      return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex);\n    },\n    // TODO: TYPE stricter type.\n    setVisual: function (key, value) {\n      this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);\n    },\n    getVisual: function (key) {\n      return this[hostName][dataName].getItemVisual(this.dataIndex, key);\n    },\n    setLayout: function (layout, merge) {\n      this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);\n    },\n    getLayout: function () {\n      return this[hostName][dataName].getItemLayout(this.dataIndex);\n    },\n    getGraphicEl: function () {\n      return this[hostName][dataName].getItemGraphicEl(this.dataIndex);\n    },\n    getRawIndex: function () {\n      return this[hostName][dataName].getRawIndex(this.dataIndex);\n    }\n  };\n}\n;\n;\n;\nzrUtil.mixin(GraphNode, createGraphDataProxyMixin('hostGraph', 'data'));\nzrUtil.mixin(GraphEdge, createGraphDataProxyMixin('hostGraph', 'edgeData'));\nexport default Graph;\nexport { GraphNode, GraphEdge };","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { createHashMap, isObject, map, isString } from 'zrender/lib/core/util.js';\nvar uidBase = 0;\nvar OrdinalMeta = /** @class */function () {\n  function OrdinalMeta(opt) {\n    this.categories = opt.categories || [];\n    this._needCollect = opt.needCollect;\n    this._deduplication = opt.deduplication;\n    this.uid = ++uidBase;\n  }\n  OrdinalMeta.createByAxisModel = function (axisModel) {\n    var option = axisModel.option;\n    var data = option.data;\n    var categories = data && map(data, getName);\n    return new OrdinalMeta({\n      categories: categories,\n      needCollect: !categories,\n      // deduplication is default in axis.\n      deduplication: option.dedplication !== false\n    });\n  };\n  ;\n  OrdinalMeta.prototype.getOrdinal = function (category) {\n    // @ts-ignore\n    return this._getOrCreateMap().get(category);\n  };\n  /**\n   * @return The ordinal. If not found, return NaN.\n   */\n  OrdinalMeta.prototype.parseAndCollect = function (category) {\n    var index;\n    var needCollect = this._needCollect;\n    // The value of category dim can be the index of the given category set.\n    // This feature is only supported when !needCollect, because we should\n    // consider a common case: a value is 2017, which is a number but is\n    // expected to be tread as a category. This case usually happen in dataset,\n    // where it happent to be no need of the index feature.\n    if (!isString(category) && !needCollect) {\n      return category;\n    }\n    // Optimize for the scenario:\n    // category is ['2012-01-01', '2012-01-02', ...], where the input\n    // data has been ensured not duplicate and is large data.\n    // Notice, if a dataset dimension provide categroies, usually echarts\n    // should remove duplication except user tell echarts dont do that\n    // (set axis.deduplication = false), because echarts do not know whether\n    // the values in the category dimension has duplication (consider the\n    // parallel-aqi example)\n    if (needCollect && !this._deduplication) {\n      index = this.categories.length;\n      this.categories[index] = category;\n      return index;\n    }\n    var map = this._getOrCreateMap();\n    // @ts-ignore\n    index = map.get(category);\n    if (index == null) {\n      if (needCollect) {\n        index = this.categories.length;\n        this.categories[index] = category;\n        // @ts-ignore\n        map.set(category, index);\n      } else {\n        index = NaN;\n      }\n    }\n    return index;\n  };\n  // Consider big data, do not create map until needed.\n  OrdinalMeta.prototype._getOrCreateMap = function () {\n    return this._map || (this._map = createHashMap(this.categories));\n  };\n  return OrdinalMeta;\n}();\nfunction getName(obj) {\n  if (isObject(obj) && obj.value != null) {\n    return obj.value;\n  } else {\n    return obj + '';\n  }\n}\nexport default OrdinalMeta;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n/* global Int32Array */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport Model from '../model/Model.js';\nimport DataDiffer from './DataDiffer.js';\nimport { DefaultDataProvider } from './helper/dataProvider.js';\nimport { summarizeDimensions } from './helper/dimensionHelper.js';\nimport SeriesDimensionDefine from './SeriesDimensionDefine.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types.js';\nimport { convertOptionIdName, isDataItemOption } from '../util/model.js';\nimport { setCommonECData } from '../util/innerStore.js';\nimport { isSourceInstance } from './Source.js';\nimport DataStore from './DataStore.js';\nimport { isSeriesDataSchema } from './helper/SeriesDataSchema.js';\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar CtorInt32Array = typeof Int32Array === 'undefined' ? Array : Int32Array;\n// Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird update animation.\nvar ID_PREFIX = 'e\\0\\0';\nvar INDEX_NOT_FOUND = -1;\n// type SeriesDimensionIndex = DimensionIndex;\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_approximateExtent'];\n// -----------------------------\n// Internal method declarations:\n// -----------------------------\nvar prepareInvertedIndex;\nvar getId;\nvar getIdNameFromStore;\nvar normalizeDimensions;\nvar transferProperties;\nvar cloneListForMapAndSample;\nvar makeIdFromName;\nvar SeriesData = /** @class */function () {\n  /**\n   * @param dimensionsInput.dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function SeriesData(dimensionsInput, hostModel) {\n    this.type = 'list';\n    this._dimOmitted = false;\n    this._nameList = [];\n    this._idList = [];\n    // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n    this._visual = {};\n    // Global layout properties.\n    this._layout = {};\n    // Item visual properties after visual coding\n    this._itemVisuals = [];\n    // Item layout properties after layout\n    this._itemLayouts = [];\n    // Graphic elements\n    this._graphicEls = [];\n    // key: dim, value: extent\n    this._approximateExtent = {};\n    this._calculationInfo = {};\n    // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n    this.hasItemOption = false;\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    var dimensions;\n    var assignStoreDimIdx = false;\n    if (isSeriesDataSchema(dimensionsInput)) {\n      dimensions = dimensionsInput.dimensions;\n      this._dimOmitted = dimensionsInput.isDimensionOmitted();\n      this._schema = dimensionsInput;\n    } else {\n      assignStoreDimIdx = true;\n      dimensions = dimensionsInput;\n    }\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n    var needsHasOwn = false;\n    var emptyObj = {};\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new SeriesDimensionDefine({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      if (emptyObj[dimensionName] != null) {\n        needsHasOwn = true;\n      }\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n      }\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        zrUtil.assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);\n      }\n      if (assignStoreDimIdx) {\n        dimensionInfo.storeDimIndex = i;\n      }\n    }\n    this.dimensions = dimensionNames;\n    this._dimInfos = dimensionInfos;\n    this._initGetDimensionInfo(needsHasOwn);\n    this.hostModel = hostModel;\n    this._invertedIndicesMap = invertedIndicesMap;\n    if (this._dimOmitted) {\n      var dimIdxToName_1 = this._dimIdxToName = zrUtil.createHashMap();\n      zrUtil.each(dimensionNames, function (dimName) {\n        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);\n      });\n    }\n  }\n  /**\n   *\n   * Get concrete dimension name by dimension name or dimension index.\n   * If input a dimension name, do not validate whether the dimension name exits.\n   *\n   * @caution\n   * @param dim Must make sure the dimension is `SeriesDimensionLoose`.\n   * Because only those dimensions will have auto-generated dimension names if not\n   * have a user-specified name, and other dimensions will get a return of null/undefined.\n   *\n   * @notice Because of this reason, should better use `getDimensionIndex` instead, for examples:\n   * ```js\n   * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);\n   * ```\n   *\n   * @return Concrete dim name.\n   */\n  SeriesData.prototype.getDimension = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n    if (dimIdx == null) {\n      return dim;\n    }\n    dimIdx = dim;\n    if (!this._dimOmitted) {\n      return this.dimensions[dimIdx];\n    }\n    // Retrieve from series dimension definition because it probably contains\n    // generated dimension name (like 'x', 'y').\n    var dimName = this._dimIdxToName.get(dimIdx);\n    if (dimName != null) {\n      return dimName;\n    }\n    var sourceDimDef = this._schema.getSourceDimension(dimIdx);\n    if (sourceDimDef) {\n      return sourceDimDef.name;\n    }\n  };\n  /**\n   * Get dimension index in data store. Return -1 if not found.\n   * Can be used to index value from getRawValue.\n   */\n  SeriesData.prototype.getDimensionIndex = function (dim) {\n    var dimIdx = this._recognizeDimIndex(dim);\n    if (dimIdx != null) {\n      return dimIdx;\n    }\n    if (dim == null) {\n      return -1;\n    }\n    var dimInfo = this._getDimInfo(dim);\n    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;\n  };\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,\n   *        it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatibility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * @return recognized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).\n   */\n  SeriesData.prototype._recognizeDimIndex = function (dim) {\n    if (zrUtil.isNumber(dim)\n    // If being a number-like string but not being defined as a dimension name.\n    || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {\n      return +dim;\n    }\n  };\n  SeriesData.prototype._getStoreDimIndex = function (dim) {\n    var dimIdx = this.getDimensionIndex(dim);\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimIdx == null) {\n        throw new Error('Unknown dimension ' + dim);\n      }\n    }\n    return dimIdx;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n  SeriesData.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._getDimInfo(this.getDimension(dim));\n  };\n  SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {\n    var dimensionInfos = this._dimInfos;\n    this._getDimInfo = needsHasOwn ? function (dimName) {\n      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined;\n    } : function (dimName) {\n      return dimensionInfos[dimName];\n    };\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n  SeriesData.prototype.getDimensionsOnCoord = function () {\n    return this._dimSummary.dataDimsOnCoord.slice();\n  };\n  SeriesData.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimSummary;\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n  SeriesData.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n  SeriesData.prototype.getStore = function () {\n    return this._store;\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data store.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n  SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {\n    var _this = this;\n    var store;\n    if (data instanceof DataStore) {\n      store = data;\n    }\n    if (!store) {\n      var dimensions = this.dimensions;\n      var provider = isSourceInstance(data) || zrUtil.isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;\n      store = new DataStore();\n      var dimensionInfos = map(dimensions, function (dimName) {\n        return {\n          type: _this._dimInfos[dimName].type,\n          property: dimName\n        };\n      });\n      store.initData(provider, dimensionInfos, dimValueGetter);\n    }\n    this._store = store;\n    // Reset\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n    this._doInit(0, store.count());\n    // Cache summary info for fast visit. See \"dimensionHelper\".\n    // Needs to be initialized after store is prepared.\n    this._dimSummary = summarizeDimensions(this, this._schema);\n    this.userOutput = this._dimSummary.userOutput;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n  SeriesData.prototype.appendData = function (data) {\n    var range = this._store.appendData(data);\n    this._doInit(range[0], range[1]);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to store.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exactly corresponding to a dimension.\n   */\n  SeriesData.prototype.appendValues = function (values, names) {\n    var _a = this._store.appendValues(values, names.length),\n      start = _a.start,\n      end = _a.end;\n    var shouldMakeIdFromName = this._shouldMakeIdFromName();\n    this._updateOrdinalMeta();\n    if (names) {\n      for (var idx = start; idx < end; idx++) {\n        var sourceIdx = idx - start;\n        this._nameList[idx] = names[sourceIdx];\n        if (shouldMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n  };\n  SeriesData.prototype._updateOrdinalMeta = function () {\n    var store = this._store;\n    var dimensions = this.dimensions;\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfo = this._dimInfos[dimensions[i]];\n      if (dimInfo.ordinalMeta) {\n        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);\n      }\n    }\n  };\n  SeriesData.prototype._shouldMakeIdFromName = function () {\n    var provider = this._store.getProvider();\n    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;\n  };\n  SeriesData.prototype._doInit = function (start, end) {\n    if (start >= end) {\n      return;\n    }\n    var store = this._store;\n    var provider = store.getProvider();\n    this._updateOrdinalMeta();\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var sourceFormat = provider.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;\n    // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n    // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n    // This kind of ids and names are always stored `_nameList` and `_idList`.\n    if (isFormatOriginal && !provider.pure) {\n      var sharedDataItem = [];\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        var dataItem = provider.getItem(idx, sharedDataItem);\n        if (!this.hasItemOption && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n        if (dataItem) {\n          var itemName = dataItem.name;\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n          var itemId = dataItem.id;\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n      }\n    }\n    if (this._shouldMakeIdFromName()) {\n      for (var idx = start; idx < end; idx++) {\n        makeIdFromName(this, idx);\n      }\n    }\n    prepareInvertedIndex(this);\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n  SeriesData.prototype.getApproximateExtent = function (dim) {\n    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculate extent of filtered data outside.\n   */\n  SeriesData.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n  SeriesData.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n  SeriesData.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Because:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n  SeriesData.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);\n    }\n    if (name == null) {\n      name = '';\n    }\n    return name;\n  };\n  SeriesData.prototype._getCategory = function (dimIdx, idx) {\n    var ordinal = this._store.get(dimIdx, idx);\n    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);\n    if (ordinalMeta) {\n      return ordinalMeta.categories[ordinal];\n    }\n    return ordinal;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Because:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n  SeriesData.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n  SeriesData.prototype.count = function () {\n    return this._store.count();\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   *\n   * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.\n   */\n  SeriesData.prototype.get = function (dim, idx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n    if (dimInfo) {\n      return store.get(dimInfo.storeDimIndex, idx);\n    }\n  };\n  /**\n   * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.\n   */\n  SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {\n    var store = this._store;\n    var dimInfo = this._dimInfos[dim];\n    if (dimInfo) {\n      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);\n    }\n  };\n  SeriesData.prototype.getIndices = function () {\n    return this._store.getIndices();\n  };\n  SeriesData.prototype.getDataExtent = function (dim) {\n    return this._store.getDataExtent(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getSum = function (dim) {\n    return this._store.getSum(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getMedian = function (dim) {\n    return this._store.getMedian(this._getStoreDimIndex(dim));\n  };\n  SeriesData.prototype.getValues = function (dimensions, idx) {\n    var _this = this;\n    var store = this._store;\n    return zrUtil.isArray(dimensions) ? store.getValues(map(dimensions, function (dim) {\n      return _this._getStoreDimIndex(dim);\n    }), idx) : store.getValues(dimensions);\n  };\n  /**\n   * If value is NaN. Including '-'\n   * Only check the coord dimensions.\n   */\n  SeriesData.prototype.hasValue = function (idx) {\n    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;\n    for (var i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Retrieve the index with given name\n   */\n  SeriesData.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this._store.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  SeriesData.prototype.getRawIndex = function (idx) {\n    return this._store.getRawIndex(idx);\n  };\n  SeriesData.prototype.indexOfRawIndex = function (rawIndex) {\n    return this._store.indexOfRawIndex(rawIndex);\n  };\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n  SeriesData.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n    var rawIndex = invertedIndices[value];\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n    return rawIndex;\n  };\n  /**\n   * Retrieve the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n  SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);\n  };\n  SeriesData.prototype.each = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store.each(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  SeriesData.prototype.filterSelf = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    this._store = this._store.filter(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n  SeriesData.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n    var innerRange = {};\n    var dims = zrUtil.keys(range);\n    var dimIndices = [];\n    zrUtil.each(dims, function (dim) {\n      var dimIdx = _this._getStoreDimIndex(dim);\n      innerRange[dimIdx] = range[dim];\n      dimIndices.push(dimIdx);\n    });\n    this._store = this._store.selectRange(innerRange);\n    return this;\n  };\n  /* eslint-enable max-len */\n  SeriesData.prototype.mapArray = function (dims, cb, ctx) {\n    'use strict';\n\n    if (zrUtil.isFunction(dims)) {\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n    // ctxCompat just for compat echarts3\n    ctx = ctx || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n  SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || ctxCompat || this;\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.map(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n    return list;\n  };\n  SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {\n    var _this = this;\n    // ctxCompat just for compat echarts3\n    var fCtx = ctx || ctxCompat || this;\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.each(normalizeDimensions(dims), function (dim) {\n        var dimInfo = _this.getDimensionInfo(dim);\n        if (!dimInfo.isCalculationCoord) {\n          console.error('Danger: only stack dimension can be modified');\n        }\n      });\n    }\n    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);\n    // If do shallow clone here, if there are too many stacked series,\n    // it still cost lots of memory, because `_store.dimensions` are not shared.\n    // We should consider there probably be shallow clone happen in each series\n    // in consequent filter/map.\n    this._store.modify(dimIndices, fCtx ? zrUtil.bind(cb, fCtx) : cb);\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n  SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n  SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this);\n    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);\n    return list;\n  };\n  SeriesData.prototype.getRawDataItem = function (idx) {\n    return this._store.getRawDataItem(idx);\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n  SeriesData.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n  SeriesData.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n  SeriesData.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n  SeriesData.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n  SeriesData.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n  SeriesData.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n  SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n    var val = itemVisual[key];\n    if (val == null) {\n      val = this.getVisual(key);\n      // TODO Performance?\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n      itemVisual[key] = val;\n    }\n    return val;\n  };\n  // eslint-disable-next-line\n  SeriesData.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n  SeriesData.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n  SeriesData.prototype.setLayout = function (key, val) {\n    isObject(key) ? zrUtil.extend(this._layout, key) : this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n  SeriesData.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n  SeriesData.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n  SeriesData.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n  SeriesData.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n  SeriesData.prototype.setItemGraphicEl = function (idx, el) {\n    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;\n    setCommonECData(seriesIndex, this.dataType, idx, el);\n    this._graphicEls[idx] = el;\n  };\n  SeriesData.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n  SeriesData.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n  SeriesData.prototype.cloneShallow = function (list) {\n    if (!list) {\n      list = new SeriesData(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);\n    }\n    transferProperties(list, this);\n    list._store = this._store;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n  SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n    if (!zrUtil.isFunction(originalMethod)) {\n      return;\n    }\n    this.__wrappedMethods = this.__wrappedMethods || [];\n    this.__wrappedMethods.push(methodName);\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  };\n  // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n  SeriesData.internalField = function () {\n    prepareInvertedIndex = function (data) {\n      var invertedIndicesMap = data._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = data._dimInfos[dim];\n        // Currently, only dimensions that has ordinalMeta can create inverted indices.\n        var ordinalMeta = dimInfo.ordinalMeta;\n        var store = data._store;\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);\n          // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n          for (var i = 0; i < store.count(); i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;\n          }\n        }\n      });\n    };\n    getIdNameFromStore = function (data, dimIdx, idx) {\n      return convertOptionIdName(data._getCategory(dimIdx, idx), null);\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n    getId = function (data, rawIndex) {\n      var id = data._idList[rawIndex];\n      if (id == null && data._idDimIdx != null) {\n        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);\n      }\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n      return id;\n    };\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n      return dimensions;\n    };\n    /**\n     * Data in excludeDimensions is copied, otherwise transferred.\n     */\n    cloneListForMapAndSample = function (original) {\n      var list = new SeriesData(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel);\n      // FIXME If needs stackedOn, value may already been stacked\n      transferProperties(list, original);\n      return list;\n    };\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n    makeIdFromName = function (data, idx) {\n      var nameList = data._nameList;\n      var idList = data._idList;\n      var nameDimIdx = data._nameDimIdx;\n      var idDimIdx = data._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);\n      }\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);\n      }\n      if (id == null && name != null) {\n        var nameRepeatCount = data._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n        idList[idx] = id;\n      }\n    };\n  }();\n  return SeriesData;\n}();\nexport default SeriesData;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nvar SeriesDimensionDefine = /** @class */function () {\n  /**\n   * @param opt All of the fields will be shallow copied.\n   */\n  function SeriesDimensionDefine(opt) {\n    /**\n     * The format of `otherDims` is:\n     * ```js\n     * {\n     *     tooltip?: number\n     *     label?: number\n     *     itemName?: number\n     *     seriesName?: number\n     * }\n     * ```\n     *\n     * A `series.encode` can specified these fields:\n     * ```js\n     * encode: {\n     *     // \"3, 1, 5\" is the index of data dimension.\n     *     tooltip: [3, 1, 5],\n     *     label: [0, 3],\n     *     ...\n     * }\n     * ```\n     * `otherDims` is the parse result of the `series.encode` above, like:\n     * ```js\n     * // Suppose the index of this data dimension is `3`.\n     * this.otherDims = {\n     *     // `3` is at the index `0` of the `encode.tooltip`\n     *     tooltip: 0,\n     *     // `3` is at the index `1` of the `encode.label`\n     *     label: 1\n     * };\n     * ```\n     *\n     * This prop should never be `null`/`undefined` after initialized.\n     */\n    this.otherDims = {};\n    if (opt != null) {\n      zrUtil.extend(this, opt);\n    }\n  }\n  return SeriesDimensionDefine;\n}();\n;\nexport default SeriesDimensionDefine;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { isTypedArray, clone, createHashMap, isArray, isObject, isArrayLike, hasOwn, assert, each, map, isNumber, isString, keys } from 'zrender/lib/core/util.js';\nimport { SOURCE_FORMAT_ORIGINAL, SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_UNKNOWN, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SOURCE_FORMAT_OBJECT_ROWS, SERIES_LAYOUT_BY_ROW } from '../util/types.js';\nimport { getDataItemValue } from '../util/model.js';\nimport { BE_ORDINAL, guessOrdinal } from './helper/sourceHelper.js';\n;\n// @inner\nvar SourceImpl = /** @class */function () {\n  function SourceImpl(fields) {\n    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);\n    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;\n    // Visit config\n    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;\n    this.startIndex = fields.startIndex || 0;\n    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;\n    this.metaRawOption = fields.metaRawOption;\n    var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;\n    if (dimensionsDefine) {\n      for (var i = 0; i < dimensionsDefine.length; i++) {\n        var dim = dimensionsDefine[i];\n        if (dim.type == null) {\n          if (guessOrdinal(this, i) === BE_ORDINAL.Must) {\n            dim.type = 'ordinal';\n          }\n        }\n      }\n    }\n  }\n  return SourceImpl;\n}();\nexport function isSourceInstance(val) {\n  return val instanceof SourceImpl;\n}\n/**\n * Create a source from option.\n * NOTE: Created source is immutable. Don't change any properties in it.\n */\nexport function createSource(sourceData, thisMetaRawOption,\n// can be null. If not provided, auto detect it from `sourceData`.\nsourceFormat) {\n  sourceFormat = sourceFormat || detectSourceFormat(sourceData);\n  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;\n  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);\n  var source = new SourceImpl({\n    data: sourceData,\n    sourceFormat: sourceFormat,\n    seriesLayoutBy: seriesLayoutBy,\n    dimensionsDefine: determined.dimensionsDefine,\n    startIndex: determined.startIndex,\n    dimensionsDetectedCount: determined.dimensionsDetectedCount,\n    metaRawOption: clone(thisMetaRawOption)\n  });\n  return source;\n}\n/**\n * Wrap original series data for some compatibility cases.\n */\nexport function createSourceFromSeriesDataOption(data) {\n  return new SourceImpl({\n    data: data,\n    sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL\n  });\n}\n/**\n * Clone source but excludes source data.\n */\nexport function cloneSourceShallow(source) {\n  return new SourceImpl({\n    data: source.data,\n    sourceFormat: source.sourceFormat,\n    seriesLayoutBy: source.seriesLayoutBy,\n    dimensionsDefine: clone(source.dimensionsDefine),\n    startIndex: source.startIndex,\n    dimensionsDetectedCount: source.dimensionsDetectedCount\n  });\n}\n/**\n * Note: An empty array will be detected as `SOURCE_FORMAT_ARRAY_ROWS`.\n */\nexport function detectSourceFormat(data) {\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n    }\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n      if (item == null) {\n        continue;\n      } else if (isArray(item) || isTypedArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (hasOwn(data, key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  }\n  return sourceFormat;\n}\n/**\n * Determine the source definitions from data standalone dimensions definitions\n * are not specified.\n */\nfunction determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader,\n// standalone raw dimensions definition, like:\n// {\n//     dimensions: ['aa', 'bb', { name: 'cc', type: 'time' }]\n// }\n// in `dataset` or `series`\ndimensionsDefine) {\n  var dimensionsDetectedCount;\n  var startIndex;\n  // PENDING: Could data be null/undefined here?\n  // currently, if `dataset.source` not specified, error thrown.\n  // if `series.data` not specified, nothing rendered without error thrown.\n  // Should test these cases.\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),\n      startIndex: startIndex,\n      dimensionsDetectedCount: dimensionsDetectedCount\n    };\n  }\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var dataArrayRows = data;\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        }\n        // 10 is an experience number, avoid long loop.\n      }, seriesLayoutBy, dataArrayRows, 10);\n    } else {\n      startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;\n    }\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val + '' : '';\n      }, seriesLayoutBy, dataArrayRows, Infinity);\n    }\n    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectedCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(!!dimensionsDefine, 'dimensions must be given if data is TypedArray.');\n    }\n  }\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),\n    dimensionsDetectedCount: dimensionsDetectedCount\n  };\n}\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n  if (obj) {\n    return keys(obj);\n  }\n}\n// Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefined or string.\nfunction normalizeDimensionsOption(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (rawItem, index) {\n    rawItem = isObject(rawItem) ? rawItem : {\n      name: rawItem\n    };\n    // Other fields will be discarded.\n    var item = {\n      name: rawItem.name,\n      displayName: rawItem.displayName,\n      type: rawItem.type\n    };\n    // User can set null in dimensions.\n    // We don't auto specify name, otherwise a given name may\n    // cause it to be referred unexpectedly.\n    if (item.name == null) {\n      return item;\n    }\n    // Also consider number form like 2012.\n    item.name += '';\n    // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n    var exist = nameMap.get(item.name);\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n    return item;\n  });\n}\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\nexport function shouldRetrieveDataByName(source) {\n  var sourceFormat = source.sourceFormat;\n  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n/**\n * Tree data structure\n */\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport linkSeriesData from './helper/linkSeriesData.js';\nimport SeriesData from './SeriesData.js';\nimport prepareSeriesDataSchema from './helper/createDimensions.js';\nimport { convertOptionIdName } from '../util/model.js';\nvar TreeNode = /** @class */function () {\n  function TreeNode(name, hostTree) {\n    this.depth = 0;\n    this.height = 0;\n    /**\n     * Reference to list item.\n     * Do not persistent dataIndex outside,\n     * besause it may be changed by list.\n     * If dataIndex -1,\n     * this node is logical deleted (filtered) in list.\n     */\n    this.dataIndex = -1;\n    this.children = [];\n    this.viewChildren = [];\n    this.isExpand = false;\n    this.name = name || '';\n    this.hostTree = hostTree;\n  }\n  /**\n   * The node is removed.\n   */\n  TreeNode.prototype.isRemoved = function () {\n    return this.dataIndex < 0;\n  };\n  TreeNode.prototype.eachNode = function (options, cb, context) {\n    if (zrUtil.isFunction(options)) {\n      context = cb;\n      cb = options;\n      options = null;\n    }\n    options = options || {};\n    if (zrUtil.isString(options)) {\n      options = {\n        order: options\n      };\n    }\n    var order = options.order || 'preorder';\n    var children = this[options.attr || 'children'];\n    var suppressVisitSub;\n    order === 'preorder' && (suppressVisitSub = cb.call(context, this));\n    for (var i = 0; !suppressVisitSub && i < children.length; i++) {\n      children[i].eachNode(options, cb, context);\n    }\n    order === 'postorder' && cb.call(context, this);\n  };\n  /**\n   * Update depth and height of this subtree.\n   */\n  TreeNode.prototype.updateDepthAndHeight = function (depth) {\n    var height = 0;\n    this.depth = depth;\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n      child.updateDepthAndHeight(depth + 1);\n      if (child.height > height) {\n        height = child.height;\n      }\n    }\n    this.height = height + 1;\n  };\n  TreeNode.prototype.getNodeById = function (id) {\n    if (this.getId() === id) {\n      return this;\n    }\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].getNodeById(id);\n      if (res) {\n        return res;\n      }\n    }\n  };\n  TreeNode.prototype.contains = function (node) {\n    if (node === this) {\n      return true;\n    }\n    for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n      var res = children[i].contains(node);\n      if (res) {\n        return res;\n      }\n    }\n  };\n  /**\n   * @param includeSelf Default false.\n   * @return order: [root, child, grandchild, ...]\n   */\n  TreeNode.prototype.getAncestors = function (includeSelf) {\n    var ancestors = [];\n    var node = includeSelf ? this : this.parentNode;\n    while (node) {\n      ancestors.push(node);\n      node = node.parentNode;\n    }\n    ancestors.reverse();\n    return ancestors;\n  };\n  TreeNode.prototype.getAncestorsIndices = function () {\n    var indices = [];\n    var currNode = this;\n    while (currNode) {\n      indices.push(currNode.dataIndex);\n      currNode = currNode.parentNode;\n    }\n    indices.reverse();\n    return indices;\n  };\n  TreeNode.prototype.getDescendantIndices = function () {\n    var indices = [];\n    this.eachNode(function (childNode) {\n      indices.push(childNode.dataIndex);\n    });\n    return indices;\n  };\n  TreeNode.prototype.getValue = function (dimension) {\n    var data = this.hostTree.data;\n    return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex);\n  };\n  TreeNode.prototype.setLayout = function (layout, merge) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);\n  };\n  /**\n   * @return {Object} layout\n   */\n  TreeNode.prototype.getLayout = function () {\n    return this.hostTree.data.getItemLayout(this.dataIndex);\n  };\n  // @depcrecated\n  // getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TreeNode.prototype.getModel = function (path) {\n    if (this.dataIndex < 0) {\n      return;\n    }\n    var hostTree = this.hostTree;\n    var itemModel = hostTree.data.getItemModel(this.dataIndex);\n    return itemModel.getModel(path);\n  };\n  // TODO: TYPE More specific model\n  TreeNode.prototype.getLevelModel = function () {\n    return (this.hostTree.levelModels || [])[this.depth];\n  };\n  TreeNode.prototype.setVisual = function (key, value) {\n    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);\n  };\n  /**\n   * Get item visual\n   * FIXME: make return type better\n   */\n  TreeNode.prototype.getVisual = function (key) {\n    return this.hostTree.data.getItemVisual(this.dataIndex, key);\n  };\n  TreeNode.prototype.getRawIndex = function () {\n    return this.hostTree.data.getRawIndex(this.dataIndex);\n  };\n  TreeNode.prototype.getId = function () {\n    return this.hostTree.data.getId(this.dataIndex);\n  };\n  /**\n   * index in parent's children\n   */\n  TreeNode.prototype.getChildIndex = function () {\n    if (this.parentNode) {\n      var children = this.parentNode.children;\n      for (var i = 0; i < children.length; ++i) {\n        if (children[i] === this) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    return -1;\n  };\n  /**\n   * if this is an ancestor of another node\n   *\n   * @param node another node\n   * @return if is ancestor\n   */\n  TreeNode.prototype.isAncestorOf = function (node) {\n    var parent = node.parentNode;\n    while (parent) {\n      if (parent === this) {\n        return true;\n      }\n      parent = parent.parentNode;\n    }\n    return false;\n  };\n  /**\n   * if this is an descendant of another node\n   *\n   * @param node another node\n   * @return if is descendant\n   */\n  TreeNode.prototype.isDescendantOf = function (node) {\n    return node !== this && node.isAncestorOf(this);\n  };\n  return TreeNode;\n}();\nexport { TreeNode };\n;\nvar Tree = /** @class */function () {\n  function Tree(hostModel) {\n    this.type = 'tree';\n    this._nodes = [];\n    this.hostModel = hostModel;\n  }\n  Tree.prototype.eachNode = function (options, cb, context) {\n    this.root.eachNode(options, cb, context);\n  };\n  Tree.prototype.getNodeByDataIndex = function (dataIndex) {\n    var rawIndex = this.data.getRawIndex(dataIndex);\n    return this._nodes[rawIndex];\n  };\n  Tree.prototype.getNodeById = function (name) {\n    return this.root.getNodeById(name);\n  };\n  /**\n   * Update item available by list,\n   * when list has been performed options like 'filterSelf' or 'map'.\n   */\n  Tree.prototype.update = function () {\n    var data = this.data;\n    var nodes = this._nodes;\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      nodes[i].dataIndex = -1;\n    }\n    for (var i = 0, len = data.count(); i < len; i++) {\n      nodes[data.getRawIndex(i)].dataIndex = i;\n    }\n  };\n  /**\n   * Clear all layouts\n   */\n  Tree.prototype.clearLayouts = function () {\n    this.data.clearItemLayouts();\n  };\n  /**\n   * data node format:\n   * {\n   *     name: ...\n   *     value: ...\n   *     children: [\n   *         {\n   *             name: ...\n   *             value: ...\n   *             children: ...\n   *         },\n   *         ...\n   *     ]\n   * }\n   */\n  Tree.createTree = function (dataRoot, hostModel, beforeLink) {\n    var tree = new Tree(hostModel);\n    var listData = [];\n    var dimMax = 1;\n    buildHierarchy(dataRoot);\n    function buildHierarchy(dataNode, parentNode) {\n      var value = dataNode.value;\n      dimMax = Math.max(dimMax, zrUtil.isArray(value) ? value.length : 1);\n      listData.push(dataNode);\n      var node = new TreeNode(convertOptionIdName(dataNode.name, ''), tree);\n      parentNode ? addChild(node, parentNode) : tree.root = node;\n      tree._nodes.push(node);\n      var children = dataNode.children;\n      if (children) {\n        for (var i = 0; i < children.length; i++) {\n          buildHierarchy(children[i], node);\n        }\n      }\n    }\n    tree.root.updateDepthAndHeight(0);\n    var dimensions = prepareSeriesDataSchema(listData, {\n      coordDimensions: ['value'],\n      dimensionsCount: dimMax\n    }).dimensions;\n    var list = new SeriesData(dimensions, hostModel);\n    list.initData(listData);\n    beforeLink && beforeLink(list);\n    linkSeriesData({\n      mainData: list,\n      struct: tree,\n      structAttr: 'tree'\n    });\n    tree.update();\n    return tree;\n  };\n  return Tree;\n}();\n/**\n * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,\n * so this function is not ready and not necessary to be public.\n */\nfunction addChild(child, node) {\n  var children = node.children;\n  if (child.parentNode === node) {\n    return;\n  }\n  children.push(child);\n  child.parentNode = node;\n}\nexport default Tree;"],"names":["dataIndexMapValueLength","valNumOrArrLengthMoreThan2","length","defaultKeyGetter","item","DataDiffer","oldArr","newArr","oldKeyGetter","newKeyGetter","context","diffMode","this","_old","_new","_oldKeyGetter","_newKeyGetter","_diffModeMultiple","prototype","add","func","_add","update","_update","updateManyToOne","_updateManyToOne","updateOneToMany","_updateOneToMany","updateManyToMany","_updateManyToMany","remove","_remove","execute","_executeOneToOne","newDataIndexMap","oldDataKeyArr","Array","newDataKeyArr","_initIndexMap","i","oldKey","newIdxMapVal","newIdxMapValLen","newIdx","shift","_performRestAdd","_executeMultiple","oldDataIndexMap","oldIdxMapVal","oldIdxMapValLen","i_1","newKey","idxMapValLen","j","arr","map","keyArr","keyGetterName","cbModeMultiple","key","idxMapVal","push","defaultDimValueGetters","UNDEFINED","CtorUint32Array","Uint32Array","CtorUint16Array","Uint16Array","CtorInt32Array","Int32Array","CtorFloat64Array","Float64Array","dataCtors","getIndicesCtor","rawCount","getInitialExtent","Infinity","cloneChunk","originalChunk","Ctor","constructor","slice","prepareStore","store","dimIdx","dimType","end","append","DataCtor","oldStore","oldLen","newStore","DataStore","_chunks","_rawExtent","_extent","_count","_rawCount","_calcDimNameToIdx","createHashMap","initData","provider","inputDimensions","dimValueGetter","_provider","_indices","getRawIndex","_getRawIdxIdentity","source","getSource","defaultGetter","defaultDimValueGetter","sourceFormat","_dimValueGetter","shouldRetrieveDataByName","_dimensions","dim","type","property","_initDataFromProvider","count","getProvider","ensureCalculationDimension","dimName","calcDimNameToIdx","dimensions","calcDimIdx","get","set","collectOrdinalMeta","ordinalMeta","chunk","rawExtents","offset","ordinalOffset","len","dimRawExtent","val","parseAndCollect","isNaN","Math","min","max","getOrdinalMeta","dimInfo","getDimensionProperty","dimIndex","appendData","data","start","persistent","appendValues","values","minFillLen","chunks","dimLen","rawExtent","emptyDataItem","idx","sourceIdx","arrayRows","call","dimNames","fillStorage","dataItem","getItem","dimStorage","clean","NaN","dimStore","getValues","dimArr","getByRawIndex","rawIdx","getSum","dimData","sum","value","getMedian","dimDataArray","each","sortedDimDataArray","sort","a","b","indexOfRawIndex","rawIndex","indices","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","minDist","minDiff","nearestIndicesLen","dataIndex","diff","dist","abs","getIndices","newIndices","thisCount","buffer","filter","dims","cb","clone","dimSize","dim0","keep","k","apply","_updateGetRawIdx","selectRange","range","keys","originalCount","storeArr","quickFinished","dimStorage2","min2","max2","val2","dimk","target","_updateDims","modify","targetChunks","tmpRetValue","dataCount","retValue","rawExtentOnDim","lttbDownSample","valueDimension","rate","maxArea","area","nextRawIndex","targetStorage","sampledIndex","frameSize","floor","currentRawIndex","ceil","nextFrameStart","nextFrameEnd","avgX","avgY","y","frameStart","frameEnd","pointAX","pointAY","firstNaNIndex","countNaN","_getRawIdx","downSample","dimension","sampleValue","sampleIndex","frameValues","dataIdx","sampleFrameIdx","getDataExtent","initialExtent","dimExtent","currEnd","useRaw","getRawDataItem","clonedDims","ignoreIndices","clonedDimsMap","reduce","obj","_copyCommonProps","_cloneIndices","internalField","getDimValueSimply","parseDataValue","objectRows","keyedColumns","original","typedArray","generateNodeKey","id","Graph","directed","nodes","edges","_nodesMap","_edgesMap","_directed","isDirected","addNode","nodesMap","node","GraphNode","hostGraph","getNodeByIndex","getNodeById","addEdge","n1","n2","edgesMap","zrUtil","edge","GraphEdge","outEdges","inEdges","getEdgeByIndex","edgeData","getEdge","eachNode","eachEdge","node1","node2","breadthFirstTraverse","startNode","direction","edgeType","__visited","queue","currentNode","e","otherNode","filterSelf","graph","degree","inDegree","outDegree","getModel","path","itemModel","getItemModel","getAdjacentDataIndices","dataIndices","adjacentEdge","getTrajectoryDataIndices","connectedEdgesMap","connectedNodesMap","sourceNodesQueue","targetNodesQueue","nodeIteratorIndex","sourceNode","targetNode","sourceNodes","targetNodes","createGraphDataProxyMixin","hostName","dataName","getValue","getStore","getDimensionIndex","setVisual","setItemVisual","getVisual","getItemVisual","setLayout","layout","merge","setItemLayout","getLayout","getItemLayout","getGraphicEl","getItemGraphicEl","uidBase","OrdinalMeta","opt","categories","_needCollect","needCollect","_deduplication","deduplication","uid","createByAxisModel","axisModel","option","getName","dedplication","getOrdinal","category","_getOrCreateMap","index","isString","_map","isObject","prepareInvertedIndex","getId","getIdNameFromStore","normalizeDimensions","transferProperties","cloneListForMapAndSample","makeIdFromName","ID_PREFIX","INDEX_NOT_FOUND","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","SeriesData","dimensionsInput","hostModel","_dimOmitted","_nameList","_idList","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_approximateExtent","_calculationInfo","hasItemOption","TRANSFERABLE_METHODS","CHANGABLE_METHODS","DOWNSAMPLE_METHODS","assignStoreDimIdx","isSeriesDataSchema","isDimensionOmitted","_schema","dimensionInfos","dimensionNames","invertedIndicesMap","needsHasOwn","emptyObj","dimInfoInput","dimensionInfo","SeriesDimensionDefine","name","dimensionName","coordDim","coordDimIndex","otherDims","createInvertedIndices","itemName","_nameDimIdx","itemId","_idDimIdx","storeDimIndex","_dimInfos","_initGetDimensionInfo","_invertedIndicesMap","dimIdxToName_1","_dimIdxToName","getDimension","_recognizeDimIndex","sourceDimDef","getSourceDimension","_getDimInfo","getSourceDimensionIndex","_getStoreDimIndex","getDimensionInfo","hasOwnProperty","undefined","getDimensionsOnCoord","_dimSummary","dataDimsOnCoord","mapDimension","dimensionsSummary","encodeFirstDimNotExtra","encode","mapDimensionsAll","_store","nameList","_this","isSourceInstance","DefaultDataProvider","_nameRepeatCount","_doInit","summarizeDimensions","userOutput","names","_a","shouldMakeIdFromName","_shouldMakeIdFromName","_updateOrdinalMeta","SOURCE_FORMAT_TYPED_ARRAY","idList","isFormatOriginal","SOURCE_FORMAT_ORIGINAL","pure","sharedDataItem","isDataItemOption","convertOptionIdName","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","setCalculationInfo","_getCategory","ordinal","hasValue","dataDimIndicesOnCoord","indexOfName","rawIndexOf","invertedIndices","ctx","fCtx","dimIndices","innerRange","mapArray","result","arguments","ctxCompat","list","Model","ecModel","otherList","thisList","visual","kvObj","itemVisual","hasItemVisual","ensureUniqueItemVisual","itemVisuals","clearAllVisual","clearItemLayouts","setItemGraphicEl","el","seriesIndex","setCommonECData","dataType","eachItemGraphicEl","cloneShallow","wrapMethod","methodName","injectFunction","originalMethod","__wrappedMethods","res","concat","propName","nameDimIdx","idDimIdx","nameRepeatCount","nmCnt","SourceImpl","fields","SOURCE_FORMAT_KEYED_COLUMNS","SOURCE_FORMAT_UNKNOWN","seriesLayoutBy","SERIES_LAYOUT_BY_COLUMN","startIndex","dimensionsDetectedCount","metaRawOption","dimensionsDefine","guessOrdinal","BE_ORDINAL","Must","createSource","sourceData","thisMetaRawOption","detectSourceFormat","determined","determineSourceDimensions","sourceHeader","createSourceFromSeriesDataOption","isTypedArray","cloneSourceShallow","isArray","SOURCE_FORMAT_ARRAY_ROWS","SOURCE_FORMAT_OBJECT_ROWS","hasOwn","isArrayLike","normalizeDimensionsOption","dataArrayRows","arrayRowsTravelFirst","isNumber","SERIES_LAYOUT_BY_ROW","objectRowsCollectDimensions","colArr","value0","getDataItemValue","firstIndex","nameMap","rawItem","displayName","exist","maxLoop","TreeNode","hostTree","depth","height","children","viewChildren","isExpand","isRemoved","options","order","suppressVisitSub","attr","updateDepthAndHeight","child","contains","getAncestors","includeSelf","ancestors","parentNode","reverse","getAncestorsIndices","currNode","getDescendantIndices","childNode","getLevelModel","levelModels","getChildIndex","isAncestorOf","parent","isDescendantOf","Tree","_nodes","root","getNodeByDataIndex","clearLayouts","createTree","dataRoot","beforeLink","tree","listData","dimMax","buildHierarchy","dataNode","addChild","prepareSeriesDataSchema","coordDimensions","dimensionsCount","linkSeriesData","mainData","struct","structAttr"],"sourceRoot":""}