{"version":3,"file":"static/client/js/chunk-vendors-c06fdc76.e95a3cad.js","mappings":"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","sources":["webpack://d1/./node_modules/claygl/src/util/shader/integrateBRDF.glsl.js","webpack://d1/./node_modules/claygl/src/util/shader/prefilter.glsl.js","webpack://d1/./node_modules/claygl/src/util/cubemap.js","webpack://d1/./node_modules/claygl/src/util/sh.js","webpack://d1/./node_modules/claygl/src/util/dds.js","webpack://d1/./node_modules/claygl/src/util/hdr.js","webpack://d1/./node_modules/claygl/src/util/texture.js"],"sourcesContent":["export default \"#define SAMPLE_NUMBER 1024\\n#define PI 3.14159265358979\\nuniform sampler2D normalDistribution;\\nuniform vec2 viewportSize : [512, 256];\\nconst vec3 N = vec3(0.0, 0.0, 1.0);\\nconst float fSampleNumber = float(SAMPLE_NUMBER);\\nvec3 importanceSampleNormal(float i, float roughness, vec3 N) {\\n vec3 H = texture2D(normalDistribution, vec2(roughness, i)).rgb;\\n vec3 upVector = abs(N.y) > 0.999 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\\n vec3 tangentX = normalize(cross(N, upVector));\\n vec3 tangentZ = cross(N, tangentX);\\n return normalize(tangentX * H.x + N * H.y + tangentZ * H.z);\\n}\\nfloat G_Smith(float roughness, float NoV, float NoL) {\\n float k = roughness * roughness / 2.0;\\n float G1V = NoV / (NoV * (1.0 - k) + k);\\n float G1L = NoL / (NoL * (1.0 - k) + k);\\n return G1L * G1V;\\n}\\nvoid main() {\\n vec2 uv = gl_FragCoord.xy / viewportSize;\\n float NoV = uv.x;\\n float roughness = uv.y;\\n vec3 V;\\n V.x = sqrt(1.0 - NoV * NoV);\\n V.y = 0.0;\\n V.z = NoV;\\n float A = 0.0;\\n float B = 0.0;\\n for (int i = 0; i < SAMPLE_NUMBER; i++) {\\n vec3 H = importanceSampleNormal(float(i) / fSampleNumber, roughness, N);\\n vec3 L = reflect(-V, H);\\n float NoL = clamp(L.z, 0.0, 1.0);\\n float NoH = clamp(H.z, 0.0, 1.0);\\n float VoH = clamp(dot(V, H), 0.0, 1.0);\\n if (NoL > 0.0) {\\n float G = G_Smith(roughness, NoV, NoL);\\n float G_Vis = G * VoH / (NoH * NoV);\\n float Fc = pow(1.0 - VoH, 5.0);\\n A += (1.0 - Fc) * G_Vis;\\n B += Fc * G_Vis;\\n }\\n }\\n gl_FragColor = vec4(vec2(A, B) / fSampleNumber, 0.0, 1.0);\\n}\\n\";\n","export default \"#define SHADER_NAME prefilter\\n#define SAMPLE_NUMBER 1024\\n#define PI 3.14159265358979\\nuniform mat4 viewInverse : VIEWINVERSE;\\nuniform samplerCube environmentMap;\\nuniform sampler2D normalDistribution;\\nuniform float roughness : 0.5;\\nvarying vec2 v_Texcoord;\\nvarying vec3 v_WorldPosition;\\n@import clay.util.rgbm\\nvec3 importanceSampleNormal(float i, float roughness, vec3 N) {\\n vec3 H = texture2D(normalDistribution, vec2(roughness, i)).rgb;\\n vec3 upVector = abs(N.y) > 0.999 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\\n vec3 tangentX = normalize(cross(N, upVector));\\n vec3 tangentZ = cross(N, tangentX);\\n return normalize(tangentX * H.x + N * H.y + tangentZ * H.z);\\n}\\nvoid main() {\\n vec3 eyePos = viewInverse[3].xyz;\\n vec3 V = normalize(v_WorldPosition - eyePos);\\n vec3 N = V;\\n vec3 prefilteredColor = vec3(0.0);\\n float totalWeight = 0.0;\\n float fMaxSampleNumber = float(SAMPLE_NUMBER);\\n for (int i = 0; i < SAMPLE_NUMBER; i++) {\\n vec3 H = importanceSampleNormal(float(i) / fMaxSampleNumber, roughness, N);\\n vec3 L = reflect(-V, H);\\n float NoL = clamp(dot(N, L), 0.0, 1.0);\\n if (NoL > 0.0) {\\n prefilteredColor += decodeHDR(textureCube(environmentMap, L)).rgb * NoL;\\n totalWeight += NoL;\\n }\\n }\\n gl_FragColor = encodeHDR(vec4(prefilteredColor / totalWeight, 1.0));\\n}\\n\";\n","// Cubemap prefilter utility\n// http://www.unrealengine.com/files/downloads/2013SiggraphPresentationsNotes.pdf\n// http://http.developer.nvidia.com/GPUGems3/gpugems3_ch20.html\nimport Texture2D from '../Texture2D';\nimport TextureCube from '../TextureCube';\nimport Texture from '../Texture';\nimport FrameBuffer from '../FrameBuffer';\nimport Pass from '../compositor/Pass';\nimport Material from '../Material';\nimport Shader from '../Shader';\nimport Skybox from '../plugin/Skybox';\nimport Scene from '../Scene';\nimport EnvironmentMapPass from '../prePass/EnvironmentMap';\nimport vendor from '../core/vendor';\nimport textureUtil from './texture';\n\nimport integrateBRDFShaderCode from './shader/integrateBRDF.glsl.js';\nimport prefilterFragCode from './shader/prefilter.glsl.js';\n\nvar cubemapUtil = {};\n\nvar targets = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];\n\n// TODO Downsample\n/**\n * @name clay.util.cubemap.prefilterEnvironmentMap\n * @param  {clay.Renderer} renderer\n * @param  {clay.Texture} envMap\n * @param  {Object} [textureOpts]\n * @param  {number} [textureOpts.width=64]\n * @param  {number} [textureOpts.height=64]\n * @param  {number} [textureOpts.type]\n * @param  {boolean} [textureOpts.encodeRGBM=false]\n * @param  {boolean} [textureOpts.decodeRGBM=false]\n * @param  {clay.Texture2D} [normalDistribution]\n * @param  {clay.Texture2D} [brdfLookup]\n */\ncubemapUtil.prefilterEnvironmentMap = function (\n    renderer, envMap, textureOpts, normalDistribution, brdfLookup\n) {\n    // Not create other renderer, it is easy having issue of cross reference of resources like framebuffer\n    // PENDING preserveDrawingBuffer?\n    if (!brdfLookup || !normalDistribution) {\n        normalDistribution = cubemapUtil.generateNormalDistribution();\n        brdfLookup = cubemapUtil.integrateBRDF(renderer, normalDistribution);\n    }\n    textureOpts = textureOpts || {};\n\n    var width = textureOpts.width || 64;\n    var height = textureOpts.height || 64;\n\n    var textureType = textureOpts.type || envMap.type;\n\n    // Use same type with given envMap\n    var prefilteredCubeMap = new TextureCube({\n        width: width,\n        height: height,\n        type: textureType,\n        flipY: false,\n        mipmaps: []\n    });\n\n    if (!prefilteredCubeMap.isPowerOfTwo()) {\n        console.warn('Width and height must be power of two to enable mipmap.');\n    }\n\n    var size = Math.min(width, height);\n    var mipmapNum = Math.log(size) / Math.log(2) + 1;\n\n    var prefilterMaterial = new Material({\n        shader: new Shader({\n            vertex: Shader.source('clay.skybox.vertex'),\n            fragment: prefilterFragCode\n        })\n    });\n    prefilterMaterial.set('normalDistribution', normalDistribution);\n\n    textureOpts.encodeRGBM && prefilterMaterial.define('fragment', 'RGBM_ENCODE');\n    textureOpts.decodeRGBM && prefilterMaterial.define('fragment', 'RGBM_DECODE');\n\n    var dummyScene = new Scene();\n    var skyEnv;\n\n    if (envMap.textureType === 'texture2D') {\n        // Convert panorama to cubemap\n        var envCubemap = new TextureCube({\n            width: width,\n            height: height,\n            // FIXME FLOAT type will cause GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT error on iOS\n            type: textureType === Texture.FLOAT ?\n                Texture.HALF_FLOAT : textureType\n        });\n        textureUtil.panoramaToCubeMap(renderer, envMap, envCubemap, {\n            // PENDING encodeRGBM so it can be decoded as RGBM\n            encodeRGBM: textureOpts.decodeRGBM\n        });\n        envMap = envCubemap;\n    }\n    skyEnv = new Skybox({\n        scene: dummyScene,\n        material: prefilterMaterial\n    });\n    skyEnv.material.set('environmentMap', envMap);\n\n    var envMapPass = new EnvironmentMapPass({\n        texture: prefilteredCubeMap\n    });\n\n    // Force to be UNSIGNED_BYTE\n    if (textureOpts.encodeRGBM) {\n        textureType = prefilteredCubeMap.type = Texture.UNSIGNED_BYTE;\n    }\n\n    var renderTargetTmp = new Texture2D({\n        width: width,\n        height: height,\n        type: textureType\n    });\n    var frameBuffer = new FrameBuffer({\n        depthBuffer: false\n    });\n    var ArrayCtor = vendor[textureType === Texture.UNSIGNED_BYTE ? 'Uint8Array' : 'Float32Array'];\n    for (var i = 0; i < mipmapNum; i++) {\n        // console.time('prefilter');\n        prefilteredCubeMap.mipmaps[i] = {\n            pixels: {}\n        };\n        skyEnv.material.set('roughness', i / (mipmapNum - 1));\n\n        // Tweak fov\n        // http://the-witness.net/news/2012/02/seamless-cube-map-filtering/\n        var n = renderTargetTmp.width;\n        var fov = 2 * Math.atan(n / (n - 0.5)) / Math.PI * 180;\n\n        for (var j = 0; j < targets.length; j++) {\n            var pixels = new ArrayCtor(renderTargetTmp.width * renderTargetTmp.height * 4);\n            frameBuffer.attach(renderTargetTmp);\n            frameBuffer.bind(renderer);\n\n            var camera = envMapPass.getCamera(targets[j]);\n            camera.fov = fov;\n            renderer.render(dummyScene, camera);\n            renderer.gl.readPixels(\n                0, 0, renderTargetTmp.width, renderTargetTmp.height,\n                Texture.RGBA, textureType, pixels\n            );\n\n            // var canvas = document.createElement('canvas');\n            // var ctx = canvas.getContext('2d');\n            // canvas.width = renderTargetTmp.width;\n            // canvas.height = renderTargetTmp.height;\n            // var imageData = ctx.createImageData(renderTargetTmp.width, renderTargetTmp.height);\n            // for (var k = 0; k < pixels.length; k++) {\n            //     imageData.data[k] = pixels[k];\n            // }\n            // ctx.putImageData(imageData, 0, 0);\n            // document.body.appendChild(canvas);\n\n            frameBuffer.unbind(renderer);\n            prefilteredCubeMap.mipmaps[i].pixels[targets[j]] = pixels;\n        }\n\n        renderTargetTmp.width /= 2;\n        renderTargetTmp.height /= 2;\n        renderTargetTmp.dirty();\n        // console.timeEnd('prefilter');\n    }\n\n    frameBuffer.dispose(renderer);\n    renderTargetTmp.dispose(renderer);\n    skyEnv.dispose(renderer);\n    // Remove gpu resource allucated in renderer\n    normalDistribution.dispose(renderer);\n\n    // renderer.dispose();\n\n    return {\n        environmentMap: prefilteredCubeMap,\n        brdfLookup: brdfLookup,\n        normalDistribution: normalDistribution,\n        maxMipmapLevel: mipmapNum\n    };\n};\n\ncubemapUtil.integrateBRDF = function (renderer, normalDistribution) {\n    normalDistribution = normalDistribution || cubemapUtil.generateNormalDistribution();\n    var framebuffer = new FrameBuffer({\n        depthBuffer: false\n    });\n    var pass = new Pass({\n        fragment: integrateBRDFShaderCode\n    });\n\n    var texture = new Texture2D({\n        width: 512,\n        height: 256,\n        type: Texture.HALF_FLOAT,\n        wrapS: Texture.CLAMP_TO_EDGE,\n        wrapT: Texture.CLAMP_TO_EDGE,\n        minFilter: Texture.NEAREST,\n        magFilter: Texture.NEAREST,\n        useMipmap: false\n    });\n    pass.setUniform('normalDistribution', normalDistribution);\n    pass.setUniform('viewportSize', [512, 256]);\n    pass.attachOutput(texture);\n    pass.render(renderer, framebuffer);\n\n    // FIXME Only chrome and firefox can readPixels with float type.\n    // framebuffer.bind(renderer);\n    // var pixels = new Float32Array(512 * 256 * 4);\n    // renderer.gl.readPixels(\n    //     0, 0, texture.width, texture.height,\n    //     Texture.RGBA, Texture.FLOAT, pixels\n    // );\n    // texture.pixels = pixels;\n    // texture.flipY = false;\n    // texture.dirty();\n    // framebuffer.unbind(renderer);\n\n    framebuffer.dispose(renderer);\n\n    return texture;\n};\n\ncubemapUtil.generateNormalDistribution = function (roughnessLevels, sampleSize) {\n\n    // http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n    // GLSL not support bit operation, use lookup instead\n    // V -> i / N, U -> roughness\n    var roughnessLevels = roughnessLevels || 256;\n    var sampleSize = sampleSize || 1024;\n\n    var normalDistribution = new Texture2D({\n        width: roughnessLevels,\n        height: sampleSize,\n        type: Texture.FLOAT,\n        minFilter: Texture.NEAREST,\n        magFilter: Texture.NEAREST,\n        wrapS: Texture.CLAMP_TO_EDGE,\n        wrapT: Texture.CLAMP_TO_EDGE,\n        useMipmap: false\n    });\n    var pixels = new Float32Array(sampleSize * roughnessLevels * 4);\n    var tmp = [];\n\n    // function sortFunc(a, b) {\n    //     return Math.abs(b) - Math.abs(a);\n    // }\n    for (var j = 0; j < roughnessLevels; j++) {\n        var roughness = j / roughnessLevels;\n        var a = roughness * roughness;\n\n        for (var i = 0; i < sampleSize; i++) {\n            // http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\n            // http://stackoverflow.com/questions/1908492/unsigned-integer-in-javascript\n            // http://stackoverflow.com/questions/1822350/what-is-the-javascript-operator-and-how-do-you-use-it\n            var y = (i << 16 | i >>> 16) >>> 0;\n            y = ((y & 1431655765) << 1 | (y & 2863311530) >>> 1) >>> 0;\n            y = ((y & 858993459) << 2 | (y & 3435973836) >>> 2) >>> 0;\n            y = ((y & 252645135) << 4 | (y & 4042322160) >>> 4) >>> 0;\n            y = (((y & 16711935) << 8 | (y & 4278255360) >>> 8) >>> 0) / 4294967296;\n\n            // CDF\n            var cosTheta = Math.sqrt((1 - y) / (1 + (a * a - 1.0) * y));\n            tmp[i] = cosTheta;\n        }\n\n        for (var i = 0; i < sampleSize; i++) {\n            var offset = (i * roughnessLevels + j) * 4;\n            var cosTheta = tmp[i];\n            var sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);\n            var x = i / sampleSize;\n            var phi = 2.0 * Math.PI * x;\n            pixels[offset] = sinTheta * Math.cos(phi);\n            pixels[offset + 1] = cosTheta;\n            pixels[offset + 2] = sinTheta * Math.sin(phi);\n            pixels[offset + 3] = 1.0;\n        }\n    }\n    normalDistribution.pixels = pixels;\n\n    return normalDistribution;\n};\n\nexport default cubemapUtil;\n","// Spherical Harmonic Helpers\nimport Texture from '../Texture';\nimport FrameBuffer from '../FrameBuffer';\nimport Texture2D from '../Texture2D';\nimport Pass from '../compositor/Pass';\nimport vendor from '../core/vendor';\nimport Skybox from '../plugin/Skybox';\nimport Skydome from '../plugin/Skydome';\nimport EnvironmentMapPass from '../prePass/EnvironmentMap';\nimport Scene from '../Scene';\nimport vec3 from '../glmatrix/vec3';\nvar sh = {};\n\nimport projectEnvMapShaderCode from './shader/projectEnvMap.glsl.js';\n\nvar targets = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];\n\n// Project on gpu, but needs browser to support readPixels as Float32Array.\nfunction projectEnvironmentMapGPU(renderer, envMap) {\n    var shTexture = new Texture2D({\n        width: 9,\n        height: 1,\n        type: Texture.FLOAT\n    });\n    var pass = new Pass({\n        fragment: projectEnvMapShaderCode\n    });\n    pass.material.define('fragment', 'TEXTURE_SIZE', envMap.width);\n    pass.setUniform('environmentMap', envMap);\n\n    var framebuffer = new FrameBuffer();\n    framebuffer.attach(shTexture);\n    pass.render(renderer, framebuffer);\n\n    framebuffer.bind(renderer);\n    // TODO Only chrome and firefox support Float32Array\n    var pixels = new vendor.Float32Array(9 * 4);\n    renderer.gl.readPixels(0, 0, 9, 1, Texture.RGBA, Texture.FLOAT, pixels);\n\n    var coeff = new vendor.Float32Array(9 * 3);\n    for (var i = 0; i < 9; i++) {\n        coeff[i * 3] = pixels[i * 4];\n        coeff[i * 3 + 1] = pixels[i * 4 + 1];\n        coeff[i * 3 + 2] = pixels[i * 4 + 2];\n    }\n    framebuffer.unbind(renderer);\n\n    framebuffer.dispose(renderer);\n    pass.dispose(renderer);\n    return coeff;\n}\n\nfunction harmonics(normal, index){\n    var x = normal[0];\n    var y = normal[1];\n    var z = normal[2];\n\n    if (index === 0) {\n        return 1.0;\n    }\n    else if (index === 1) {\n        return x;\n    }\n    else if (index === 2) {\n        return y;\n    }\n    else if (index === 3) {\n        return z;\n    }\n    else if (index === 4) {\n        return x * z;\n    }\n    else if (index === 5) {\n        return y * z;\n    }\n    else if (index === 6) {\n        return x * y;\n    }\n    else if (index === 7) {\n        return 3.0 * z * z - 1.0;\n    }\n    else {\n        return x * x - y * y;\n    }\n}\n\nvar normalTransform = {\n    px: [2, 1, 0, -1, -1, 1],\n    nx: [2, 1, 0, 1, -1, -1],\n    py: [0, 2, 1, 1, -1, -1],\n    ny: [0, 2, 1, 1, 1, 1],\n    pz: [0, 1, 2, -1, -1, -1],\n    nz: [0, 1, 2, 1, -1, 1]\n};\n\n// Project on cpu.\nfunction projectEnvironmentMapCPU(renderer, cubePixels, width, height) {\n    var coeff = new vendor.Float32Array(9 * 3);\n    var normal = vec3.create();\n    var texel = vec3.create();\n    var fetchNormal = vec3.create();\n    for (var m = 0; m < 9; m++) {\n        var result = vec3.create();\n        for (var k = 0; k < targets.length; k++) {\n            var pixels = cubePixels[targets[k]];\n\n            var sideResult = vec3.create();\n            var divider = 0;\n            var i = 0;\n            var transform = normalTransform[targets[k]];\n            for (var y = 0; y < height; y++) {\n                for (var x = 0; x < width; x++) {\n\n                    normal[0] = x / (width - 1.0) * 2.0 - 1.0;\n                    // TODO Flip y?\n                    normal[1] = y / (height - 1.0) * 2.0 - 1.0;\n                    normal[2] = -1.0;\n                    vec3.normalize(normal, normal);\n\n                    fetchNormal[0] = normal[transform[0]] * transform[3];\n                    fetchNormal[1] = normal[transform[1]] * transform[4];\n                    fetchNormal[2] = normal[transform[2]] * transform[5];\n\n                    texel[0] = pixels[i++] / 255;\n                    texel[1] = pixels[i++] / 255;\n                    texel[2] = pixels[i++] / 255;\n                    // RGBM Decode\n                    var scale = pixels[i++] / 255 * 8.12;\n                    texel[0] *= scale;\n                    texel[1] *= scale;\n                    texel[2] *= scale;\n\n                    vec3.scaleAndAdd(sideResult, sideResult, texel, harmonics(fetchNormal, m) * -normal[2]);\n                    // -normal.z equals cos(theta) of Lambertian\n                    divider += -normal[2];\n                }\n            }\n            vec3.scaleAndAdd(result, result, sideResult, 1 / divider);\n        }\n\n        coeff[m * 3] = result[0] / 6.0;\n        coeff[m * 3 + 1] = result[1] / 6.0;\n        coeff[m * 3 + 2] = result[2] / 6.0;\n    }\n    return coeff;\n}\n\n/**\n * @param  {clay.Renderer} renderer\n * @param  {clay.Texture} envMap\n * @param  {Object} [textureOpts]\n * @param  {Object} [textureOpts.lod]\n * @param  {boolean} [textureOpts.decodeRGBM]\n */\nsh.projectEnvironmentMap = function (renderer, envMap, opts) {\n\n    // TODO sRGB\n\n    opts = opts || {};\n    opts.lod = opts.lod || 0;\n\n    var skybox;\n    var dummyScene = new Scene();\n    var size = 64;\n    if (envMap.textureType === 'texture2D') {\n        skybox = new Skydome({\n            scene: dummyScene,\n            environmentMap: envMap\n        });\n    }\n    else {\n        size = (envMap.image && envMap.image.px) ? envMap.image.px.width : envMap.width;\n        skybox = new Skybox({\n            scene: dummyScene,\n            environmentMap: envMap\n        });\n    }\n    // Convert to rgbm\n    var width = Math.ceil(size / Math.pow(2, opts.lod));\n    var height = Math.ceil(size / Math.pow(2, opts.lod));\n    var rgbmTexture = new Texture2D({\n        width: width,\n        height: height\n    });\n    var framebuffer = new FrameBuffer();\n    skybox.material.define('fragment', 'RGBM_ENCODE');\n    if (opts.decodeRGBM) {\n        skybox.material.define('fragment', 'RGBM_DECODE');\n    }\n    skybox.material.set('lod', opts.lod);\n    var envMapPass = new EnvironmentMapPass({\n        texture: rgbmTexture\n    });\n    var cubePixels = {};\n    for (var i = 0; i < targets.length; i++) {\n        cubePixels[targets[i]] = new Uint8Array(width * height * 4);\n        var camera = envMapPass.getCamera(targets[i]);\n        camera.fov = 90;\n        framebuffer.attach(rgbmTexture);\n        framebuffer.bind(renderer);\n        renderer.render(dummyScene, camera);\n        renderer.gl.readPixels(\n            0, 0, width, height,\n            Texture.RGBA, Texture.UNSIGNED_BYTE, cubePixels[targets[i]]\n        );\n        framebuffer.unbind(renderer);\n    }\n\n    skybox.dispose(renderer);\n    framebuffer.dispose(renderer);\n    rgbmTexture.dispose(renderer);\n\n    return projectEnvironmentMapCPU(renderer, cubePixels, width, height);\n};\n\nexport default sh;\n","import Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nimport TextureCube from '../TextureCube';\n\n// http://msdn.microsoft.com/en-us/library/windows/desktop/bb943991(v=vs.85).aspx\n// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\nvar DDS_MAGIC = 0x20534444;\n\nvar DDSD_CAPS = 0x1;\nvar DDSD_HEIGHT = 0x2;\nvar DDSD_WIDTH = 0x4;\nvar DDSD_PITCH = 0x8;\nvar DDSD_PIXELFORMAT = 0x1000;\nvar DDSD_MIPMAPCOUNT = 0x20000;\nvar DDSD_LINEARSIZE = 0x80000;\nvar DDSD_DEPTH = 0x800000;\n\nvar DDSCAPS_COMPLEX = 0x8;\nvar DDSCAPS_MIPMAP = 0x400000;\nvar DDSCAPS_TEXTURE = 0x1000;\n\nvar DDSCAPS2_CUBEMAP = 0x200;\nvar DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\nvar DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\nvar DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\nvar DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\nvar DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\nvar DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;\nvar DDSCAPS2_VOLUME = 0x200000;\n\nvar DDPF_ALPHAPIXELS = 0x1;\nvar DDPF_ALPHA = 0x2;\nvar DDPF_FOURCC = 0x4;\nvar DDPF_RGB = 0x40;\nvar DDPF_YUV = 0x200;\nvar DDPF_LUMINANCE = 0x20000;\n\nfunction fourCCToInt32(value) {\n    return value.charCodeAt(0) +\n        (value.charCodeAt(1) << 8) +\n        (value.charCodeAt(2) << 16) +\n        (value.charCodeAt(3) << 24);\n}\n\nfunction int32ToFourCC(value) {\n    return String.fromCharCode(\n        value & 0xff,\n        (value >> 8) & 0xff,\n        (value >> 16) & 0xff,\n        (value >> 24) & 0xff\n    );\n}\n\nvar headerLengthInt = 31; // The header length in 32 bit ints\n\nvar FOURCC_DXT1 = fourCCToInt32('DXT1');\nvar FOURCC_DXT3 = fourCCToInt32('DXT3');\nvar FOURCC_DXT5 = fourCCToInt32('DXT5');\n// Offsets into the header array\nvar off_magic = 0;\n\nvar off_size = 1;\nvar off_flags = 2;\nvar off_height = 3;\nvar off_width = 4;\n\nvar off_mipmapCount = 7;\n\nvar off_pfFlags = 20;\nvar off_pfFourCC = 21;\n\nvar off_caps = 27;\nvar off_caps2 = 28;\nvar off_caps3 = 29;\nvar off_caps4 = 30;\n\nvar ret = {\n    parse: function(arrayBuffer, out) {\n        var header = new Int32Array(arrayBuffer, 0, headerLengthInt);\n        if (header[off_magic] !== DDS_MAGIC) {\n            return null;\n        }\n        if (!header(off_pfFlags) & DDPF_FOURCC) {\n            return null;\n        }\n\n        var fourCC = header(off_pfFourCC);\n        var width = header[off_width];\n        var height = header[off_height];\n        var isCubeMap = header[off_caps2] & DDSCAPS2_CUBEMAP;\n        var hasMipmap = header[off_flags] & DDSD_MIPMAPCOUNT;\n        var blockBytes, internalFormat;\n        switch(fourCC) {\n            case FOURCC_DXT1:\n                blockBytes = 8;\n                internalFormat = Texture.COMPRESSED_RGB_S3TC_DXT1_EXT;\n                break;\n            case FOURCC_DXT3:\n                blockBytes = 16;\n                internalFormat = Texture.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n                break;\n            case FOURCC_DXT5:\n                blockBytes = 16;\n                internalFormat = Texture.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n                break;\n            default:\n                return null;\n        }\n        var dataOffset = header[off_size] + 4;\n        // TODO: Suppose all face are existed\n        var faceNumber = isCubeMap ? 6 : 1;\n        var mipmapCount = 1;\n        if (hasMipmap) {\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\n        }\n\n        var textures = [];\n        for (var f = 0; f < faceNumber; f++) {\n            var _width = width;\n            var _height = height;\n            textures[f] = new Texture2D({\n                width: _width,\n                height: _height,\n                format: internalFormat\n            });\n            var mipmaps = [];\n            for (var i = 0; i < mipmapCount; i++) {\n                var dataLength = Math.max(4, _width) / 4 * Math.max(4, _height) / 4 * blockBytes;\n                var byteArray = new Uint8Array(arrayBuffer, dataOffset, dataLength);\n\n                dataOffset += dataLength;\n                _width *= 0.5;\n                _height *= 0.5;\n                mipmaps[i] = byteArray;\n            }\n            textures[f].pixels = mipmaps[0];\n            if (hasMipmap) {\n                textures[f].mipmaps = mipmaps;\n            }\n        }\n        // TODO\n        // return isCubeMap ? textures : textures[0];\n        if (out) {\n            out.width = textures[0].width;\n            out.height = textures[0].height;\n            out.format = textures[0].format;\n            out.pixels = textures[0].pixels;\n            out.mipmaps = textures[0].mipmaps;\n        }\n        else {\n            return textures[0];\n        }\n    }\n};\n\nexport default ret;\n","import Texture from '../Texture';\nimport Texture2D from '../Texture2D';\nvar toChar = String.fromCharCode;\n\nvar MINELEN = 8;\nvar MAXELEN = 0x7fff;\nfunction rgbe2float(rgbe, buffer, offset, exposure) {\n    if (rgbe[3] > 0) {\n        var f = Math.pow(2.0, rgbe[3] - 128 - 8 + exposure);\n        buffer[offset + 0] = rgbe[0] * f;\n        buffer[offset + 1] = rgbe[1] * f;\n        buffer[offset + 2] = rgbe[2] * f;\n    }\n    else {\n        buffer[offset + 0] = 0;\n        buffer[offset + 1] = 0;\n        buffer[offset + 2] = 0;\n    }\n    buffer[offset + 3] = 1.0;\n    return buffer;\n}\n\nfunction uint82string(array, offset, size) {\n    var str = '';\n    for (var i = offset; i < size; i++) {\n        str += toChar(array[i]);\n    }\n    return str;\n}\n\nfunction copyrgbe(s, t) {\n    t[0] = s[0];\n    t[1] = s[1];\n    t[2] = s[2];\n    t[3] = s[3];\n}\n\n// TODO : check\nfunction oldReadColors(scan, buffer, offset, xmax) {\n    var rshift = 0, x = 0, len = xmax;\n    while (len > 0) {\n        scan[x][0] = buffer[offset++];\n        scan[x][1] = buffer[offset++];\n        scan[x][2] = buffer[offset++];\n        scan[x][3] = buffer[offset++];\n        if (scan[x][0] === 1 && scan[x][1] === 1 && scan[x][2] === 1) {\n            // exp is count of repeated pixels\n            for (var i = (scan[x][3] << rshift) >>> 0; i > 0; i--) {\n                copyrgbe(scan[x-1], scan[x]);\n                x++;\n                len--;\n            }\n            rshift += 8;\n        } else {\n            x++;\n            len--;\n            rshift = 0;\n        }\n    }\n    return offset;\n}\n\nfunction readColors(scan, buffer, offset, xmax) {\n    if ((xmax < MINELEN) | (xmax > MAXELEN)) {\n        return oldReadColors(scan, buffer, offset, xmax);\n    }\n    var i = buffer[offset++];\n    if (i != 2) {\n        return oldReadColors(scan, buffer, offset - 1, xmax);\n    }\n    scan[0][1] = buffer[offset++];\n    scan[0][2] = buffer[offset++];\n\n    i = buffer[offset++];\n    if ((((scan[0][2] << 8) >>> 0) | i) >>> 0 !== xmax) {\n        return null;\n    }\n    for (var i = 0; i < 4; i++) {\n        for (var x = 0; x < xmax;) {\n            var code = buffer[offset++];\n            if (code > 128) {\n                code = (code & 127) >>> 0;\n                var val = buffer[offset++];\n                while (code--) {\n                    scan[x++][i] = val;\n                }\n            } else {\n                while (code--) {\n                    scan[x++][i] = buffer[offset++];\n                }\n            }\n        }\n    }\n    return offset;\n}\n\n\nvar ret = {\n    // http://www.graphics.cornell.edu/~bjw/rgbe.html\n    // Blender source\n    // http://radsite.lbl.gov/radiance/refer/Notes/picture_format.html\n    parseRGBE: function(arrayBuffer, texture, exposure) {\n        if (exposure == null) {\n            exposure = 0;\n        }\n        var data = new Uint8Array(arrayBuffer);\n        var size = data.length;\n        if (uint82string(data, 0, 2) !== '#?') {\n            return;\n        }\n        // find empty line, next line is resolution info\n        for (var i = 2; i < size; i++) {\n            if (toChar(data[i]) === '\\n' && toChar(data[i+1]) === '\\n') {\n                break;\n            }\n        }\n        if (i >= size) { // not found\n            return;\n        }\n        // find resolution info line\n        i += 2;\n        var str = '';\n        for (; i < size; i++) {\n            var _char = toChar(data[i]);\n            if (_char === '\\n') {\n                break;\n            }\n            str += _char;\n        }\n        // -Y M +X N\n        var tmp = str.split(' ');\n        var height = parseInt(tmp[1]);\n        var width = parseInt(tmp[3]);\n        if (!width || !height) {\n            return;\n        }\n\n        // read and decode actual data\n        var offset = i+1;\n        var scanline = [];\n        // memzero\n        for (var x = 0; x < width; x++) {\n            scanline[x] = [];\n            for (var j = 0; j < 4; j++) {\n                scanline[x][j] = 0;\n            }\n        }\n        var pixels = new Float32Array(width * height * 4);\n        var offset2 = 0;\n        for (var y = 0; y < height; y++) {\n            var offset = readColors(scanline, data, offset, width);\n            if (!offset) {\n                return null;\n            }\n            for (var x = 0; x < width; x++) {\n                rgbe2float(scanline[x], pixels, offset2, exposure);\n                offset2 += 4;\n            }\n        }\n\n        if (!texture) {\n            texture = new Texture2D();\n        }\n        texture.width = width;\n        texture.height = height;\n        texture.pixels = pixels;\n        // HALF_FLOAT can't use Float32Array\n        texture.type = Texture.FLOAT;\n        return texture;\n    },\n\n    parseRGBEFromPNG: function(png) {\n\n    }\n};\n\nexport default ret;\n","import Texture2D from '../Texture2D';\nimport TextureCube from '../TextureCube';\nimport vendor from '../core/vendor';\nimport EnvironmentMapPass from '../prePass/EnvironmentMap';\nimport Skydome from '../plugin/Skydome';\nimport Scene from '../Scene';\n\nimport dds from './dds';\nimport hdr from './hdr';\n\n/**\n * @alias clay.util.texture\n */\nvar textureUtil = {\n    /**\n     * @param  {string|object} path\n     * @param  {object} [option]\n     * @param  {Function} [onsuccess]\n     * @param  {Function} [onerror]\n     * @return {clay.Texture}\n     */\n    loadTexture: function (path, option, onsuccess, onerror) {\n        var texture;\n        if (typeof(option) === 'function') {\n            onsuccess = option;\n            onerror = onsuccess;\n            option = {};\n        }\n        else {\n            option = option || {};\n        }\n        if (typeof(path) === 'string') {\n            if (path.match(/.hdr$/) || option.fileType === 'hdr') {\n                texture = new Texture2D({\n                    width: 0,\n                    height: 0,\n                    sRGB: false\n                });\n                textureUtil._fetchTexture(\n                    path,\n                    function (data) {\n                        hdr.parseRGBE(data, texture, option.exposure);\n                        texture.dirty();\n                        onsuccess && onsuccess(texture);\n                    },\n                    onerror\n                );\n                return texture;\n            }\n            else if (path.match(/.dds$/) || option.fileType === 'dds') {\n                texture = new Texture2D({\n                    width: 0,\n                    height: 0\n                });\n                textureUtil._fetchTexture(\n                    path,\n                    function (data) {\n                        dds.parse(data, texture);\n                        texture.dirty();\n                        onsuccess && onsuccess(texture);\n                    },\n                    onerror\n                );\n            }\n            else {\n                texture = new Texture2D();\n                texture.load(path);\n                texture.success(onsuccess);\n                texture.error(onerror);\n            }\n        }\n        else if (typeof path === 'object' && typeof(path.px) !== 'undefined') {\n            texture = new TextureCube();\n            texture.load(path);\n            texture.success(onsuccess);\n            texture.error(onerror);\n        }\n        return texture;\n    },\n\n    /**\n     * Load a panorama texture and render it to a cube map\n     * @param  {clay.Renderer} renderer\n     * @param  {string} path\n     * @param  {clay.TextureCube} cubeMap\n     * @param  {object} [option]\n     * @param  {boolean} [option.encodeRGBM]\n     * @param  {number} [option.exposure]\n     * @param  {Function} [onsuccess]\n     * @param  {Function} [onerror]\n     */\n    loadPanorama: function (renderer, path, cubeMap, option, onsuccess, onerror) {\n        var self = this;\n\n        if (typeof(option) === 'function') {\n            onsuccess = option;\n            onerror = onsuccess;\n            option = {};\n        }\n        else {\n            option = option || {};\n        }\n\n        textureUtil.loadTexture(path, option, function (texture) {\n            // PENDING\n            texture.flipY = option.flipY || false;\n            self.panoramaToCubeMap(renderer, texture, cubeMap, option);\n            texture.dispose(renderer);\n            onsuccess && onsuccess(cubeMap);\n        }, onerror);\n    },\n\n    /**\n     * Render a panorama texture to a cube map\n     * @param  {clay.Renderer} renderer\n     * @param  {clay.Texture2D} panoramaMap\n     * @param  {clay.TextureCube} cubeMap\n     * @param  {Object} option\n     * @param  {boolean} [option.encodeRGBM]\n     */\n    panoramaToCubeMap: function (renderer, panoramaMap, cubeMap, option) {\n        var environmentMapPass = new EnvironmentMapPass();\n        var skydome = new Skydome({\n            scene: new Scene()\n        });\n        skydome.setEnvironmentMap(panoramaMap);\n\n        option = option || {};\n        if (option.encodeRGBM) {\n            skydome.material.define('fragment', 'RGBM_ENCODE');\n        }\n\n        // Share sRGB\n        cubeMap.sRGB = panoramaMap.sRGB;\n\n        environmentMapPass.texture = cubeMap;\n        environmentMapPass.render(renderer, skydome.scene);\n        environmentMapPass.texture = null;\n        environmentMapPass.dispose(renderer);\n        return cubeMap;\n    },\n\n    /**\n     * Convert height map to normal map\n     * @param {HTMLImageElement|HTMLCanvasElement} image\n     * @param {boolean} [checkBump=false]\n     * @return {HTMLCanvasElement}\n     */\n    heightToNormal: function (image, checkBump) {\n        var canvas = document.createElement('canvas');\n        var width = canvas.width = image.width;\n        var height = canvas.height = image.height;\n        var ctx = canvas.getContext('2d');\n        ctx.drawImage(image, 0, 0, width, height);\n        checkBump = checkBump || false;\n        var srcData = ctx.getImageData(0, 0, width, height);\n        var dstData = ctx.createImageData(width, height);\n        for (var i = 0; i < srcData.data.length; i += 4) {\n            if (checkBump) {\n                var r = srcData.data[i];\n                var g = srcData.data[i + 1];\n                var b = srcData.data[i + 2];\n                var diff = Math.abs(r - g) + Math.abs(g - b);\n                if (diff > 20) {\n                    console.warn('Given image is not a height map');\n                    return image;\n                }\n            }\n            // Modified from http://mrdoob.com/lab/javascript/height2normal/\n            var x1, y1, x2, y2;\n            if (i % (width * 4) === 0) {\n                // left edge\n                x1 = srcData.data[i];\n                x2 = srcData.data[i + 4];\n            }\n            else if (i % (width * 4) === (width - 1) * 4) {\n                // right edge\n                x1 = srcData.data[i - 4];\n                x2 = srcData.data[i];\n            }\n            else {\n                x1 = srcData.data[i - 4];\n                x2 = srcData.data[i + 4];\n            }\n\n            if (i < width * 4) {\n                // top edge\n                y1 = srcData.data[i];\n                y2 = srcData.data[i + width * 4];\n            }\n            else if (i > width * (height - 1) * 4) {\n                // bottom edge\n                y1 = srcData.data[i - width * 4];\n                y2 = srcData.data[i];\n            }\n            else {\n                y1 = srcData.data[i - width * 4];\n                y2 = srcData.data[i + width * 4];\n            }\n\n            dstData.data[i] = (x1 - x2) + 127;\n            dstData.data[i + 1] = (y1 - y2) + 127;\n            dstData.data[i + 2] = 255;\n            dstData.data[i + 3] = 255;\n        }\n        ctx.putImageData(dstData, 0, 0);\n        return canvas;\n    },\n\n    /**\n     * Convert height map to normal map\n     * @param {HTMLImageElement|HTMLCanvasElement} image\n     * @param {boolean} [checkBump=false]\n     * @param {number} [threshold=20]\n     * @return {HTMLCanvasElement}\n     */\n    isHeightImage: function (img, downScaleSize, threshold) {\n        if (!img || !img.width || !img.height) {\n            return false;\n        }\n\n        var canvas = document.createElement('canvas');\n        var ctx = canvas.getContext('2d');\n        var size = downScaleSize || 32;\n        threshold = threshold || 20;\n        canvas.width = canvas.height = size;\n        ctx.drawImage(img, 0, 0, size, size);\n        var srcData = ctx.getImageData(0, 0, size, size);\n        for (var i = 0; i < srcData.data.length; i += 4) {\n            var r = srcData.data[i];\n            var g = srcData.data[i + 1];\n            var b = srcData.data[i + 2];\n            var diff = Math.abs(r - g) + Math.abs(g - b);\n            if (diff > threshold) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    _fetchTexture: function (path, onsuccess, onerror) {\n        vendor.request.get({\n            url: path,\n            responseType: 'arraybuffer',\n            onload: onsuccess,\n            onerror: onerror\n        });\n    },\n\n    /**\n     * Create a chessboard texture\n     * @param  {number} [size]\n     * @param  {number} [unitSize]\n     * @param  {string} [color1]\n     * @param  {string} [color2]\n     * @return {clay.Texture2D}\n     */\n    createChessboard: function (size, unitSize, color1, color2) {\n        size = size || 512;\n        unitSize = unitSize || 64;\n        color1 = color1 || 'black';\n        color2 = color2 || 'white';\n\n        var repeat = Math.ceil(size / unitSize);\n\n        var canvas = document.createElement('canvas');\n        canvas.width = size;\n        canvas.height = size;\n        var ctx = canvas.getContext('2d');\n        ctx.fillStyle = color2;\n        ctx.fillRect(0, 0, size, size);\n\n        ctx.fillStyle = color1;\n        for (var i = 0; i < repeat; i++) {\n            for (var j = 0; j < repeat; j++) {\n                var isFill = j % 2 ? (i % 2) : (i % 2 - 1);\n                if (isFill) {\n                    ctx.fillRect(i * unitSize, j * unitSize, unitSize, unitSize);\n                }\n            }\n        }\n\n        var texture = new Texture2D({\n            image: canvas,\n            anisotropic: 8\n        });\n\n        return texture;\n    },\n\n    /**\n     * Create a blank pure color 1x1 texture\n     * @param  {string} color\n     * @return {clay.Texture2D}\n     */\n    createBlank: function (color) {\n        var canvas = document.createElement('canvas');\n        canvas.width = 1;\n        canvas.height = 1;\n        var ctx = canvas.getContext('2d');\n        ctx.fillStyle = color;\n        ctx.fillRect(0, 0, 1, 1);\n\n        var texture = new Texture2D({\n            image: canvas\n        });\n\n        return texture;\n    }\n};\n\nexport default textureUtil;\n"],"names":["cubemapUtil","targets","prefilterEnvironmentMap","renderer","envMap","textureOpts","normalDistribution","brdfLookup","generateNormalDistribution","integrateBRDF","width","height","textureType","type","prefilteredCubeMap","TextureCube","flipY","mipmaps","isPowerOfTwo","console","warn","size","Math","min","mipmapNum","log","prefilterMaterial","Material","shader","Shader","vertex","source","fragment","prefilterFragCode","set","encodeRGBM","define","decodeRGBM","skyEnv","dummyScene","Scene","envCubemap","Texture","FLOAT","HALF_FLOAT","textureUtil","panoramaToCubeMap","Skybox","scene","material","envMapPass","EnvironmentMapPass","texture","UNSIGNED_BYTE","renderTargetTmp","Texture2D","frameBuffer","FrameBuffer","depthBuffer","ArrayCtor","vendor","i","pixels","n","fov","atan","PI","j","length","attach","bind","camera","getCamera","render","gl","readPixels","RGBA","unbind","dirty","dispose","environmentMap","maxMipmapLevel","framebuffer","pass","Pass","integrateBRDFShaderCode","wrapS","CLAMP_TO_EDGE","wrapT","minFilter","NEAREST","magFilter","useMipmap","setUniform","attachOutput","roughnessLevels","sampleSize","Float32Array","tmp","roughness","a","y","cosTheta","sqrt","offset","sinTheta","x","phi","cos","sin","sh","harmonics","normal","index","z","normalTransform","px","nx","py","ny","pz","nz","projectEnvironmentMapCPU","cubePixels","coeff","vec3","create","texel","fetchNormal","m","result","k","sideResult","divider","transform","normalize","scale","scaleAndAdd","projectEnvironmentMap","opts","skybox","lod","Skydome","image","ceil","pow","rgbmTexture","Uint8Array","DDS_MAGIC","DDSD_MIPMAPCOUNT","DDSCAPS2_CUBEMAP","DDPF_FOURCC","fourCCToInt32","value","charCodeAt","headerLengthInt","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","off_magic","off_size","off_flags","off_height","off_width","off_mipmapCount","off_pfFlags","off_pfFourCC","off_caps2","ret","parse","arrayBuffer","out","header","Int32Array","blockBytes","internalFormat","fourCC","isCubeMap","hasMipmap","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","dataOffset","faceNumber","mipmapCount","max","textures","f","_width","_height","format","dataLength","byteArray","toChar","String","fromCharCode","MINELEN","MAXELEN","rgbe2float","rgbe","buffer","exposure","uint82string","array","str","copyrgbe","s","t","oldReadColors","scan","xmax","rshift","len","readColors","code","val","parseRGBE","data","_char","split","parseInt","scanline","offset2","parseRGBEFromPNG","png","loadTexture","path","option","onsuccess","onerror","match","fileType","sRGB","_fetchTexture","hdr","dds","load","success","error","loadPanorama","cubeMap","self","this","panoramaMap","environmentMapPass","skydome","setEnvironmentMap","heightToNormal","checkBump","canvas","document","createElement","ctx","getContext","drawImage","srcData","getImageData","dstData","createImageData","r","g","b","diff","abs","x1","y1","x2","y2","putImageData","isHeightImage","img","downScaleSize","threshold","request","get","url","responseType","onload","createChessboard","unitSize","color1","color2","repeat","fillStyle","fillRect","isFill","anisotropic","createBlank","color"],"sourceRoot":""}