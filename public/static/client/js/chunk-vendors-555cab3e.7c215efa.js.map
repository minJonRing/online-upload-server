{"version":3,"file":"static/client/js/chunk-vendors-555cab3e.7c215efa.js","mappings":"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","sources":["webpack://d1/./node_modules/claygl/src/Camera.js","webpack://d1/./node_modules/claygl/src/FrameBuffer.js","webpack://d1/./node_modules/claygl/src/GeometryBase.js","webpack://d1/./node_modules/claygl/src/Geometry.js","webpack://d1/./node_modules/claygl/src/Light.js","webpack://d1/./node_modules/claygl/src/Material.js","webpack://d1/./node_modules/claygl/src/Mesh.js","webpack://d1/./node_modules/claygl/src/Node.js"],"sourcesContent":["import Node from './Node';\nimport Matrix4 from './math/Matrix4';\nimport Frustum from './math/Frustum';\nimport Ray from './math/Ray';\n\nimport vec4 from './glmatrix/vec4';\nimport vec3 from './glmatrix/vec3';\n\n\n/**\n * @constructor clay.Camera\n * @extends clay.Node\n */\nvar Camera = Node.extend(function () {\n    return /** @lends clay.Camera# */ {\n        /**\n         * Camera projection matrix\n         * @type {clay.Matrix4}\n         */\n        projectionMatrix: new Matrix4(),\n\n        /**\n         * Inverse of camera projection matrix\n         * @type {clay.Matrix4}\n         */\n        invProjectionMatrix: new Matrix4(),\n\n        /**\n         * View matrix, equal to inverse of camera's world matrix\n         * @type {clay.Matrix4}\n         */\n        viewMatrix: new Matrix4(),\n\n        /**\n         * Camera frustum in view space\n         * @type {clay.Frustum}\n         */\n        frustum: new Frustum()\n    };\n}, function () {\n    this.update(true);\n},\n/** @lends clay.Camera.prototype */\n{\n\n    update: function (force) {\n        Node.prototype.update.call(this, force);\n        Matrix4.invert(this.viewMatrix, this.worldTransform);\n\n        this.updateProjectionMatrix();\n        Matrix4.invert(this.invProjectionMatrix, this.projectionMatrix);\n\n        this.frustum.setFromProjection(this.projectionMatrix);\n    },\n\n    /**\n     * Set camera view matrix\n     */\n    setViewMatrix: function (viewMatrix) {\n        Matrix4.copy(this.viewMatrix, viewMatrix);\n        Matrix4.invert(this.worldTransform, viewMatrix);\n        this.decomposeWorldTransform();\n    },\n\n    /**\n     * Decompose camera projection matrix\n     */\n    decomposeProjectionMatrix: function () {},\n\n    /**\n     * Set camera projection matrix\n     * @param {clay.Matrix4} projectionMatrix\n     */\n    setProjectionMatrix: function (projectionMatrix) {\n        Matrix4.copy(this.projectionMatrix, projectionMatrix);\n        Matrix4.invert(this.invProjectionMatrix, projectionMatrix);\n        this.decomposeProjectionMatrix();\n    },\n    /**\n     * Update projection matrix, called after update\n     */\n    updateProjectionMatrix: function () {},\n\n    /**\n     * Cast a picking ray from camera near plane to far plane\n     * @function\n     * @param {clay.Vector2} ndc\n     * @param {clay.Ray} [out]\n     * @return {clay.Ray}\n     */\n    castRay: (function () {\n        var v4 = vec4.create();\n        return function (ndc, out) {\n            var ray = out !== undefined ? out : new Ray();\n            var x = ndc.array[0];\n            var y = ndc.array[1];\n            vec4.set(v4, x, y, -1, 1);\n            vec4.transformMat4(v4, v4, this.invProjectionMatrix.array);\n            vec4.transformMat4(v4, v4, this.worldTransform.array);\n            vec3.scale(ray.origin.array, v4, 1 / v4[3]);\n\n            vec4.set(v4, x, y, 1, 1);\n            vec4.transformMat4(v4, v4, this.invProjectionMatrix.array);\n            vec4.transformMat4(v4, v4, this.worldTransform.array);\n            vec3.scale(v4, v4, 1 / v4[3]);\n            vec3.sub(ray.direction.array, v4, ray.origin.array);\n\n            vec3.normalize(ray.direction.array, ray.direction.array);\n            ray.direction._dirty = true;\n            ray.origin._dirty = true;\n\n            return ray;\n        };\n    })(),\n\n    /**\n     * @function\n     * @name clone\n     * @return {clay.Camera}\n     * @memberOf clay.Camera.prototype\n     */\n});\n\nexport default Camera;\n","import Base from './core/Base';\nimport Texture from './Texture';\nimport TextureCube from './TextureCube';\nimport glenum from './core/glenum';\nimport Cache from './core/Cache';\n\nvar KEY_FRAMEBUFFER = 'framebuffer';\nvar KEY_RENDERBUFFER = 'renderbuffer';\nvar KEY_RENDERBUFFER_WIDTH = KEY_RENDERBUFFER + '_width';\nvar KEY_RENDERBUFFER_HEIGHT = KEY_RENDERBUFFER + '_height';\nvar KEY_RENDERBUFFER_ATTACHED = KEY_RENDERBUFFER + '_attached';\nvar KEY_DEPTHTEXTURE_ATTACHED = 'depthtexture_attached';\n\nvar GL_FRAMEBUFFER = glenum.FRAMEBUFFER;\nvar GL_RENDERBUFFER = glenum.RENDERBUFFER;\nvar GL_DEPTH_ATTACHMENT = glenum.DEPTH_ATTACHMENT;\nvar GL_COLOR_ATTACHMENT0 = glenum.COLOR_ATTACHMENT0;\n/**\n * @constructor clay.FrameBuffer\n * @extends clay.core.Base\n */\nvar FrameBuffer = Base.extend(\n/** @lends clay.FrameBuffer# */\n{\n    /**\n     * If use depth buffer\n     * @type {boolean}\n     */\n    depthBuffer: true,\n\n    /**\n     * @type {Object}\n     */\n    viewport: null,\n\n    _width: 0,\n    _height: 0,\n\n    _textures: null,\n\n    _boundRenderer: null,\n}, function () {\n    // Use cache\n    this._cache = new Cache();\n\n    this._textures = {};\n},\n\n/**@lends clay.FrameBuffer.prototype. */\n{\n    /**\n     * Get attached texture width\n     * {number}\n     */\n    // FIXME Can't use before #bind\n    getTextureWidth: function () {\n        return this._width;\n    },\n\n    /**\n     * Get attached texture height\n     * {number}\n     */\n    getTextureHeight: function () {\n        return this._height;\n    },\n\n    /**\n     * Bind the framebuffer to given renderer before rendering\n     * @param  {clay.Renderer} renderer\n     */\n    bind: function (renderer) {\n\n        if (renderer.__currentFrameBuffer) {\n            // Already bound\n            if (renderer.__currentFrameBuffer === this) {\n                return;\n            }\n\n            console.warn('Renderer already bound with another framebuffer. Unbind it first');\n        }\n        renderer.__currentFrameBuffer = this;\n\n        var _gl = renderer.gl;\n\n        _gl.bindFramebuffer(GL_FRAMEBUFFER, this._getFrameBufferGL(renderer));\n        this._boundRenderer = renderer;\n        var cache = this._cache;\n\n        cache.put('viewport', renderer.viewport);\n\n        var hasTextureAttached = false;\n        var width;\n        var height;\n        for (var attachment in this._textures) {\n            hasTextureAttached = true;\n            var obj = this._textures[attachment];\n            if (obj) {\n                // TODO Do width, height checking, make sure size are same\n                width = obj.texture.width;\n                height = obj.texture.height;\n                // Attach textures\n                this._doAttach(renderer, obj.texture, attachment, obj.target);\n            }\n        }\n\n        this._width = width;\n        this._height = height;\n\n        if (!hasTextureAttached && this.depthBuffer) {\n            console.error('Must attach texture before bind, or renderbuffer may have incorrect width and height.')\n        }\n\n        if (this.viewport) {\n            renderer.setViewport(this.viewport);\n        }\n        else {\n            renderer.setViewport(0, 0, width, height, 1);\n        }\n\n        var attachedTextures = cache.get('attached_textures');\n        if (attachedTextures) {\n            for (var attachment in attachedTextures) {\n                if (!this._textures[attachment]) {\n                    var target = attachedTextures[attachment];\n                    this._doDetach(_gl, attachment, target);\n                }\n            }\n        }\n        if (!cache.get(KEY_DEPTHTEXTURE_ATTACHED) && this.depthBuffer) {\n            // Create a new render buffer\n            if (cache.miss(KEY_RENDERBUFFER)) {\n                cache.put(KEY_RENDERBUFFER, _gl.createRenderbuffer());\n            }\n            var renderbuffer = cache.get(KEY_RENDERBUFFER);\n\n            if (width !== cache.get(KEY_RENDERBUFFER_WIDTH)\n                    || height !== cache.get(KEY_RENDERBUFFER_HEIGHT)) {\n                _gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer);\n                _gl.renderbufferStorage(GL_RENDERBUFFER, _gl.DEPTH_COMPONENT16, width, height);\n                cache.put(KEY_RENDERBUFFER_WIDTH, width);\n                cache.put(KEY_RENDERBUFFER_HEIGHT, height);\n                _gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n            }\n            if (!cache.get(KEY_RENDERBUFFER_ATTACHED)) {\n                _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, renderbuffer);\n                cache.put(KEY_RENDERBUFFER_ATTACHED, true);\n            }\n        }\n    },\n\n    /**\n     * Unbind the frame buffer after rendering\n     * @param  {clay.Renderer} renderer\n     */\n    unbind: function (renderer) {\n        // Remove status record on renderer\n        renderer.__currentFrameBuffer = null;\n\n        var _gl = renderer.gl;\n\n        _gl.bindFramebuffer(GL_FRAMEBUFFER, null);\n        this._boundRenderer = null;\n\n        this._cache.use(renderer.__uid__);\n        var viewport = this._cache.get('viewport');\n        // Reset viewport;\n        if (viewport) {\n            renderer.setViewport(viewport);\n        }\n\n        this.updateMipmap(renderer);\n    },\n\n    // Because the data of texture is changed over time,\n    // Here update the mipmaps of texture each time after rendered;\n    updateMipmap: function (renderer) {\n        var _gl = renderer.gl;\n        for (var attachment in this._textures) {\n            var obj = this._textures[attachment];\n            if (obj) {\n                var texture = obj.texture;\n                // FIXME some texture format can't generate mipmap\n                if (!texture.NPOT && texture.useMipmap\n                    && texture.minFilter === Texture.LINEAR_MIPMAP_LINEAR) {\n                    var target = texture.textureType === 'textureCube' ? glenum.TEXTURE_CUBE_MAP : glenum.TEXTURE_2D;\n                    _gl.bindTexture(target, texture.getWebGLTexture(renderer));\n                    _gl.generateMipmap(target);\n                    _gl.bindTexture(target, null);\n                }\n            }\n        }\n    },\n\n\n    // 0x8CD5, 36053, FRAMEBUFFER_COMPLETE\n    // 0x8CD6, 36054, FRAMEBUFFER_INCOMPLETE_ATTACHMENT\n    // 0x8CD7, 36055, FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\n    // 0x8CD9, 36057, FRAMEBUFFER_INCOMPLETE_DIMENSIONS\n    // 0x8CDD, 36061, FRAMEBUFFER_UNSUPPORTED\n    checkStatus: function (_gl) {\n        return _gl.checkFramebufferStatus(GL_FRAMEBUFFER);\n    },\n\n    _getFrameBufferGL: function (renderer) {\n        var cache = this._cache;\n        cache.use(renderer.__uid__);\n\n        if (cache.miss(KEY_FRAMEBUFFER)) {\n            cache.put(KEY_FRAMEBUFFER, renderer.gl.createFramebuffer());\n        }\n\n        return cache.get(KEY_FRAMEBUFFER);\n    },\n\n    /**\n     * Attach a texture(RTT) to the framebuffer\n     * @param  {clay.Texture} texture\n     * @param  {number} [attachment=gl.COLOR_ATTACHMENT0]\n     * @param  {number} [target=gl.TEXTURE_2D]\n     */\n    attach: function (texture, attachment, target) {\n\n        if (!texture.width) {\n            throw new Error('The texture attached to color buffer is not a valid.');\n        }\n        // TODO width and height check\n\n        // If the depth_texture extension is enabled, developers\n        // Can attach a depth texture to the depth buffer\n        // http://blog.tojicode.com/2012/07/using-webgldepthtexture.html\n        attachment = attachment || GL_COLOR_ATTACHMENT0;\n        target = target || glenum.TEXTURE_2D;\n\n        var boundRenderer = this._boundRenderer;\n        var _gl = boundRenderer && boundRenderer.gl;\n        var attachedTextures;\n\n        if (_gl) {\n            var cache = this._cache;\n            cache.use(boundRenderer.__uid__);\n            attachedTextures = cache.get('attached_textures');\n        }\n\n        // Check if texture attached\n        var previous = this._textures[attachment];\n        if (previous && previous.target === target\n            && previous.texture === texture\n            && (attachedTextures && attachedTextures[attachment] != null)\n        ) {\n            return;\n        }\n\n        var canAttach = true;\n        if (boundRenderer) {\n            canAttach = this._doAttach(boundRenderer, texture, attachment, target);\n            // Set viewport again incase attached to different size textures.\n            if (!this.viewport) {\n                boundRenderer.setViewport(0, 0, texture.width, texture.height, 1);\n            }\n        }\n\n        if (canAttach) {\n            this._textures[attachment] = this._textures[attachment] || {};\n            this._textures[attachment].texture = texture;\n            this._textures[attachment].target = target;\n        }\n    },\n\n    _doAttach: function (renderer, texture, attachment, target) {\n        var _gl = renderer.gl;\n        // Make sure texture is always updated\n        // Because texture width or height may be changed and in this we can't be notified\n        // FIXME awkward;\n        var webglTexture = texture.getWebGLTexture(renderer);\n        // Assume cache has been used.\n        var attachedTextures = this._cache.get('attached_textures');\n        if (attachedTextures && attachedTextures[attachment]) {\n            var obj = attachedTextures[attachment];\n            // Check if texture and target not changed\n            if (obj.texture === texture && obj.target === target) {\n                return;\n            }\n        }\n        attachment = +attachment;\n\n        var canAttach = true;\n        if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {\n            var extension = renderer.getGLExtension('WEBGL_depth_texture');\n\n            if (!extension) {\n                console.error('Depth texture is not supported by the browser');\n                canAttach = false;\n            }\n            if (texture.format !== glenum.DEPTH_COMPONENT\n                && texture.format !== glenum.DEPTH_STENCIL\n            ) {\n                console.error('The texture attached to depth buffer is not a valid.');\n                canAttach = false;\n            }\n\n            // Dispose render buffer created previous\n            if (canAttach) {\n                var renderbuffer = this._cache.get(KEY_RENDERBUFFER);\n                if (renderbuffer) {\n                    _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, null);\n                    _gl.deleteRenderbuffer(renderbuffer);\n                    this._cache.put(KEY_RENDERBUFFER, false);\n                }\n\n                this._cache.put(KEY_RENDERBUFFER_ATTACHED, false);\n                this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, true);\n            }\n        }\n\n        // Mipmap level can only be 0\n        _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, webglTexture, 0);\n\n        if (!attachedTextures) {\n            attachedTextures = {};\n            this._cache.put('attached_textures', attachedTextures);\n        }\n        attachedTextures[attachment] = attachedTextures[attachment] || {};\n        attachedTextures[attachment].texture = texture;\n        attachedTextures[attachment].target = target;\n\n        return canAttach;\n    },\n\n    _doDetach: function (_gl, attachment, target) {\n        // Detach a texture from framebuffer\n        // https://github.com/KhronosGroup/WebGL/blob/master/conformance-suites/1.0.0/conformance/framebuffer-test.html#L145\n        _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, null, 0);\n\n        // Assume cache has been used.\n        var attachedTextures = this._cache.get('attached_textures');\n        if (attachedTextures && attachedTextures[attachment]) {\n            attachedTextures[attachment] = null;\n        }\n\n        if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {\n            this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, false);\n        }\n    },\n\n    /**\n     * Detach a texture\n     * @param  {number} [attachment=gl.COLOR_ATTACHMENT0]\n     * @param  {number} [target=gl.TEXTURE_2D]\n     */\n    detach: function (attachment, target) {\n        // TODO depth extension check ?\n        this._textures[attachment] = null;\n        if (this._boundRenderer) {\n            var cache = this._cache;\n            cache.use(this._boundRenderer.__uid__);\n            this._doDetach(this._boundRenderer.gl, attachment, target);\n        }\n    },\n    /**\n     * Dispose\n     * @param  {WebGLRenderingContext} _gl\n     */\n    dispose: function (renderer) {\n\n        var _gl = renderer.gl;\n        var cache = this._cache;\n\n        cache.use(renderer.__uid__);\n\n        var renderBuffer = cache.get(KEY_RENDERBUFFER);\n        if (renderBuffer) {\n            _gl.deleteRenderbuffer(renderBuffer);\n        }\n        var frameBuffer = cache.get(KEY_FRAMEBUFFER);\n        if (frameBuffer) {\n            _gl.deleteFramebuffer(frameBuffer);\n        }\n        cache.deleteContext(renderer.__uid__);\n\n        // Clear cache for reusing\n        this._textures = {};\n\n    }\n});\n\nFrameBuffer.DEPTH_ATTACHMENT = GL_DEPTH_ATTACHMENT;\nFrameBuffer.COLOR_ATTACHMENT0 = GL_COLOR_ATTACHMENT0;\nFrameBuffer.STENCIL_ATTACHMENT = glenum.STENCIL_ATTACHMENT;\nFrameBuffer.DEPTH_STENCIL_ATTACHMENT = glenum.DEPTH_STENCIL_ATTACHMENT;\n\nexport default FrameBuffer;\n","import Base from './core/Base';\nimport glenum from './core/glenum';\nimport Cache from './core/Cache';\nimport vendor from './core/vendor';\n\nfunction getArrayCtorByType (type) {\n    return ({\n        'byte': vendor.Int8Array,\n        'ubyte': vendor.Uint8Array,\n        'short': vendor.Int16Array,\n        'ushort': vendor.Uint16Array\n    })[type] || vendor.Float32Array;\n}\n\nfunction makeAttrKey(attrName) {\n    return 'attr_' + attrName;\n}\n/**\n * GeometryBase attribute\n * @alias clay.GeometryBase.Attribute\n * @constructor\n */\nfunction Attribute(name, type, size, semantic) {\n    /**\n     * Attribute name\n     * @type {string}\n     */\n    this.name = name;\n    /**\n     * Attribute type\n     * Possible values:\n     *  + `'byte'`\n     *  + `'ubyte'`\n     *  + `'short'`\n     *  + `'ushort'`\n     *  + `'float'` Most commonly used.\n     * @type {string}\n     */\n    this.type = type;\n    /**\n     * Size of attribute component. 1 - 4.\n     * @type {number}\n     */\n    this.size = size;\n    /**\n     * Semantic of this attribute.\n     * Possible values:\n     *  + `'POSITION'`\n     *  + `'NORMAL'`\n     *  + `'BINORMAL'`\n     *  + `'TANGENT'`\n     *  + `'TEXCOORD'`\n     *  + `'TEXCOORD_0'`\n     *  + `'TEXCOORD_1'`\n     *  + `'COLOR'`\n     *  + `'JOINT'`\n     *  + `'WEIGHT'`\n     *\n     * In shader, attribute with same semantic will be automatically mapped. For example:\n     * ```glsl\n     * attribute vec3 pos: POSITION\n     * ```\n     * will use the attribute value with semantic POSITION in geometry, no matter what name it used.\n     * @type {string}\n     */\n    this.semantic = semantic || '';\n\n    /**\n     * Value of the attribute.\n     * @type {TypedArray}\n     */\n    this.value = null;\n\n    // Init getter setter\n    switch (size) {\n        case 1:\n            this.get = function (idx) {\n                return this.value[idx];\n            };\n            this.set = function (idx, value) {\n                this.value[idx] = value;\n            };\n            // Copy from source to target\n            this.copy = function (target, source) {\n                this.value[target] = this.value[target];\n            };\n            break;\n        case 2:\n            this.get = function (idx, out) {\n                var arr = this.value;\n                out[0] = arr[idx * 2];\n                out[1] = arr[idx * 2 + 1];\n                return out;\n            };\n            this.set = function (idx, val) {\n                var arr = this.value;\n                arr[idx * 2] = val[0];\n                arr[idx * 2 + 1] = val[1];\n            };\n            this.copy = function (target, source) {\n                var arr = this.value;\n                source *= 2;\n                target *= 2;\n                arr[target] = arr[source];\n                arr[target + 1] = arr[source + 1];\n            };\n            break;\n        case 3:\n            this.get = function (idx, out) {\n                var idx3 = idx * 3;\n                var arr = this.value;\n                out[0] = arr[idx3];\n                out[1] = arr[idx3 + 1];\n                out[2] = arr[idx3 + 2];\n                return out;\n            };\n            this.set = function (idx, val) {\n                var idx3 = idx * 3;\n                var arr = this.value;\n                arr[idx3] = val[0];\n                arr[idx3 + 1] = val[1];\n                arr[idx3 + 2] = val[2];\n            };\n            this.copy = function (target, source) {\n                var arr = this.value;\n                source *= 3;\n                target *= 3;\n                arr[target] = arr[source];\n                arr[target + 1] = arr[source + 1];\n                arr[target + 2] = arr[source + 2];\n            };\n            break;\n        case 4:\n            this.get = function (idx, out) {\n                var arr = this.value;\n                var idx4 = idx * 4;\n                out[0] = arr[idx4];\n                out[1] = arr[idx4 + 1];\n                out[2] = arr[idx4 + 2];\n                out[3] = arr[idx4 + 3];\n                return out;\n            };\n            this.set = function (idx, val) {\n                var arr = this.value;\n                var idx4 = idx * 4;\n                arr[idx4] = val[0];\n                arr[idx4 + 1] = val[1];\n                arr[idx4 + 2] = val[2];\n                arr[idx4 + 3] = val[3];\n            };\n            this.copy = function (target, source) {\n                var arr = this.value;\n                source *= 4;\n                target *= 4;\n                // copyWithin is extremely slow\n                arr[target] = arr[source];\n                arr[target + 1] = arr[source + 1];\n                arr[target + 2] = arr[source + 2];\n                arr[target + 3] = arr[source + 3];\n            };\n    }\n}\n\n/**\n * Set item value at give index. Second parameter val is number if size is 1\n * @function\n * @name clay.GeometryBase.Attribute#set\n * @param {number} idx\n * @param {number[]|number} val\n * @example\n * geometry.getAttribute('position').set(0, [1, 1, 1]);\n */\n\n/**\n * Get item value at give index. Second parameter out is no need if size is 1\n * @function\n * @name clay.GeometryBase.Attribute#set\n * @param {number} idx\n * @param {number[]} [out]\n * @example\n * geometry.getAttribute('position').get(0, out);\n */\n\n/**\n * Initialize attribute with given vertex count\n * @param {number} nVertex\n */\nAttribute.prototype.init = function (nVertex) {\n    if (!this.value || this.value.length !== nVertex * this.size) {\n        var ArrayConstructor = getArrayCtorByType(this.type);\n        this.value = new ArrayConstructor(nVertex * this.size);\n    }\n};\n\n/**\n * Initialize attribute with given array. Which can be 1 dimensional or 2 dimensional\n * @param {Array} array\n * @example\n *  geometry.getAttribute('position').fromArray(\n *      [-1, 0, 0, 1, 0, 0, 0, 1, 0]\n *  );\n *  geometry.getAttribute('position').fromArray(\n *      [ [-1, 0, 0], [1, 0, 0], [0, 1, 0] ]\n *  );\n */\nAttribute.prototype.fromArray = function (array) {\n    var ArrayConstructor = getArrayCtorByType(this.type);\n    var value;\n    // Convert 2d array to flat\n    if (array[0] && (array[0].length)) {\n        var n = 0;\n        var size = this.size;\n        value = new ArrayConstructor(array.length * size);\n        for (var i = 0; i < array.length; i++) {\n            for (var j = 0; j < size; j++) {\n                value[n++] = array[i][j];\n            }\n        }\n    }\n    else {\n        value = new ArrayConstructor(array);\n    }\n    this.value = value;\n};\n\nAttribute.prototype.clone = function(copyValue) {\n    var ret = new Attribute(this.name, this.type, this.size, this.semantic);\n    // FIXME\n    if (copyValue) {\n        console.warn('todo');\n    }\n    return ret;\n};\n\nfunction AttributeBuffer(name, type, buffer, size, semantic) {\n    this.name = name;\n    this.type = type;\n    this.buffer = buffer;\n    this.size = size;\n    this.semantic = semantic;\n\n    // To be set in mesh\n    // symbol in the shader\n    this.symbol = '';\n\n    // Needs remove flag\n    this.needsRemove = false;\n}\n\nfunction IndicesBuffer(buffer) {\n    this.buffer = buffer;\n    this.count = 0;\n}\n\n/**\n * Base of all geometry. Use {@link clay.Geometry} for common 3D usage.\n * @constructor clay.GeometryBase\n * @extends clay.core.Base\n */\nvar GeometryBase = Base.extend(function () {\n    return /** @lends clay.GeometryBase# */ {\n        /**\n         * Attributes of geometry.\n         * @type {Object.<string, clay.GeometryBase.Attribute>}\n         */\n        attributes: {},\n\n        /**\n         * Indices of geometry.\n         * @type {Uint16Array|Uint32Array}\n         */\n        indices: null,\n\n        /**\n         * Is vertices data dynamically updated.\n         * Attributes value can't be changed after first render if dyanmic is false.\n         * @type {boolean}\n         */\n        dynamic: true,\n\n        _enabledAttributes: null,\n\n        // PENDING\n        // Init it here to avoid deoptimization when it's assigned in application dynamically\n        __used: 0\n    };\n}, function () {\n    // Use cache\n    this._cache = new Cache();\n\n    this._attributeList = Object.keys(this.attributes);\n\n    this.__vaoCache = {};\n},\n/** @lends clay.GeometryBase.prototype */\n{\n    /**\n     * Main attribute will be used to count vertex number\n     * @type {string}\n     */\n    mainAttribute: '',\n    /**\n     * User defined picking algorithm instead of default\n     * triangle ray intersection\n     * x, y are NDC.\n     * ```typescript\n     * (x, y, renderer, camera, renderable, out) => boolean\n     * ```\n     * @type {?Function}\n     */\n    pick: null,\n\n    /**\n     * User defined ray picking algorithm instead of default\n     * triangle ray intersection\n     * ```typescript\n     * (ray: clay.Ray, renderable: clay.Renderable, out: Array) => boolean\n     * ```\n     * @type {?Function}\n     */\n    pickByRay: null,\n\n    /**\n     * Mark attributes and indices in geometry needs to update.\n     * Usually called after you change the data in attributes.\n     */\n    dirty: function () {\n        var enabledAttributes = this.getEnabledAttributes();\n        for (var i = 0; i < enabledAttributes.length; i++) {\n            this.dirtyAttribute(enabledAttributes[i]);\n        }\n        this.dirtyIndices();\n        this._enabledAttributes = null;\n\n        this._cache.dirty('any');\n    },\n    /**\n     * Mark the indices needs to update.\n     */\n    dirtyIndices: function () {\n        this._cache.dirtyAll('indices');\n    },\n    /**\n     * Mark the attributes needs to update.\n     * @param {string} [attrName]\n     */\n    dirtyAttribute: function (attrName) {\n        this._cache.dirtyAll(makeAttrKey(attrName));\n        this._cache.dirtyAll('attributes');\n    },\n    /**\n     * Get indices of triangle at given index.\n     * @param {number} idx\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     */\n    getTriangleIndices: function (idx, out) {\n        if (idx < this.triangleCount && idx >= 0) {\n            if (!out) {\n                out = [];\n            }\n            var indices = this.indices;\n            out[0] = indices[idx * 3];\n            out[1] = indices[idx * 3 + 1];\n            out[2] = indices[idx * 3 + 2];\n            return out;\n        }\n    },\n\n    /**\n     * Set indices of triangle at given index.\n     * @param {number} idx\n     * @param {Array.<number>} arr\n     */\n    setTriangleIndices: function (idx, arr) {\n        var indices = this.indices;\n        indices[idx * 3] = arr[0];\n        indices[idx * 3 + 1] = arr[1];\n        indices[idx * 3 + 2] = arr[2];\n    },\n\n    isUseIndices: function () {\n        return !!this.indices;\n    },\n\n    /**\n     * Initialize indices from an array.\n     * @param {Array} array\n     */\n    initIndicesFromArray: function (array) {\n        var value;\n        var ArrayConstructor = this.vertexCount > 0xffff\n            ? vendor.Uint32Array : vendor.Uint16Array;\n        // Convert 2d array to flat\n        if (array[0] && (array[0].length)) {\n            var n = 0;\n            var size = 3;\n\n            value = new ArrayConstructor(array.length * size);\n            for (var i = 0; i < array.length; i++) {\n                for (var j = 0; j < size; j++) {\n                    value[n++] = array[i][j];\n                }\n            }\n        }\n        else {\n            value = new ArrayConstructor(array);\n        }\n\n        this.indices = value;\n    },\n    /**\n     * Create a new attribute\n     * @param {string} name\n     * @param {string} type\n     * @param {number} size\n     * @param {string} [semantic]\n     */\n    createAttribute: function (name, type, size, semantic) {\n        var attrib = new Attribute(name, type, size, semantic);\n        if (this.attributes[name]) {\n            this.removeAttribute(name);\n        }\n        this.attributes[name] = attrib;\n        this._attributeList.push(name);\n        return attrib;\n    },\n    /**\n     * Remove attribute\n     * @param {string} name\n     */\n    removeAttribute: function (name) {\n        var attributeList = this._attributeList;\n        var idx = attributeList.indexOf(name);\n        if (idx >= 0) {\n            attributeList.splice(idx, 1);\n            delete this.attributes[name];\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * Get attribute\n     * @param {string} name\n     * @return {clay.GeometryBase.Attribute}\n     */\n    getAttribute: function (name) {\n        return this.attributes[name];\n    },\n\n    /**\n     * Get enabled attributes name list\n     * Attribute which has the same vertex number with position is treated as a enabled attribute\n     * @return {string[]}\n     */\n    getEnabledAttributes: function () {\n        var enabledAttributes = this._enabledAttributes;\n        var attributeList = this._attributeList;\n        // Cache\n        if (enabledAttributes) {\n            return enabledAttributes;\n        }\n\n        var result = [];\n        var nVertex = this.vertexCount;\n\n        for (var i = 0; i < attributeList.length; i++) {\n            var name = attributeList[i];\n            var attrib = this.attributes[name];\n            if (attrib.value) {\n                if (attrib.value.length === nVertex * attrib.size) {\n                    result.push(name);\n                }\n            }\n        }\n\n        this._enabledAttributes = result;\n\n        return result;\n    },\n\n    getBufferChunks: function (renderer) {\n        var cache = this._cache;\n        cache.use(renderer.__uid__);\n        var isAttributesDirty = cache.isDirty('attributes');\n        var isIndicesDirty = cache.isDirty('indices');\n        if (isAttributesDirty || isIndicesDirty) {\n            this._updateBuffer(renderer.gl, isAttributesDirty, isIndicesDirty);\n            var enabledAttributes = this.getEnabledAttributes();\n            for (var i = 0; i < enabledAttributes.length; i++) {\n                cache.fresh(makeAttrKey(enabledAttributes[i]));\n            }\n            cache.fresh('attributes');\n            cache.fresh('indices');\n        }\n        cache.fresh('any');\n        return cache.get('chunks');\n    },\n\n    _updateBuffer: function (_gl, isAttributesDirty, isIndicesDirty) {\n        var cache = this._cache;\n        var chunks = cache.get('chunks');\n        var firstUpdate = false;\n        if (!chunks) {\n            chunks = [];\n            // Intialize\n            chunks[0] = {\n                attributeBuffers: [],\n                indicesBuffer: null\n            };\n            cache.put('chunks', chunks);\n            firstUpdate = true;\n        }\n\n        var chunk = chunks[0];\n        var attributeBuffers = chunk.attributeBuffers;\n        var indicesBuffer = chunk.indicesBuffer;\n\n        if (isAttributesDirty || firstUpdate) {\n            var attributeList = this.getEnabledAttributes();\n\n            var attributeBufferMap = {};\n            if (!firstUpdate) {\n                for (var i = 0; i < attributeBuffers.length; i++) {\n                    attributeBufferMap[attributeBuffers[i].name] = attributeBuffers[i];\n                }\n            }\n            // FIXME If some attributes removed\n            for (var k = 0; k < attributeList.length; k++) {\n                var name = attributeList[k];\n                var attribute = this.attributes[name];\n\n                var bufferInfo;\n\n                if (!firstUpdate) {\n                    bufferInfo = attributeBufferMap[name];\n                }\n                var buffer;\n                if (bufferInfo) {\n                    buffer = bufferInfo.buffer;\n                }\n                else {\n                    buffer = _gl.createBuffer();\n                }\n                if (cache.isDirty(makeAttrKey(name))) {\n                    // Only update when they are dirty.\n                    // TODO: Use BufferSubData?\n                    _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);\n                    _gl.bufferData(_gl.ARRAY_BUFFER, attribute.value, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);\n                }\n\n                attributeBuffers[k] = new AttributeBuffer(name, attribute.type, buffer, attribute.size, attribute.semantic);\n            }\n            // Remove unused attributes buffers.\n            // PENDING\n            for (var i = k; i < attributeBuffers.length; i++) {\n                _gl.deleteBuffer(attributeBuffers[i].buffer);\n            }\n            attributeBuffers.length = k;\n\n        }\n\n        if (this.isUseIndices() && (isIndicesDirty || firstUpdate)) {\n            if (!indicesBuffer) {\n                indicesBuffer = new IndicesBuffer(_gl.createBuffer());\n                chunk.indicesBuffer = indicesBuffer;\n            }\n            indicesBuffer.count = this.indices.length;\n            _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);\n            _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, this.indices, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);\n        }\n    },\n\n    /**\n     * Dispose geometry data in GL context.\n     * @param {clay.Renderer} renderer\n     */\n    dispose: function (renderer) {\n\n        var cache = this._cache;\n\n        cache.use(renderer.__uid__);\n        var chunks = cache.get('chunks');\n        if (chunks) {\n            for (var c = 0; c < chunks.length; c++) {\n                var chunk = chunks[c];\n\n                for (var k = 0; k < chunk.attributeBuffers.length; k++) {\n                    var attribs = chunk.attributeBuffers[k];\n                    renderer.gl.deleteBuffer(attribs.buffer);\n                }\n\n                if (chunk.indicesBuffer) {\n                    renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);\n                }\n            }\n        }\n        if (this.__vaoCache) {\n            var vaoExt = renderer.getGLExtension('OES_vertex_array_object');\n            for (var id in this.__vaoCache) {\n                var vao = this.__vaoCache[id].vao;\n                if (vao) {\n                    vaoExt.deleteVertexArrayOES(vao);\n                }\n            }\n        }\n        this.__vaoCache = {};\n        cache.deleteContext(renderer.__uid__);\n    }\n\n});\n\nif (Object.defineProperty) {\n    /**\n     * @name clay.GeometryBase#vertexCount\n     * @type {number}\n     * @readOnly\n     */\n    Object.defineProperty(GeometryBase.prototype, 'vertexCount', {\n\n        enumerable: false,\n\n        get: function () {\n\n            var mainAttribute = this.attributes[this.mainAttribute];\n\n            if (!mainAttribute) {\n                mainAttribute = this.attributes[this._attributeList[0]];\n            }\n\n            if (!mainAttribute || !mainAttribute.value) {\n                return 0;\n            }\n            return mainAttribute.value.length / mainAttribute.size;\n        }\n    });\n    /**\n     * @name clay.GeometryBase#triangleCount\n     * @type {number}\n     * @readOnly\n     */\n    Object.defineProperty(GeometryBase.prototype, 'triangleCount', {\n\n        enumerable: false,\n\n        get: function () {\n            var indices = this.indices;\n            if (!indices) {\n                return 0;\n            }\n            else {\n                return indices.length / 3;\n            }\n        }\n    });\n}\n\nGeometryBase.STATIC_DRAW = glenum.STATIC_DRAW;\nGeometryBase.DYNAMIC_DRAW = glenum.DYNAMIC_DRAW;\nGeometryBase.STREAM_DRAW = glenum.STREAM_DRAW;\n\nGeometryBase.AttributeBuffer = AttributeBuffer;\nGeometryBase.IndicesBuffer = IndicesBuffer;\n\nGeometryBase.Attribute = Attribute;\n\nexport default GeometryBase;\n","import vendor from './core/vendor';\nimport vec3 from './glmatrix/vec3';\nimport mat4 from './glmatrix/mat4';\nimport BoundingBox from './math/BoundingBox';\nimport GeometryBase from './GeometryBase';\n\nvar vec3Create = vec3.create;\nvar vec3Add = vec3.add;\nvar vec3Set = vec3.set;\n\nvar Attribute = GeometryBase.Attribute;\n\n/**\n * Geometry in ClayGL contains vertex attributes of mesh. These vertex attributes will be finally provided to the {@link clay.Shader}.\n * Different {@link clay.Shader} needs different attributes. Here is a list of attributes used in the builtin shaders.\n *\n * + position: `clay.basic`, `clay.lambert`, `clay.standard`\n * + texcoord0: `clay.basic`, `clay.lambert`, `clay.standard`\n * + color: `clay.basic`, `clay.lambert`, `clay.standard`\n * + weight: `clay.basic`, `clay.lambert`, `clay.standard`\n * + joint: `clay.basic`, `clay.lambert`, `clay.standard`\n * + normal: `clay.lambert`, `clay.standard`\n * + tangent: `clay.standard`\n *\n * #### Create a procedural geometry\n *\n * ClayGL provides a couple of builtin procedural geometries. Inlcuding:\n *\n *  + {@link clay.geometry.Cube}\n *  + {@link clay.geometry.Sphere}\n *  + {@link clay.geometry.Plane}\n *  + {@link clay.geometry.Cylinder}\n *  + {@link clay.geometry.Cone}\n *  + {@link clay.geometry.ParametricSurface}\n *\n * It's simple to create a basic geometry with these classes.\n *\n```js\nvar sphere = new clay.geometry.Sphere({\n    radius: 2\n});\n```\n *\n * #### Create the geometry data by yourself\n *\n * Usually the vertex attributes data are created by the {@link clay.loader.GLTF} or procedural geometries like {@link clay.geometry.Sphere}.\n * Besides these, you can create the data manually. Here is a simple example to create a triangle.\n```js\nvar TRIANGLE_POSITIONS = [\n    [-0.5, -0.5, 0],\n    [0.5, -0.5, 0],\n    [0, 0.5, 0]\n];\nvar geometry = new clay.StaticGeometryBase();\n// Add triangle vertices to position attribute.\ngeometry.attributes.position.fromArray(TRIANGLE_POSITIONS);\n```\n * Then you can use the utility methods like `generateVertexNormals`, `generateTangents` to create the remaining necessary attributes.\n *\n *\n * #### Use with custom shaders\n *\n * If you wan't to write custom shaders. Don't forget to add SEMANTICS to these attributes. For example\n *\n ```glsl\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nuniform mat4 world : WORLD;\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 normal : NORMAL;\n```\n * These `POSITION`, `TEXCOORD_0`, `NORMAL` are SEMANTICS which will map the attributes in shader to the attributes in the GeometryBase\n *\n * Available attributes SEMANTICS includes `POSITION`, `TEXCOORD_0`, `TEXCOORD_1` `NORMAL`, `TANGENT`, `COLOR`, `WEIGHT`, `JOINT`.\n *\n *\n * @constructor clay.Geometry\n * @extends clay.GeometryBase\n */\nvar Geometry = GeometryBase.extend(function () {\n    return /** @lends clay.Geometry# */ {\n        /**\n         * Attributes of geometry. Including:\n         *  + `position`\n         *  + `texcoord0`\n         *  + `texcoord1`\n         *  + `normal`\n         *  + `tangent`\n         *  + `color`\n         *  + `weight`\n         *  + `joint`\n         *  + `barycentric`\n         *\n         * @type {Object.<string, clay.Geometry.Attribute>}\n         */\n        attributes: {\n            position: new Attribute('position', 'float', 3, 'POSITION'),\n            texcoord0: new Attribute('texcoord0', 'float', 2, 'TEXCOORD_0'),\n            texcoord1: new Attribute('texcoord1', 'float', 2, 'TEXCOORD_1'),\n            normal: new Attribute('normal', 'float', 3, 'NORMAL'),\n            tangent: new Attribute('tangent', 'float', 4, 'TANGENT'),\n            color: new Attribute('color', 'float', 4, 'COLOR'),\n            // Skinning attributes\n            // Each vertex can be bind to 4 bones, because the\n            // sum of weights is 1, so the weights is stored in vec3 and the last\n            // can be calculated by 1-w.x-w.y-w.z\n            weight: new Attribute('weight', 'float', 3, 'WEIGHT'),\n            joint: new Attribute('joint', 'float', 4, 'JOINT'),\n            // For wireframe display\n            // http://codeflow.org/entries/2012/aug/02/easy-wireframe-display-with-barycentric-coordinates/\n            barycentric: new Attribute('barycentric', 'float', 3, null),\n        },\n        /**\n         * Calculated bounding box of geometry.\n         * @type {clay.BoundingBox}\n         */\n        boundingBox: null\n    };\n},\n/** @lends clay.Geometry.prototype */\n{\n\n    mainAttribute: 'position',\n\n    /**\n     * Update boundingBox of Geometry\n     */\n    updateBoundingBox: function () {\n        var bbox = this.boundingBox;\n        if (!bbox) {\n            bbox = this.boundingBox = new BoundingBox();\n        }\n        var posArr = this.attributes.position.value;\n        if (posArr && posArr.length) {\n            var min = bbox.min;\n            var max = bbox.max;\n            var minArr = min.array;\n            var maxArr = max.array;\n            vec3.set(minArr, posArr[0], posArr[1], posArr[2]);\n            vec3.set(maxArr, posArr[0], posArr[1], posArr[2]);\n            for (var i = 3; i < posArr.length;) {\n                var x = posArr[i++];\n                var y = posArr[i++];\n                var z = posArr[i++];\n                if (x < minArr[0]) { minArr[0] = x; }\n                if (y < minArr[1]) { minArr[1] = y; }\n                if (z < minArr[2]) { minArr[2] = z; }\n\n                if (x > maxArr[0]) { maxArr[0] = x; }\n                if (y > maxArr[1]) { maxArr[1] = y; }\n                if (z > maxArr[2]) { maxArr[2] = z; }\n            }\n            min._dirty = true;\n            max._dirty = true;\n        }\n    },\n\n    /**\n     * Generate normals per vertex.\n     */\n    generateVertexNormals: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        var indices = this.indices;\n        var attributes = this.attributes;\n        var positions = attributes.position.value;\n        var normals = attributes.normal.value;\n\n        if (!normals || normals.length !== positions.length) {\n            normals = attributes.normal.value = new vendor.Float32Array(positions.length);\n        }\n        else {\n            // Reset\n            for (var i = 0; i < normals.length; i++) {\n                normals[i] = 0;\n            }\n        }\n\n        var p1 = vec3Create();\n        var p2 = vec3Create();\n        var p3 = vec3Create();\n\n        var v21 = vec3Create();\n        var v32 = vec3Create();\n\n        var n = vec3Create();\n\n        var len = indices ? indices.length : this.vertexCount;\n        var i1, i2, i3;\n        for (var f = 0; f < len;) {\n            if (indices) {\n                i1 = indices[f++];\n                i2 = indices[f++];\n                i3 = indices[f++];\n            }\n            else {\n                i1 = f++;\n                i2 = f++;\n                i3 = f++;\n            }\n\n            vec3Set(p1, positions[i1*3], positions[i1*3+1], positions[i1*3+2]);\n            vec3Set(p2, positions[i2*3], positions[i2*3+1], positions[i2*3+2]);\n            vec3Set(p3, positions[i3*3], positions[i3*3+1], positions[i3*3+2]);\n\n            vec3.sub(v21, p1, p2);\n            vec3.sub(v32, p2, p3);\n            vec3.cross(n, v21, v32);\n            // Already be weighted by the triangle area\n            for (var i = 0; i < 3; i++) {\n                normals[i1*3+i] = normals[i1*3+i] + n[i];\n                normals[i2*3+i] = normals[i2*3+i] + n[i];\n                normals[i3*3+i] = normals[i3*3+i] + n[i];\n            }\n        }\n\n        for (var i = 0; i < normals.length;) {\n            vec3Set(n, normals[i], normals[i+1], normals[i+2]);\n            vec3.normalize(n, n);\n            normals[i++] = n[0];\n            normals[i++] = n[1];\n            normals[i++] = n[2];\n        }\n        this.dirty();\n    },\n\n    /**\n     * Generate normals per face.\n     */\n    generateFaceNormals: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        if (!this.isUniqueVertex()) {\n            this.generateUniqueVertex();\n        }\n\n        var indices = this.indices;\n        var attributes = this.attributes;\n        var positions = attributes.position.value;\n        var normals = attributes.normal.value;\n\n        var p1 = vec3Create();\n        var p2 = vec3Create();\n        var p3 = vec3Create();\n\n        var v21 = vec3Create();\n        var v32 = vec3Create();\n        var n = vec3Create();\n\n        if (!normals) {\n            normals = attributes.normal.value = new Float32Array(positions.length);\n        }\n        var len = indices ? indices.length : this.vertexCount;\n        var i1, i2, i3;\n        for (var f = 0; f < len;) {\n            if (indices) {\n                i1 = indices[f++];\n                i2 = indices[f++];\n                i3 = indices[f++];\n            }\n            else {\n                i1 = f++;\n                i2 = f++;\n                i3 = f++;\n            }\n\n            vec3Set(p1, positions[i1*3], positions[i1*3+1], positions[i1*3+2]);\n            vec3Set(p2, positions[i2*3], positions[i2*3+1], positions[i2*3+2]);\n            vec3Set(p3, positions[i3*3], positions[i3*3+1], positions[i3*3+2]);\n\n            vec3.sub(v21, p1, p2);\n            vec3.sub(v32, p2, p3);\n            vec3.cross(n, v21, v32);\n\n            vec3.normalize(n, n);\n\n            for (var i = 0; i < 3; i++) {\n                normals[i1*3 + i] = n[i];\n                normals[i2*3 + i] = n[i];\n                normals[i3*3 + i] = n[i];\n            }\n        }\n        this.dirty();\n    },\n\n    /**\n     * Generate tangents attributes.\n     */\n    generateTangents: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        var nVertex = this.vertexCount;\n        var attributes = this.attributes;\n        if (!attributes.tangent.value) {\n            attributes.tangent.value = new Float32Array(nVertex * 4);\n        }\n        var texcoords = attributes.texcoord0.value;\n        var positions = attributes.position.value;\n        var tangents = attributes.tangent.value;\n        var normals = attributes.normal.value;\n\n        if (!texcoords) {\n            console.warn('Geometry without texcoords can\\'t generate tangents.');\n            return;\n        }\n\n        var tan1 = [];\n        var tan2 = [];\n        for (var i = 0; i < nVertex; i++) {\n            tan1[i] = [0.0, 0.0, 0.0];\n            tan2[i] = [0.0, 0.0, 0.0];\n        }\n\n        var sdir = [0.0, 0.0, 0.0];\n        var tdir = [0.0, 0.0, 0.0];\n        var indices = this.indices;\n\n        var len = indices ? indices.length : this.vertexCount;\n        var i1, i2, i3;\n        for (var i = 0; i < len;) {\n            if (indices) {\n                i1 = indices[i++];\n                i2 = indices[i++];\n                i3 = indices[i++];\n            }\n            else {\n                i1 = i++;\n                i2 = i++;\n                i3 = i++;\n            }\n\n            var st1s = texcoords[i1 * 2],\n                st2s = texcoords[i2 * 2],\n                st3s = texcoords[i3 * 2],\n                st1t = texcoords[i1 * 2 + 1],\n                st2t = texcoords[i2 * 2 + 1],\n                st3t = texcoords[i3 * 2 + 1],\n\n                p1x = positions[i1 * 3],\n                p2x = positions[i2 * 3],\n                p3x = positions[i3 * 3],\n                p1y = positions[i1 * 3 + 1],\n                p2y = positions[i2 * 3 + 1],\n                p3y = positions[i3 * 3 + 1],\n                p1z = positions[i1 * 3 + 2],\n                p2z = positions[i2 * 3 + 2],\n                p3z = positions[i3 * 3 + 2];\n\n            var x1 = p2x - p1x,\n                x2 = p3x - p1x,\n                y1 = p2y - p1y,\n                y2 = p3y - p1y,\n                z1 = p2z - p1z,\n                z2 = p3z - p1z;\n\n            var s1 = st2s - st1s,\n                s2 = st3s - st1s,\n                t1 = st2t - st1t,\n                t2 = st3t - st1t;\n\n            var r = 1.0 / (s1 * t2 - t1 * s2);\n            sdir[0] = (t2 * x1 - t1 * x2) * r;\n            sdir[1] = (t2 * y1 - t1 * y2) * r;\n            sdir[2] = (t2 * z1 - t1 * z2) * r;\n\n            tdir[0] = (s1 * x2 - s2 * x1) * r;\n            tdir[1] = (s1 * y2 - s2 * y1) * r;\n            tdir[2] = (s1 * z2 - s2 * z1) * r;\n\n            vec3Add(tan1[i1], tan1[i1], sdir);\n            vec3Add(tan1[i2], tan1[i2], sdir);\n            vec3Add(tan1[i3], tan1[i3], sdir);\n            vec3Add(tan2[i1], tan2[i1], tdir);\n            vec3Add(tan2[i2], tan2[i2], tdir);\n            vec3Add(tan2[i3], tan2[i3], tdir);\n        }\n        var tmp = vec3Create();\n        var nCrossT = vec3Create();\n        var n = vec3Create();\n        for (var i = 0; i < nVertex; i++) {\n            n[0] = normals[i * 3];\n            n[1] = normals[i * 3 + 1];\n            n[2] = normals[i * 3 + 2];\n            var t = tan1[i];\n\n            // Gram-Schmidt orthogonalize\n            vec3.scale(tmp, n, vec3.dot(n, t));\n            vec3.sub(tmp, t, tmp);\n            vec3.normalize(tmp, tmp);\n            // Calculate handedness.\n            vec3.cross(nCrossT, n, t);\n            tangents[i * 4] = tmp[0];\n            tangents[i * 4 + 1] = tmp[1];\n            tangents[i * 4 + 2] = tmp[2];\n            // PENDING can config ?\n            tangents[i * 4 + 3] = vec3.dot(nCrossT, tan2[i]) < 0.0 ? -1.0 : 1.0;\n        }\n        this.dirty();\n    },\n\n    /**\n     * If vertices are not shared by different indices.\n     */\n    isUniqueVertex: function () {\n        if (this.isUseIndices()) {\n            return this.vertexCount === this.indices.length;\n        }\n        else {\n            return true;\n        }\n    },\n    /**\n     * Create a unique vertex for each index.\n     */\n    generateUniqueVertex: function () {\n        if (!this.vertexCount || !this.indices) {\n            return;\n        }\n\n        if (this.indices.length > 0xffff) {\n            this.indices = new vendor.Uint32Array(this.indices);\n        }\n\n        var attributes = this.attributes;\n        var indices = this.indices;\n\n        var attributeNameList = this.getEnabledAttributes();\n\n        var oldAttrValues = {};\n        for (var a = 0; a < attributeNameList.length; a++) {\n            var name = attributeNameList[a];\n            oldAttrValues[name] = attributes[name].value;\n            attributes[name].init(this.indices.length);\n        }\n\n        var cursor = 0;\n        for (var i = 0; i < indices.length; i++) {\n            var ii = indices[i];\n            for (var a = 0; a < attributeNameList.length; a++) {\n                var name = attributeNameList[a];\n                var array = attributes[name].value;\n                var size = attributes[name].size;\n\n                for (var k = 0; k < size; k++) {\n                    array[cursor * size + k] = oldAttrValues[name][ii * size + k];\n                }\n            }\n            indices[i] = cursor;\n            cursor++;\n        }\n\n        this.dirty();\n    },\n\n    /**\n     * Generate barycentric coordinates for wireframe draw.\n     */\n    generateBarycentric: function () {\n        if (!this.vertexCount) {\n            return;\n        }\n\n        if (!this.isUniqueVertex()) {\n            this.generateUniqueVertex();\n        }\n\n        var attributes = this.attributes;\n        var array = attributes.barycentric.value;\n        var indices = this.indices;\n        // Already existed;\n        if (array && array.length === indices.length * 3) {\n            return;\n        }\n        array = attributes.barycentric.value = new Float32Array(indices.length * 3);\n\n        for (var i = 0; i < (indices ? indices.length : this.vertexCount / 3);) {\n            for (var j = 0; j < 3; j++) {\n                var ii = indices ? indices[i++] : (i * 3 + j);\n                array[ii * 3 + j] = 1;\n            }\n        }\n        this.dirty();\n    },\n\n    /**\n     * Apply transform to geometry attributes.\n     * @param {clay.Matrix4} matrix\n     */\n    applyTransform: function (matrix) {\n\n        var attributes = this.attributes;\n        var positions = attributes.position.value;\n        var normals = attributes.normal.value;\n        var tangents = attributes.tangent.value;\n\n        matrix = matrix.array;\n        // Normal Matrix\n        var inverseTransposeMatrix = mat4.create();\n        mat4.invert(inverseTransposeMatrix, matrix);\n        mat4.transpose(inverseTransposeMatrix, inverseTransposeMatrix);\n\n        var vec3TransformMat4 = vec3.transformMat4;\n        var vec3ForEach = vec3.forEach;\n        vec3ForEach(positions, 3, 0, null, vec3TransformMat4, matrix);\n        if (normals) {\n            vec3ForEach(normals, 3, 0, null, vec3TransformMat4, inverseTransposeMatrix);\n        }\n        if (tangents) {\n            vec3ForEach(tangents, 4, 0, null, vec3TransformMat4, inverseTransposeMatrix);\n        }\n\n        if (this.boundingBox) {\n            this.updateBoundingBox();\n        }\n    },\n    /**\n     * Dispose geometry data in GL context.\n     * @param {clay.Renderer} renderer\n     */\n    dispose: function (renderer) {\n\n        var cache = this._cache;\n\n        cache.use(renderer.__uid__);\n        var chunks = cache.get('chunks');\n        if (chunks) {\n            for (var c = 0; c < chunks.length; c++) {\n                var chunk = chunks[c];\n\n                for (var k = 0; k < chunk.attributeBuffers.length; k++) {\n                    var attribs = chunk.attributeBuffers[k];\n                    renderer.gl.deleteBuffer(attribs.buffer);\n                }\n\n                if (chunk.indicesBuffer) {\n                    renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);\n                }\n            }\n        }\n        if (this.__vaoCache) {\n            var vaoExt = renderer.getGLExtension('OES_vertex_array_object');\n            for (var id in this.__vaoCache) {\n                var vao = this.__vaoCache[id].vao;\n                if (vao) {\n                    vaoExt.deleteVertexArrayOES(vao);\n                }\n            }\n        }\n        this.__vaoCache = {};\n        cache.deleteContext(renderer.__uid__);\n    }\n\n});\n\nGeometry.STATIC_DRAW = GeometryBase.STATIC_DRAW;\nGeometry.DYNAMIC_DRAW = GeometryBase.DYNAMIC_DRAW;\nGeometry.STREAM_DRAW = GeometryBase.STREAM_DRAW;\n\nGeometry.AttributeBuffer = GeometryBase.AttributeBuffer;\nGeometry.IndicesBuffer = GeometryBase.IndicesBuffer;\n\nGeometry.Attribute = Attribute;\n\nexport default Geometry;\n","import Node from './Node';\nimport Shader from './Shader';\n\nimport lightShader from './shader/source/header/light';\nShader['import'](lightShader);\n\n/**\n * @constructor clay.Light\n * @extends clay.Node\n */\nvar Light = Node.extend(function(){\n    return /** @lends clay.Light# */ {\n        /**\n         * Light RGB color\n         * @type {number[]}\n         */\n        color: [1, 1, 1],\n\n        /**\n         * Light intensity\n         * @type {number}\n         */\n        intensity: 1.0,\n\n        // Config for shadow map\n        /**\n         * If light cast shadow\n         * @type {boolean}\n         */\n        castShadow: true,\n\n        /**\n         * Shadow map size\n         * @type {number}\n         */\n        shadowResolution: 512,\n\n        /**\n         * Light group, shader with same `lightGroup` will be affected\n         *\n         * Only useful in forward rendering\n         * @type {number}\n         */\n        group: 0\n    };\n},\n/** @lends clay.Light.prototype. */\n{\n    /**\n     * Light type\n     * @type {string}\n     * @memberOf clay.Light#\n     */\n    type: '',\n\n    /**\n     * @return {clay.Light}\n     * @memberOf clay.Light.prototype\n     */\n    clone: function() {\n        var light = Node.prototype.clone.call(this);\n        light.color = Array.prototype.slice.call(this.color);\n        light.intensity = this.intensity;\n        light.castShadow = this.castShadow;\n        light.shadowResolution = this.shadowResolution;\n\n        return light;\n    }\n});\n\nexport default Light;\n","import Base from './core/Base';\nimport util from './core/util';\nimport colorUtil from './core/color';\nvar parseColor = colorUtil.parseToFloat;\n\nvar programKeyCache = {};\n\nfunction getDefineCode(defines) {\n    var defineKeys = Object.keys(defines);\n    defineKeys.sort();\n    var defineStr = [];\n    // Custom Defines\n    for (var i = 0; i < defineKeys.length; i++) {\n        var key = defineKeys[i];\n        var value = defines[key];\n        if (value === null) {\n            defineStr.push(key);\n        }\n        else{\n            defineStr.push(key + ' ' + value.toString());\n        }\n    }\n    return defineStr.join('\\n');\n}\n\nfunction getProgramKey(vertexDefines, fragmentDefines, enabledTextures) {\n    enabledTextures.sort();\n    var defineStr = [];\n    for (var i = 0; i < enabledTextures.length; i++) {\n        var symbol = enabledTextures[i];\n        defineStr.push(symbol);\n    }\n    var key = getDefineCode(vertexDefines) + '\\n'\n        + getDefineCode(fragmentDefines) + '\\n'\n        + defineStr.join('\\n');\n\n    if (programKeyCache[key]) {\n        return programKeyCache[key];\n    }\n\n    var id = util.genGUID();\n    programKeyCache[key] = id;\n    return id;\n}\n\n/**\n * Material defines the appearance of mesh surface, like `color`, `roughness`, `metalness`, etc.\n * It contains a {@link clay.Shader} and corresponding uniforms.\n *\n * Here is a basic example to create a standard material\n```js\nvar material = new clay.Material({\n    shader: new clay.Shader(\n        clay.Shader.source('clay.vertex'),\n        clay.Shader.source('clay.fragment')\n    )\n});\n```\n * @constructor clay.Material\n * @extends clay.core.Base\n */\nvar Material = Base.extend(function () {\n    return /** @lends clay.Material# */ {\n        /**\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * @type {Object}\n         */\n        // uniforms: null,\n\n        /**\n         * @type {clay.Shader}\n         */\n        // shader: null,\n\n        /**\n         * @type {boolean}\n         */\n        depthTest: true,\n\n        /**\n         * @type {boolean}\n         */\n        depthMask: true,\n\n        /**\n         * @type {boolean}\n         */\n        transparent: false,\n        /**\n         * Blend func is a callback function when the material\n         * have custom blending\n         * The gl context will be the only argument passed in tho the\n         * blend function\n         * Detail of blend function in WebGL:\n         * http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf\n         *\n         * Example :\n         * function(_gl) {\n         *  _gl.blendEquation(_gl.FUNC_ADD);\n         *  _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);\n         * }\n         */\n        blend: null,\n\n        /**\n         * If update texture status automatically.\n         */\n        autoUpdateTextureStatus: true,\n\n        uniforms: {},\n        vertexDefines: {},\n        fragmentDefines: {},\n        _textureStatus: {},\n\n        // shadowTransparentMap : null\n\n        // PENDING enable the uniform that only used in shader.\n        _enabledUniforms: null,\n    };\n}, function () {\n    if (!this.name) {\n        this.name = 'MATERIAL_' + this.__uid__;\n    }\n\n    if (this.shader) {\n        // Keep status, mainly preset uniforms, vertexDefines and fragmentDefines\n        this.attachShader(this.shader, true);\n    }\n},\n/** @lends clay.Material.prototype */\n{\n    precision: 'highp',\n\n    /**\n     * Set material uniform\n     * @example\n     *  mat.setUniform('color', [1, 1, 1, 1]);\n     * @param {string} symbol\n     * @param {number|array|clay.Texture|ArrayBufferView} value\n     */\n    setUniform: function (symbol, value) {\n        if (value === undefined) {\n            console.warn('Uniform value \"' + symbol + '\" is undefined');\n        }\n        var uniform = this.uniforms[symbol];\n        if (uniform) {\n\n            if (typeof value === 'string') {\n                // Try to parse as a color. Invalid color string will return null.\n                value = parseColor(value) || value;\n            }\n\n            uniform.value = value;\n\n            if (this.autoUpdateTextureStatus && uniform.type === 't') {\n                if (value) {\n                    this.enableTexture(symbol);\n                }\n                else {\n                    this.disableTexture(symbol);\n                }\n            }\n        }\n    },\n\n    /**\n     * @param {Object} obj\n     */\n    setUniforms: function(obj) {\n        for (var key in obj) {\n            var val = obj[key];\n            this.setUniform(key, val);\n        }\n    },\n\n    /**\n     * @param  {string}  symbol\n     * @return {boolean}\n     */\n    isUniformEnabled: function (symbol) {\n        return this._enabledUniforms.indexOf(symbol) >= 0;\n    },\n\n    getEnabledUniforms: function () {\n        return this._enabledUniforms;\n    },\n    getTextureUniforms: function () {\n        return this._textureUniforms;\n    },\n\n    /**\n     * Alias of setUniform and setUniforms\n     * @param {object|string} symbol\n     * @param {number|array|clay.Texture|ArrayBufferView} [value]\n     */\n    set: function (symbol, value) {\n        if (typeof(symbol) === 'object') {\n            for (var key in symbol) {\n                var val = symbol[key];\n                this.setUniform(key, val);\n            }\n        }\n        else {\n            this.setUniform(symbol, value);\n        }\n    },\n    /**\n     * Get uniform value\n     * @param  {string} symbol\n     * @return {number|array|clay.Texture|ArrayBufferView}\n     */\n    get: function (symbol) {\n        var uniform = this.uniforms[symbol];\n        if (uniform) {\n            return uniform.value;\n        }\n    },\n    /**\n     * Attach a shader instance\n     * @param  {clay.Shader} shader\n     * @param  {boolean} keepStatus If try to keep uniform and texture\n     */\n    attachShader: function(shader, keepStatus) {\n        var originalUniforms = this.uniforms;\n\n        // Ignore if uniform can use in shader.\n        this.uniforms = shader.createUniforms();\n        this.shader = shader;\n\n        var uniforms = this.uniforms;\n        this._enabledUniforms = Object.keys(uniforms);\n        // Make sure uniforms are set in same order to avoid texture slot wrong\n        this._enabledUniforms.sort();\n        this._textureUniforms = this._enabledUniforms.filter(function (uniformName) {\n            var type = this.uniforms[uniformName].type;\n            return type === 't' || type === 'tv';\n        }, this);\n\n        var originalVertexDefines = this.vertexDefines;\n        var originalFragmentDefines = this.fragmentDefines;\n\n        this.vertexDefines = util.clone(shader.vertexDefines);\n        this.fragmentDefines = util.clone(shader.fragmentDefines);\n\n        if (keepStatus) {\n            for (var symbol in originalUniforms) {\n                if (uniforms[symbol]) {\n                    uniforms[symbol].value = originalUniforms[symbol].value;\n                }\n            }\n\n            util.defaults(this.vertexDefines, originalVertexDefines);\n            util.defaults(this.fragmentDefines, originalFragmentDefines);\n        }\n\n        var textureStatus = {};\n        for (var key in shader.textures) {\n            textureStatus[key] = {\n                shaderType: shader.textures[key].shaderType,\n                type: shader.textures[key].type,\n                enabled: (keepStatus && this._textureStatus[key]) ? this._textureStatus[key].enabled : false\n            };\n        }\n\n        this._textureStatus = textureStatus;\n\n        this._programKey = '';\n    },\n\n    /**\n     * Clone a new material and keep uniforms, shader will not be cloned\n     * @return {clay.Material}\n     */\n    clone: function () {\n        var material = new this.constructor({\n            name: this.name,\n            shader: this.shader\n        });\n        for (var symbol in this.uniforms) {\n            material.uniforms[symbol].value = this.uniforms[symbol].value;\n        }\n        material.depthTest = this.depthTest;\n        material.depthMask = this.depthMask;\n        material.transparent = this.transparent;\n        material.blend = this.blend;\n\n        material.vertexDefines = util.clone(this.vertexDefines);\n        material.fragmentDefines = util.clone(this.fragmentDefines);\n        material.enableTexture(this.getEnabledTextures());\n        material.precision = this.precision;\n\n        return material;\n    },\n\n    /**\n     * Add a #define macro in shader code\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     * @param  {number} [val]\n     */\n    define: function (shaderType, symbol, val) {\n        var vertexDefines = this.vertexDefines;\n        var fragmentDefines = this.fragmentDefines;\n        if (shaderType !== 'vertex' && shaderType !== 'fragment' && shaderType !== 'both'\n            && arguments.length < 3\n        ) {\n            // shaderType default to be 'both'\n            val = symbol;\n            symbol = shaderType;\n            shaderType = 'both';\n        }\n        val = val != null ? val : null;\n        if (shaderType === 'vertex' || shaderType === 'both') {\n            if (vertexDefines[symbol] !== val) {\n                vertexDefines[symbol] = val;\n                // Mark as dirty\n                this._programKey = '';\n            }\n        }\n        if (shaderType === 'fragment' || shaderType === 'both') {\n            if (fragmentDefines[symbol] !== val) {\n                fragmentDefines[symbol] = val;\n                if (shaderType !== 'both') {\n                    this._programKey = '';\n                }\n            }\n        }\n    },\n\n    /**\n     * Remove a #define macro in shader code\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     */\n    undefine: function (shaderType, symbol) {\n        if (shaderType !== 'vertex' && shaderType !== 'fragment' && shaderType !== 'both'\n            && arguments.length < 2\n        ) {\n            // shaderType default to be 'both'\n            symbol = shaderType;\n            shaderType = 'both';\n        }\n        if (shaderType === 'vertex' || shaderType === 'both') {\n            if (this.isDefined('vertex', symbol)) {\n                delete this.vertexDefines[symbol];\n                // Mark as dirty\n                this._programKey = '';\n            }\n        }\n        if (shaderType === 'fragment' || shaderType === 'both') {\n            if (this.isDefined('fragment', symbol)) {\n                delete this.fragmentDefines[symbol];\n                if (shaderType !== 'both') {\n                    this._programKey = '';\n                }\n            }\n        }\n    },\n\n    /**\n     * If macro is defined in shader.\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     */\n    isDefined: function (shaderType, symbol) {\n        // PENDING hasOwnProperty ?\n        switch (shaderType) {\n            case 'vertex':\n                return this.vertexDefines[symbol] !== undefined;\n            case 'fragment':\n                return this.fragmentDefines[symbol] !== undefined;\n        }\n    },\n    /**\n     * Get macro value defined in shader.\n     * @param  {string} shaderType Can be vertex, fragment or both\n     * @param  {string} symbol\n     */\n    getDefine: function (shaderType, symbol) {\n        switch(shaderType) {\n            case 'vertex':\n                return this.vertexDefines[symbol];\n            case 'fragment':\n                return this.fragmentDefines[symbol];\n        }\n    },\n    /**\n     * Enable a texture, actually it will add a #define macro in the shader code\n     * For example, if texture symbol is diffuseMap, it will add a line `#define DIFFUSEMAP_ENABLED` in the shader code\n     * @param  {string} symbol\n     */\n    enableTexture: function (symbol) {\n        if (Array.isArray(symbol)) {\n            for (var i = 0; i < symbol.length; i++) {\n                this.enableTexture(symbol[i]);\n            }\n            return;\n        }\n\n        var status = this._textureStatus[symbol];\n        if (status) {\n            var isEnabled = status.enabled;\n            if (!isEnabled) {\n                status.enabled = true;\n                this._programKey = '';\n            }\n        }\n    },\n    /**\n     * Enable all textures used in the shader\n     */\n    enableTexturesAll: function () {\n        var textureStatus = this._textureStatus;\n        for (var symbol in textureStatus) {\n            textureStatus[symbol].enabled = true;\n        }\n\n        this._programKey = '';\n    },\n    /**\n     * Disable a texture, it remove a #define macro in the shader\n     * @param  {string} symbol\n     */\n    disableTexture: function (symbol) {\n        if (Array.isArray(symbol)) {\n            for (var i = 0; i < symbol.length; i++) {\n                this.disableTexture(symbol[i]);\n            }\n            return;\n        }\n\n        var status = this._textureStatus[symbol];\n        if (status) {\n            var isDisabled = ! status.enabled;\n            if (!isDisabled) {\n                status.enabled = false;\n                this._programKey = '';\n            }\n        }\n    },\n    /**\n     * Disable all textures used in the shader\n     */\n    disableTexturesAll: function () {\n        var textureStatus = this._textureStatus;\n        for (var symbol in textureStatus) {\n            textureStatus[symbol].enabled = false;\n        }\n\n        this._programKey = '';\n    },\n    /**\n     * If texture of given type is enabled.\n     * @param  {string}  symbol\n     * @return {boolean}\n     */\n    isTextureEnabled: function (symbol) {\n        var textureStatus = this._textureStatus;\n        return !!textureStatus[symbol]\n            && textureStatus[symbol].enabled;\n    },\n\n    /**\n     * Get all enabled textures\n     * @return {string[]}\n     */\n    getEnabledTextures: function () {\n        var enabledTextures = [];\n        var textureStatus = this._textureStatus;\n        for (var symbol in textureStatus) {\n            if (textureStatus[symbol].enabled) {\n                enabledTextures.push(symbol);\n            }\n        }\n        return enabledTextures;\n    },\n\n    /**\n     * Mark defines are updated.\n     */\n    dirtyDefines: function () {\n        this._programKey = '';\n    },\n\n    getProgramKey: function () {\n        if (!this._programKey) {\n            this._programKey = getProgramKey(\n                this.vertexDefines, this.fragmentDefines, this.getEnabledTextures()\n            );\n        }\n        return this._programKey;\n    }\n});\n\nexport default Material;\n","import Renderable from './Renderable';\nimport glenum from './core/glenum';\n\n/**\n * @constructor clay.Mesh\n * @extends clay.Renderable\n */\nvar Mesh = Renderable.extend(/** @lends clay.Mesh# */ {\n    /**\n     * Used when it is a skinned mesh\n     * @type {clay.Skeleton}\n     */\n    skeleton: null,\n    /**\n     * Joints indices Meshes can share the one skeleton instance and each mesh can use one part of joints. Joints indices indicate the index of joint in the skeleton instance\n     * @type {number[]}\n     */\n    joints: null\n\n}, function () {\n    if (!this.joints) {\n        this.joints = [];\n    }\n}, {\n\n    /**\n     * Offset matrix used for multiple skinned mesh clone sharing one skeleton\n     * @type {clay.Matrix4}\n     */\n    offsetMatrix: null,\n\n    isInstancedMesh: function () { return false; },\n\n    isSkinnedMesh: function () {\n        return !!(this.skeleton && this.joints && this.joints.length > 0);\n    },\n\n    clone: function () {\n        var mesh = Renderable.prototype.clone.call(this);\n        mesh.skeleton = this.skeleton;\n        if (this.joints) {\n            mesh.joints = this.joints.slice();\n        }\n        return mesh;\n    }\n});\n\n// Enums\nMesh.POINTS = glenum.POINTS;\nMesh.LINES = glenum.LINES;\nMesh.LINE_LOOP = glenum.LINE_LOOP;\nMesh.LINE_STRIP = glenum.LINE_STRIP;\nMesh.TRIANGLES = glenum.TRIANGLES;\nMesh.TRIANGLE_STRIP = glenum.TRIANGLE_STRIP;\nMesh.TRIANGLE_FAN = glenum.TRIANGLE_FAN;\n\nMesh.BACK = glenum.BACK;\nMesh.FRONT = glenum.FRONT;\nMesh.FRONT_AND_BACK = glenum.FRONT_AND_BACK;\nMesh.CW = glenum.CW;\nMesh.CCW = glenum.CCW;\n\nexport default Mesh;\n","import Base from './core/Base';\nimport Vector3 from './math/Vector3';\nimport Quaternion from './math/Quaternion';\nimport Matrix4 from './math/Matrix4';\nimport mat4 from './glmatrix/mat4';\nimport BoundingBox from './math/BoundingBox';\n\nvar nameId = 0;\n\n/**\n * @constructor clay.Node\n * @extends clay.core.Base\n */\nvar Node = Base.extend(/** @lends clay.Node# */{\n    /**\n     * Scene node name\n     * @type {string}\n     */\n    name: '',\n\n    /**\n     * Position relative to its parent node. aka translation.\n     * @type {clay.Vector3}\n     */\n    position: null,\n\n    /**\n     * Rotation relative to its parent node. Represented by a quaternion\n     * @type {clay.Quaternion}\n     */\n    rotation: null,\n\n    /**\n     * Scale relative to its parent node\n     * @type {clay.Vector3}\n     */\n    scale: null,\n\n    /**\n     * Affine transform matrix relative to its root scene.\n     * @type {clay.Matrix4}\n     */\n    worldTransform: null,\n\n    /**\n     * Affine transform matrix relative to its parent node.\n     * Composited with position, rotation and scale.\n     * @type {clay.Matrix4}\n     */\n    localTransform: null,\n\n    /**\n     * If the local transform is update from SRT(scale, rotation, translation, which is position here) each frame\n     * @type {boolean}\n     */\n    autoUpdateLocalTransform: true,\n\n    /**\n     * Parent of current scene node\n     * @type {?clay.Node}\n     * @private\n     */\n    _parent: null,\n    /**\n     * The root scene mounted. Null if it is a isolated node\n     * @type {?clay.Scene}\n     * @private\n     */\n    _scene: null,\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _needsUpdateWorldTransform: true,\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _inIterating: false,\n\n    // Depth for transparent list sorting\n    __depth: 0\n\n}, function () {\n\n    if (!this.name) {\n        this.name = (this.type || 'NODE') + '_' + (nameId++);\n    }\n\n    if (!this.position) {\n        this.position = new Vector3();\n    }\n    if (!this.rotation) {\n        this.rotation = new Quaternion();\n    }\n    if (!this.scale) {\n        this.scale = new Vector3(1, 1, 1);\n    }\n\n    this.worldTransform = new Matrix4();\n    this.localTransform = new Matrix4();\n\n    this._children = [];\n\n},\n/**@lends clay.Node.prototype. */\n{\n\n    /**\n     * @type {?clay.Vector3}\n     * @instance\n     */\n    target: null,\n    /**\n     * If node and its chilren invisible\n     * @type {boolean}\n     * @instance\n     */\n    invisible: false,\n\n    /**\n     * If Node is a skinned mesh\n     * @return {boolean}\n     */\n    isSkinnedMesh: function () {\n        return false;\n    },\n    /**\n     * Return true if it is a renderable scene node, like Mesh and ParticleSystem\n     * @return {boolean}\n     */\n    isRenderable: function () {\n        return false;\n    },\n\n    /**\n     * Set the name of the scene node\n     * @param {string} name\n     */\n    setName: function (name) {\n        var scene = this._scene;\n        if (scene) {\n            var nodeRepository = scene._nodeRepository;\n            delete nodeRepository[this.name];\n            nodeRepository[name] = this;\n        }\n        this.name = name;\n    },\n\n    /**\n     * Add a child node\n     * @param {clay.Node} node\n     */\n    add: function (node) {\n        var originalParent = node._parent;\n        if (originalParent === this) {\n            return;\n        }\n        if (originalParent) {\n            originalParent.remove(node);\n        }\n        node._parent = this;\n        this._children.push(node);\n\n        var scene = this._scene;\n        if (scene && scene !== node.scene) {\n            node.traverse(this._addSelfToScene, this);\n        }\n        // Mark children needs update transform\n        // In case child are remove and added again after parent moved\n        node._needsUpdateWorldTransform = true;\n    },\n\n    /**\n     * Remove the given child scene node\n     * @param {clay.Node} node\n     */\n    remove: function (node) {\n        var children = this._children;\n        var idx = children.indexOf(node);\n        if (idx < 0) {\n            return;\n        }\n\n        children.splice(idx, 1);\n        node._parent = null;\n\n        if (this._scene) {\n            node.traverse(this._removeSelfFromScene, this);\n        }\n    },\n\n    /**\n     * Remove all children\n     */\n    removeAll: function () {\n        var children = this._children;\n\n        for (var idx = 0; idx < children.length; idx++) {\n            children[idx]._parent = null;\n\n            if (this._scene) {\n                children[idx].traverse(this._removeSelfFromScene, this);\n            }\n        }\n\n        this._children = [];\n    },\n\n    /**\n     * Get the scene mounted\n     * @return {clay.Scene}\n     */\n    getScene: function () {\n        return this._scene;\n    },\n\n    /**\n     * Get parent node\n     * @return {clay.Scene}\n     */\n    getParent: function () {\n        return this._parent;\n    },\n\n    _removeSelfFromScene: function (descendant) {\n        descendant._scene.removeFromScene(descendant);\n        descendant._scene = null;\n    },\n\n    _addSelfToScene: function (descendant) {\n        this._scene.addToScene(descendant);\n        descendant._scene = this._scene;\n    },\n\n    /**\n     * Return true if it is ancestor of the given scene node\n     * @param {clay.Node} node\n     */\n    isAncestor: function (node) {\n        var parent = node._parent;\n        while(parent) {\n            if (parent === this) {\n                return true;\n            }\n            parent = parent._parent;\n        }\n        return false;\n    },\n\n    /**\n     * Get a new created array of all children nodes\n     * @return {clay.Node[]}\n     */\n    children: function () {\n        return this._children.slice();\n    },\n\n    /**\n     * Get child scene node at given index.\n     * @param {number} idx\n     * @return {clay.Node}\n     */\n    childAt: function (idx) {\n        return this._children[idx];\n    },\n\n    /**\n     * Get first child with the given name\n     * @param {string} name\n     * @return {clay.Node}\n     */\n    getChildByName: function (name) {\n        var children = this._children;\n        for (var i = 0; i < children.length; i++) {\n            if (children[i].name === name) {\n                return children[i];\n            }\n        }\n    },\n\n    /**\n     * Get first descendant have the given name\n     * @param {string} name\n     * @return {clay.Node}\n     */\n    getDescendantByName: function (name) {\n        var children = this._children;\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (child.name === name) {\n                return child;\n            } else {\n                var res = child.getDescendantByName(name);\n                if (res) {\n                    return res;\n                }\n            }\n        }\n    },\n\n    /**\n     * Query descendant node by path\n     * @param {string} path\n     * @return {clay.Node}\n     * @example\n     *  node.queryNode('root/parent/child');\n     */\n    queryNode: function (path) {\n        if (!path) {\n            return;\n        }\n        // TODO Name have slash ?\n        var pathArr = path.split('/');\n        var current = this;\n        for (var i = 0; i < pathArr.length; i++) {\n            var name = pathArr[i];\n            // Skip empty\n            if (!name) {\n                continue;\n            }\n            var found = false;\n            var children = current._children;\n            for (var j = 0; j < children.length; j++) {\n                var child = children[j];\n                if (child.name === name) {\n                    current = child;\n                    found = true;\n                    break;\n                }\n            }\n            // Early return if not found\n            if (!found) {\n                return;\n            }\n        }\n\n        return current;\n    },\n\n    /**\n     * Get query path, relative to rootNode(default is scene)\n     * @param {clay.Node} [rootNode]\n     * @return {string}\n     */\n    getPath: function (rootNode) {\n        if (!this._parent) {\n            return '/';\n        }\n\n        var current = this._parent;\n        var path = this.name;\n        while (current._parent) {\n            path = current.name + '/' + path;\n            if (current._parent == rootNode) {\n                break;\n            }\n            current = current._parent;\n        }\n        if (!current._parent && rootNode) {\n            return null;\n        }\n        return path;\n    },\n\n    /**\n     * Depth first traverse all its descendant scene nodes.\n     *\n     * **WARN** Don't do `add`, `remove` operation in the callback during traverse.\n     * @param {Function} callback\n     * @param {Node} [context]\n     */\n    traverse: function (callback, context) {\n        callback.call(context, this);\n        var _children = this._children;\n        for(var i = 0, len = _children.length; i < len; i++) {\n            _children[i].traverse(callback, context);\n        }\n    },\n\n    /**\n     * Traverse all children nodes.\n     *\n     * **WARN** DON'T do `add`, `remove` operation in the callback during iteration.\n     *\n     * @param {Function} callback\n     * @param {Node} [context]\n     */\n    eachChild: function (callback, context) {\n        var _children = this._children;\n        for(var i = 0, len = _children.length; i < len; i++) {\n            var child = _children[i];\n            callback.call(context, child, i);\n        }\n    },\n\n    /**\n     * Set the local transform and decompose to SRT\n     * @param {clay.Matrix4} matrix\n     */\n    setLocalTransform: function (matrix) {\n        mat4.copy(this.localTransform.array, matrix.array);\n        this.decomposeLocalTransform();\n    },\n\n    /**\n     * Decompose the local transform to SRT\n     */\n    decomposeLocalTransform: function (keepScale) {\n        var scale = !keepScale ? this.scale: null;\n        this.localTransform.decomposeMatrix(scale, this.rotation, this.position);\n    },\n\n    /**\n     * Set the world transform and decompose to SRT\n     * @param {clay.Matrix4} matrix\n     */\n    setWorldTransform: function (matrix) {\n        mat4.copy(this.worldTransform.array, matrix.array);\n        this.decomposeWorldTransform();\n    },\n\n    /**\n     * Decompose the world transform to SRT\n     * @function\n     */\n    decomposeWorldTransform: (function () {\n\n        var tmp = mat4.create();\n\n        return function (keepScale) {\n            var localTransform = this.localTransform;\n            var worldTransform = this.worldTransform;\n            // Assume world transform is updated\n            if (this._parent) {\n                mat4.invert(tmp, this._parent.worldTransform.array);\n                mat4.multiply(localTransform.array, tmp, worldTransform.array);\n            } else {\n                mat4.copy(localTransform.array, worldTransform.array);\n            }\n            var scale = !keepScale ? this.scale: null;\n            localTransform.decomposeMatrix(scale, this.rotation, this.position);\n        };\n    })(),\n\n    transformNeedsUpdate: function () {\n        return this.position._dirty\n            || this.rotation._dirty\n            || this.scale._dirty;\n    },\n\n    /**\n     * Update local transform from SRT\n     * Notice that local transform will not be updated if _dirty mark of position, rotation, scale is all false\n     */\n    updateLocalTransform: function () {\n        var position = this.position;\n        var rotation = this.rotation;\n        var scale = this.scale;\n\n        if (this.transformNeedsUpdate()) {\n            var m = this.localTransform.array;\n\n            // Transform order, scale->rotation->position\n            mat4.fromRotationTranslation(m, rotation.array, position.array);\n\n            mat4.scale(m, m, scale.array);\n\n            rotation._dirty = false;\n            scale._dirty = false;\n            position._dirty = false;\n\n            this._needsUpdateWorldTransform = true;\n        }\n    },\n\n    /**\n     * Update world transform, assume its parent world transform have been updated\n     * @private\n     */\n    _updateWorldTransformTopDown: function () {\n        var localTransform = this.localTransform.array;\n        var worldTransform = this.worldTransform.array;\n        if (this._parent) {\n            mat4.multiplyAffine(\n                worldTransform,\n                this._parent.worldTransform.array,\n                localTransform\n            );\n        }\n        else {\n            mat4.copy(worldTransform, localTransform);\n        }\n    },\n\n    /**\n     * Update world transform before whole scene is updated.\n     */\n    updateWorldTransform: function () {\n        // Find the root node which transform needs update;\n        var rootNodeIsDirty = this;\n        while (rootNodeIsDirty && rootNodeIsDirty.getParent()\n            && rootNodeIsDirty.getParent().transformNeedsUpdate()\n        ) {\n            rootNodeIsDirty = rootNodeIsDirty.getParent();\n        }\n        rootNodeIsDirty.update();\n    },\n\n    /**\n     * Update local transform and world transform recursively\n     * @param {boolean} forceUpdateWorld\n     */\n    update: function (forceUpdateWorld) {\n        if (this.autoUpdateLocalTransform) {\n            this.updateLocalTransform();\n        }\n        else {\n            // Transform is manually setted\n            forceUpdateWorld = true;\n        }\n\n        if (forceUpdateWorld || this._needsUpdateWorldTransform) {\n            this._updateWorldTransformTopDown();\n            forceUpdateWorld = true;\n            this._needsUpdateWorldTransform = false;\n        }\n\n        var children = this._children;\n        for(var i = 0, len = children.length; i < len; i++) {\n            children[i].update(forceUpdateWorld);\n        }\n    },\n\n    /**\n     * Get bounding box of node\n     * @param  {Function} [filter]\n     * @param  {clay.BoundingBox} [out]\n     * @return {clay.BoundingBox}\n     */\n    // TODO Skinning\n    getBoundingBox: (function () {\n        function defaultFilter (el) {\n            return !el.invisible && el.geometry;\n        }\n        var tmpBBox = new BoundingBox();\n        var tmpMat4 = new Matrix4();\n        var invWorldTransform = new Matrix4();\n        return function (filter, out) {\n            out = out || new BoundingBox();\n            filter = filter || defaultFilter;\n\n            if (this._parent) {\n                Matrix4.invert(invWorldTransform, this._parent.worldTransform);\n            }\n            else {\n                Matrix4.identity(invWorldTransform);\n            }\n\n            this.traverse(function (mesh) {\n                if (mesh.geometry && mesh.geometry.boundingBox) {\n                    tmpBBox.copy(mesh.geometry.boundingBox);\n                    Matrix4.multiply(tmpMat4, invWorldTransform, mesh.worldTransform);\n                    tmpBBox.applyTransform(tmpMat4);\n                    out.union(tmpBBox);\n                }\n            }, this, defaultFilter);\n\n            return out;\n        };\n    })(),\n\n    /**\n     * Get world position, extracted from world transform\n     * @param  {clay.Vector3} [out]\n     * @return {clay.Vector3}\n     */\n    getWorldPosition: function (out) {\n        // PENDING\n        if (this.transformNeedsUpdate()) {\n            this.updateWorldTransform();\n        }\n        var m = this.worldTransform.array;\n        if (out) {\n            var arr = out.array;\n            arr[0] = m[12];\n            arr[1] = m[13];\n            arr[2] = m[14];\n            return out;\n        }\n        else {\n            return new Vector3(m[12], m[13], m[14]);\n        }\n    },\n\n    /**\n     * Clone a new node\n     * @return {Node}\n     */\n    clone: function () {\n        var node = new this.constructor();\n\n        var children = this._children;\n\n        node.setName(this.name);\n        node.position.copy(this.position);\n        node.rotation.copy(this.rotation);\n        node.scale.copy(this.scale);\n\n        for (var i = 0; i < children.length; i++) {\n            node.add(children[i].clone());\n        }\n\n        return node;\n    },\n\n    /**\n     * Rotate the node around a axis by angle degrees, axis passes through point\n     * @param {clay.Vector3} point Center point\n     * @param {clay.Vector3} axis  Center axis\n     * @param {number}       angle Rotation angle\n     * @see http://docs.unity3d.com/Documentation/ScriptReference/Transform.RotateAround.html\n     * @function\n     */\n    rotateAround: (function () {\n        var v = new Vector3();\n        var RTMatrix = new Matrix4();\n\n        // TODO improve performance\n        return function (point, axis, angle) {\n\n            v.copy(this.position).subtract(point);\n\n            var localTransform = this.localTransform;\n            localTransform.identity();\n            // parent node\n            localTransform.translate(point);\n            localTransform.rotate(angle, axis);\n\n            RTMatrix.fromRotationTranslation(this.rotation, v);\n            localTransform.multiply(RTMatrix);\n            localTransform.scale(this.scale);\n\n            this.decomposeLocalTransform();\n            this._needsUpdateWorldTransform = true;\n        };\n    })(),\n\n    /**\n     * @param {clay.Vector3} target\n     * @param {clay.Vector3} [up]\n     * @see http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml\n     * @function\n     */\n    lookAt: (function () {\n        var m = new Matrix4();\n        return function (target, up) {\n            m.lookAt(this.position, target, up || this.localTransform.y).invert();\n            this.setLocalTransform(m);\n\n            this.target = target;\n        };\n    })()\n});\n\nexport default Node;\n"],"names":["Camera","Node","extend","projectionMatrix","Matrix4","invProjectionMatrix","viewMatrix","frustum","Frustum","this","update","force","prototype","call","invert","worldTransform","updateProjectionMatrix","setFromProjection","setViewMatrix","copy","decomposeWorldTransform","decomposeProjectionMatrix","setProjectionMatrix","castRay","v4","vec4","create","ndc","out","ray","undefined","Ray","x","array","y","set","transformMat4","vec3","scale","origin","sub","direction","normalize","_dirty","KEY_FRAMEBUFFER","KEY_RENDERBUFFER","KEY_RENDERBUFFER_WIDTH","KEY_RENDERBUFFER_HEIGHT","KEY_RENDERBUFFER_ATTACHED","KEY_DEPTHTEXTURE_ATTACHED","GL_FRAMEBUFFER","glenum","FRAMEBUFFER","GL_RENDERBUFFER","RENDERBUFFER","GL_DEPTH_ATTACHMENT","DEPTH_ATTACHMENT","GL_COLOR_ATTACHMENT0","COLOR_ATTACHMENT0","FrameBuffer","Base","depthBuffer","viewport","_width","_height","_textures","_boundRenderer","_cache","Cache","getTextureWidth","getTextureHeight","bind","renderer","__currentFrameBuffer","console","warn","_gl","gl","bindFramebuffer","_getFrameBufferGL","cache","put","width","height","hasTextureAttached","attachment","obj","texture","_doAttach","target","error","setViewport","attachedTextures","get","_doDetach","miss","createRenderbuffer","renderbuffer","bindRenderbuffer","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","unbind","use","__uid__","updateMipmap","NPOT","useMipmap","minFilter","Texture","LINEAR_MIPMAP_LINEAR","textureType","TEXTURE_CUBE_MAP","TEXTURE_2D","bindTexture","getWebGLTexture","generateMipmap","checkStatus","checkFramebufferStatus","createFramebuffer","attach","Error","boundRenderer","previous","canAttach","webglTexture","DEPTH_STENCIL_ATTACHMENT","extension","getGLExtension","format","DEPTH_COMPONENT","DEPTH_STENCIL","deleteRenderbuffer","framebufferTexture2D","detach","dispose","renderBuffer","frameBuffer","deleteFramebuffer","deleteContext","STENCIL_ATTACHMENT","getArrayCtorByType","type","vendor","Int8Array","Uint8Array","Int16Array","Uint16Array","Float32Array","makeAttrKey","attrName","Attribute","name","size","semantic","value","idx","source","arr","val","idx3","idx4","AttributeBuffer","buffer","symbol","needsRemove","IndicesBuffer","count","init","nVertex","length","ArrayConstructor","fromArray","n","i","j","clone","copyValue","ret","GeometryBase","attributes","indices","dynamic","_enabledAttributes","__used","_attributeList","Object","keys","__vaoCache","mainAttribute","pick","pickByRay","dirty","enabledAttributes","getEnabledAttributes","dirtyAttribute","dirtyIndices","dirtyAll","getTriangleIndices","triangleCount","setTriangleIndices","isUseIndices","initIndicesFromArray","vertexCount","Uint32Array","createAttribute","attrib","removeAttribute","push","attributeList","indexOf","splice","getAttribute","result","getBufferChunks","isAttributesDirty","isDirty","isIndicesDirty","_updateBuffer","fresh","chunks","firstUpdate","attributeBuffers","indicesBuffer","chunk","attributeBufferMap","k","bufferInfo","attribute","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","DYNAMIC_DRAW","STATIC_DRAW","deleteBuffer","ELEMENT_ARRAY_BUFFER","c","attribs","vaoExt","id","vao","deleteVertexArrayOES","defineProperty","enumerable","STREAM_DRAW","vec3Create","vec3Add","add","vec3Set","Geometry","position","texcoord0","texcoord1","normal","tangent","color","weight","joint","barycentric","boundingBox","updateBoundingBox","bbox","BoundingBox","posArr","min","max","minArr","maxArr","z","generateVertexNormals","positions","normals","i1","i2","i3","p1","p2","p3","v21","v32","len","f","cross","generateFaceNormals","isUniqueVertex","generateUniqueVertex","generateTangents","texcoords","tangents","tan1","tan2","sdir","tdir","st1s","st2s","st3s","st1t","st2t","st3t","p1x","p2x","p3x","p1y","p2y","p3y","p1z","p2z","p3z","x1","x2","y1","y2","z1","z2","s1","s2","t1","t2","r","tmp","nCrossT","t","dot","attributeNameList","oldAttrValues","a","cursor","ii","generateBarycentric","applyTransform","matrix","inverseTransposeMatrix","mat4","transpose","vec3TransformMat4","vec3ForEach","forEach","Shader","lightShader","Light","intensity","castShadow","shadowResolution","group","light","Array","slice","parseColor","colorUtil","parseToFloat","programKeyCache","getDefineCode","defines","defineKeys","sort","defineStr","key","toString","join","getProgramKey","vertexDefines","fragmentDefines","enabledTextures","util","genGUID","Material","depthTest","depthMask","transparent","blend","autoUpdateTextureStatus","uniforms","_textureStatus","_enabledUniforms","shader","attachShader","precision","setUniform","uniform","enableTexture","disableTexture","setUniforms","isUniformEnabled","getEnabledUniforms","getTextureUniforms","_textureUniforms","keepStatus","originalUniforms","createUniforms","filter","uniformName","originalVertexDefines","originalFragmentDefines","defaults","textureStatus","textures","shaderType","enabled","_programKey","material","constructor","getEnabledTextures","define","arguments","undefine","isDefined","getDefine","isArray","status","isEnabled","enableTexturesAll","isDisabled","disableTexturesAll","isTextureEnabled","dirtyDefines","Mesh","Renderable","skeleton","joints","offsetMatrix","isInstancedMesh","isSkinnedMesh","mesh","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","BACK","FRONT","FRONT_AND_BACK","CW","CCW","nameId","rotation","localTransform","autoUpdateLocalTransform","_parent","_scene","_needsUpdateWorldTransform","_inIterating","__depth","Vector3","Quaternion","_children","invisible","isRenderable","setName","scene","nodeRepository","_nodeRepository","node","originalParent","remove","traverse","_addSelfToScene","children","_removeSelfFromScene","removeAll","getScene","getParent","descendant","removeFromScene","addToScene","isAncestor","parent","childAt","getChildByName","getDescendantByName","child","res","queryNode","path","pathArr","split","current","found","getPath","rootNode","callback","context","eachChild","setLocalTransform","decomposeLocalTransform","keepScale","decomposeMatrix","setWorldTransform","multiply","transformNeedsUpdate","updateLocalTransform","m","fromRotationTranslation","_updateWorldTransformTopDown","multiplyAffine","updateWorldTransform","rootNodeIsDirty","forceUpdateWorld","getBoundingBox","defaultFilter","el","geometry","tmpBBox","tmpMat4","invWorldTransform","identity","union","getWorldPosition","rotateAround","v","RTMatrix","point","axis","angle","subtract","translate","rotate","lookAt","up"],"sourceRoot":""}