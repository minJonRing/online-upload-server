{"version":3,"file":"static/client/js/chunk-vendors-e8fb0117.b691741b.js","mappings":"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","sources":["webpack://d1/./node_modules/echarts/lib/data/helper/SeriesDataSchema.js","webpack://d1/./node_modules/echarts/lib/data/helper/createDimensions.js","webpack://d1/./node_modules/echarts/lib/data/helper/dataProvider.js","webpack://d1/./node_modules/echarts/lib/data/helper/dataStackHelper.js","webpack://d1/./node_modules/echarts/lib/data/helper/dataValueHelper.js","webpack://d1/./node_modules/echarts/lib/data/helper/dimensionHelper.js","webpack://d1/./node_modules/echarts/lib/data/helper/linkList.js","webpack://d1/./node_modules/echarts/lib/data/helper/linkSeriesData.js","webpack://d1/./node_modules/echarts/lib/data/helper/sourceHelper.js","webpack://d1/./node_modules/echarts/lib/data/helper/sourceManager.js","webpack://d1/./node_modules/echarts/lib/data/helper/transform.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { createHashMap, isObject, retrieve2 } from 'zrender/lib/core/util.js';\nimport { makeInner } from '../../util/model.js';\nimport { shouldRetrieveDataByName } from '../Source.js';\nvar inner = makeInner();\nvar dimTypeShort = {\n  float: 'f',\n  int: 'i',\n  ordinal: 'o',\n  number: 'n',\n  time: 't'\n};\n/**\n * Represents the dimension requirement of a series.\n *\n * NOTICE:\n * When there are too many dimensions in dataset and many series, only the used dimensions\n * (i.e., used by coord sys and declared in `series.encode`) are add to `dimensionDefineList`.\n * But users may query data by other unused dimension names.\n * In this case, users can only query data if and only if they have defined dimension names\n * via ec option, so we provide `getDimensionIndexFromSource`, which only query them from\n * `source` dimensions.\n */\nvar SeriesDataSchema = /** @class */function () {\n  function SeriesDataSchema(opt) {\n    this.dimensions = opt.dimensions;\n    this._dimOmitted = opt.dimensionOmitted;\n    this.source = opt.source;\n    this._fullDimCount = opt.fullDimensionCount;\n    this._updateDimOmitted(opt.dimensionOmitted);\n  }\n  SeriesDataSchema.prototype.isDimensionOmitted = function () {\n    return this._dimOmitted;\n  };\n  SeriesDataSchema.prototype._updateDimOmitted = function (dimensionOmitted) {\n    this._dimOmitted = dimensionOmitted;\n    if (!dimensionOmitted) {\n      return;\n    }\n    if (!this._dimNameMap) {\n      this._dimNameMap = ensureSourceDimNameMap(this.source);\n    }\n  };\n  /**\n   * @caution Can only be used when `dimensionOmitted: true`.\n   *\n   * Get index by user defined dimension name (i.e., not internal generate name).\n   * That is, get index from `dimensionsDefine`.\n   * If no `dimensionsDefine`, or no name get, return -1.\n   */\n  SeriesDataSchema.prototype.getSourceDimensionIndex = function (dimName) {\n    return retrieve2(this._dimNameMap.get(dimName), -1);\n  };\n  /**\n   * @caution Can only be used when `dimensionOmitted: true`.\n   *\n   * Notice: may return `null`/`undefined` if user not specify dimension names.\n   */\n  SeriesDataSchema.prototype.getSourceDimension = function (dimIndex) {\n    var dimensionsDefine = this.source.dimensionsDefine;\n    if (dimensionsDefine) {\n      return dimensionsDefine[dimIndex];\n    }\n  };\n  SeriesDataSchema.prototype.makeStoreSchema = function () {\n    var dimCount = this._fullDimCount;\n    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);\n    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);\n    // If source don't have dimensions or series don't omit unsed dimensions.\n    // Generate from seriesDimList directly\n    var dimHash = '';\n    var dims = [];\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {\n      var property = void 0;\n      var type = void 0;\n      var ordinalMeta = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx];\n      // The list has been sorted by `storeDimIndex` asc.\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        property = willRetrieveDataByName ? seriesDimDef.name : null;\n        type = seriesDimDef.type;\n        ordinalMeta = seriesDimDef.ordinalMeta;\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n        if (sourceDimDef) {\n          property = willRetrieveDataByName ? sourceDimDef.name : null;\n          type = sourceDimDef.type;\n        }\n      }\n      dims.push({\n        property: property,\n        type: type,\n        ordinalMeta: ordinalMeta\n      });\n      // If retrieving data by index,\n      //   use <index, type, ordinalMeta> to determine whether data can be shared.\n      //   (Because in this case there might be no dimension name defined in dataset, but indices always exists).\n      //   (Indices are always 0, 1, 2, ..., so we can ignore them to shorten the hash).\n      // Otherwise if retrieving data by property name (like `data: [{aa: 123, bb: 765}, ...]`),\n      //   use <property, type, ordinalMeta> in hash.\n      if (willRetrieveDataByName && property != null\n      // For data stack, we have make sure each series has its own dim on this store.\n      // So we do not add property to hash to make sure they can share this store.\n      && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {\n        dimHash += makeHashStrict\n        // Use escape character '`' in case that property name contains '$'.\n        ? property.replace(/\\`/g, '`1').replace(/\\$/g, '`2')\n        // For better performance, when there are large dimensions, tolerant this defects that hardly meet.\n        : property;\n      }\n      dimHash += '$';\n      dimHash += dimTypeShort[type] || 'f';\n      if (ordinalMeta) {\n        dimHash += ordinalMeta.uid;\n      }\n      dimHash += '$';\n    }\n    // Source from endpoint(usually series) will be read differently\n    // when seriesLayoutBy or startIndex(which is affected by sourceHeader) are different.\n    // So we use this three props as key.\n    var source = this.source;\n    var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join('$$');\n    return {\n      dimensions: dims,\n      hash: hash\n    };\n  };\n  SeriesDataSchema.prototype.makeOutputDimensionNames = function () {\n    var result = [];\n    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {\n      var name_1 = void 0;\n      var seriesDimDef = this.dimensions[seriesDimIdx];\n      // The list has been sorted by `storeDimIndex` asc.\n      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {\n        if (!seriesDimDef.isCalculationCoord) {\n          name_1 = seriesDimDef.name;\n        }\n        seriesDimIdx++;\n      } else {\n        var sourceDimDef = this.getSourceDimension(fullDimIdx);\n        if (sourceDimDef) {\n          name_1 = sourceDimDef.name;\n        }\n      }\n      result.push(name_1);\n    }\n    return result;\n  };\n  SeriesDataSchema.prototype.appendCalculationDimension = function (dimDef) {\n    this.dimensions.push(dimDef);\n    dimDef.isCalculationCoord = true;\n    this._fullDimCount++;\n    // If append dimension on a data store, consider the store\n    // might be shared by different series, series dimensions not\n    // really map to store dimensions.\n    this._updateDimOmitted(true);\n  };\n  return SeriesDataSchema;\n}();\nexport { SeriesDataSchema };\nexport function isSeriesDataSchema(schema) {\n  return schema instanceof SeriesDataSchema;\n}\nexport function createDimNameMap(dimsDef) {\n  var dataDimNameMap = createHashMap();\n  for (var i = 0; i < (dimsDef || []).length; i++) {\n    var dimDefItemRaw = dimsDef[i];\n    var userDimName = isObject(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;\n    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n      dataDimNameMap.set(userDimName, i);\n    }\n  }\n  return dataDimNameMap;\n}\nexport function ensureSourceDimNameMap(source) {\n  var innerSource = inner(source);\n  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));\n}\nexport function shouldOmitUnusedDimensions(dimCount) {\n  return dimCount > 30;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { VISUAL_DIMENSIONS } from '../../util/types.js';\nimport SeriesDimensionDefine from '../SeriesDimensionDefine.js';\nimport { createHashMap, defaults, each, extend, isObject, isString } from 'zrender/lib/core/util.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { CtorInt32Array } from '../DataStore.js';\nimport { normalizeToArray } from '../../util/model.js';\nimport { BE_ORDINAL, guessOrdinal } from './sourceHelper.js';\nimport { createDimNameMap, ensureSourceDimNameMap, SeriesDataSchema, shouldOmitUnusedDimensions } from './SeriesDataSchema.js';\n/**\n * For outside usage compat (like echarts-gl are using it).\n */\nexport function createDimensions(source, opt) {\n  return prepareSeriesDataSchema(source, opt).dimensions;\n}\n/**\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `coordDimensions`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @return The results are always sorted by `storeDimIndex` asc.\n */\nexport default function prepareSeriesDataSchema(\n// TODO: TYPE completeDimensions type\nsource, opt) {\n  if (!isSourceInstance(source)) {\n    source = createSourceFromSeriesDataOption(source);\n  }\n  opt = opt || {};\n  var sysDims = opt.coordDimensions || [];\n  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];\n  var coordDimNameMap = createHashMap();\n  var resultList = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);\n  // Try to ignore unused dimensions if sharing a high dimension datastore\n  // 30 is an experience value.\n  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);\n  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;\n  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);\n  var encodeDef = opt.encodeDefine;\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n  var encodeDefMap = createHashMap(encodeDef);\n  var indicesMap = new CtorInt32Array(dimCount);\n  for (var i = 0; i < indicesMap.length; i++) {\n    indicesMap[i] = -1;\n  }\n  function getResultItem(dimIdx) {\n    var idx = indicesMap[dimIdx];\n    if (idx < 0) {\n      var dimDefItemRaw = dimsDef[dimIdx];\n      var dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {\n        name: dimDefItemRaw\n      };\n      var resultItem = new SeriesDimensionDefine();\n      var userDimName = dimDefItem.name;\n      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {\n        // Only if `series.dimensions` is defined in option\n        // displayName, will be set, and dimension will be displayed vertically in\n        // tooltip by default.\n        resultItem.name = resultItem.displayName = userDimName;\n      }\n      dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      var newIdx = resultList.length;\n      indicesMap[dimIdx] = newIdx;\n      resultItem.storeDimIndex = dimIdx;\n      resultList.push(resultItem);\n      return resultItem;\n    }\n    return resultList[idx];\n  }\n  if (!omitUnusedDimensions) {\n    for (var i = 0; i < dimCount; i++) {\n      getResultItem(i);\n    }\n  }\n  // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = normalizeToArray(dataDimsRaw).slice();\n    // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    each(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(getResultItem(resultDimIdx), coordDim, idx);\n      }\n    });\n  });\n  // Apply templates and default order from `sysDims`.\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n    if (isString(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = extend({}, sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta;\n      // `coordDimIndex` should not be set directly.\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n    var dataDims = encodeDefMap.get(coordDim);\n    // negative resultDimIdx means no need to mapping.\n    if (dataDims === false) {\n      return;\n    }\n    dataDims = normalizeToArray(dataDims);\n    // dimensions provides default dim sequences.\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {\n          availDimIdx++;\n        }\n        availDimIdx < dimCount && dataDims.push(availDimIdx++);\n      }\n    }\n    // Apply templates.\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = getResultItem(resultDimIdx);\n      // Coordinate system has a higher priority on dim type than source.\n      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {\n        resultItem.type = sysDimItem.type;\n      }\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      }\n      // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  }\n  // Make sure the first extra dim is 'value'.\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value';\n  function ifNoNameFillWithCoordName(resultItem) {\n    if (resultItem.name == null) {\n      // Duplication will be removed in the next step.\n      resultItem.name = resultItem.coordDim;\n    }\n  }\n  // Set dim `name` and other `coordDim` and other props.\n  if (!omitUnusedDimensions) {\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n      var resultItem = getResultItem(resultDimIdx);\n      var coordDim = resultItem.coordDim;\n      if (coordDim == null) {\n        // TODO no need to generate coordDim for isExtraCoord?\n        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);\n        resultItem.coordDimIndex = 0;\n        // Series specified generateCoord is using out.\n        if (!generateCoord || generateCoordCount <= 0) {\n          resultItem.isExtraCoord = true;\n        }\n        generateCoordCount--;\n      }\n      ifNoNameFillWithCoordName(resultItem);\n      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must\n      // Consider the case:\n      // {\n      //    dataset: {source: [\n      //        ['2001', 123],\n      //        ['2002', 456],\n      //        ...\n      //        ['The others', 987],\n      //    ]},\n      //    series: {type: 'pie'}\n      // }\n      // The first column should better be treated as a \"ordinal\" although it\n      // might not be detected as an \"ordinal\" by `guessOrdinal`.\n      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n        resultItem.type = 'ordinal';\n      }\n    }\n  } else {\n    each(resultList, function (resultItem) {\n      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?\n      ifNoNameFillWithCoordName(resultItem);\n    });\n    // Sort dimensions: there are some rule that use the last dim as label,\n    // and for some latter travel process easier.\n    resultList.sort(function (item0, item1) {\n      return item0.storeDimIndex - item1.storeDimIndex;\n    });\n  }\n  removeDuplication(resultList);\n  return new SeriesDataSchema({\n    source: source,\n    dimensions: resultList,\n    fullDimensionCount: dimCount,\n    dimensionOmitted: omitUnusedDimensions\n  });\n}\nfunction removeDuplication(result) {\n  var duplicationMap = createHashMap();\n  for (var i = 0; i < result.length; i++) {\n    var dim = result[i];\n    var dimOriginalName = dim.name;\n    var count = duplicationMap.get(dimOriginalName) || 0;\n    if (count > 0) {\n      // Starts from 0.\n      dim.name = dimOriginalName + (count - 1);\n    }\n    count++;\n    duplicationMap.set(dimOriginalName, count);\n  }\n}\n// ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calculate bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in data store?\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  each(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\nfunction genCoordDimName(name, map, fromZero) {\n  if (fromZero || map.hasKey(name)) {\n    var i = 0;\n    while (map.hasKey(name + i)) {\n      i++;\n    }\n    name += i;\n  }\n  map.set(name, true);\n  return name;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _a, _b, _c;\n// TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\nimport { isTypedArray, extend, assert, each, isObject, bind } from 'zrender/lib/core/util.js';\nimport { getDataItemValue } from '../../util/model.js';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source.js';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SERIES_LAYOUT_BY_COLUMN, SERIES_LAYOUT_BY_ROW } from '../../util/types.js';\nvar providerMethods;\nvar mountMethods;\n/**\n * If normal array used, mutable chunk size is supported.\n * If typed array used, chunk size must be fixed.\n */\nvar DefaultDataProvider = /** @class */function () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;\n    // declare source is Source;\n    this._source = source;\n    var data = this._data = source.data;\n    // Typed array. TODO IE10+?\n    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n    mountMethods(this, data, source);\n  }\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n  DefaultDataProvider.prototype.clean = function () {};\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n  DefaultDataProvider.internalField = function () {\n    var _a;\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n      if (process.env.NODE_ENV !== 'production') {\n        assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n      extend(provider, methods);\n      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n      return out;\n    };\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n    providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n  return DefaultDataProvider;\n}();\nexport { DefaultDataProvider };\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\nvar rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n  return item;\n}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimName == null) {\n        throw new Error();\n      }\n    }\n    var col = rawData[dimName];\n    item[i] = col ? col[idx] : null;\n  }\n  return item;\n}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\nexport function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n  return method;\n}\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\nvar rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n  if (process.env.NODE_ENV !== 'production') {\n    if (dimName == null) {\n      throw new Error();\n    }\n  }\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\nexport function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n  return method;\n}\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\nvar rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = getDataItemValue(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\nexport function getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get value on \"' + sourceFormat + '\".');\n  }\n  return method;\n}\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n}\n// ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\nexport function retrieveRawValue(data, dataIndex,\n// If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  }\n  // Consider data may be not persistent.\n  var dataItem = data.getRawDataItem(dataIndex);\n  if (dataItem == null) {\n    return;\n  }\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n      result = getDataItemValue(dataItem);\n    }\n    return result;\n  }\n}\n/**\n * Compatible with some cases (in pie, map) like:\n * data: [{name: 'xx', value: 5, selected: true}, ...]\n * where only sourceFormat is 'original' and 'objectRows' supported.\n *\n * // TODO\n * Supported detail options in data item when using 'arrayRows'.\n *\n * @param data\n * @param dataIndex\n * @param attr like 'selected'\n */\nexport function retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n  var dataItem = data.getRawDataItem(dataIndex);\n  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {\n    dataItem = null;\n  }\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, isString } from 'zrender/lib/core/util.js';\nimport { isSeriesDataSchema } from './SeriesDataSchema.js';\n/**\n * Note that it is too complicated to support 3d stack by value\n * (have to create two-dimension inverted index), so in 3d case\n * we just support that stacked by index.\n *\n * @param seriesModel\n * @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.\n *        The input will be modified.\n * @param opt\n * @param opt.stackedCoordDimension Specify a coord dimension if needed.\n * @param opt.byIndex=false\n * @return calculationInfo\n * {\n *     stackedDimension: string\n *     stackedByDimension: string\n *     isStackedByIndex: boolean\n *     stackedOverDimension: string\n *     stackResultDimension: string\n * }\n */\nexport function enableDataStack(seriesModel, dimensionsInput, opt) {\n  opt = opt || {};\n  var byIndex = opt.byIndex;\n  var stackedCoordDimension = opt.stackedCoordDimension;\n  var dimensionDefineList;\n  var schema;\n  var store;\n  if (isLegacyDimensionsInput(dimensionsInput)) {\n    dimensionDefineList = dimensionsInput;\n  } else {\n    schema = dimensionsInput.schema;\n    dimensionDefineList = schema.dimensions;\n    store = dimensionsInput.store;\n  }\n  // Compatibal: when `stack` is set as '', do not stack.\n  var mayStack = !!(seriesModel && seriesModel.get('stack'));\n  var stackedByDimInfo;\n  var stackedDimInfo;\n  var stackResultDimension;\n  var stackedOverDimension;\n  each(dimensionDefineList, function (dimensionInfo, index) {\n    if (isString(dimensionInfo)) {\n      dimensionDefineList[index] = dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n    if (mayStack && !dimensionInfo.isExtraCoord) {\n      // Find the first ordinal dimension as the stackedByDimInfo.\n      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {\n        stackedByDimInfo = dimensionInfo;\n      }\n      // Find the first stackable dimension as the stackedDimInfo.\n      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {\n        stackedDimInfo = dimensionInfo;\n      }\n    }\n  });\n  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {\n    // Compatible with previous design, value axis (time axis) only stack by index.\n    // It may make sense if the user provides elaborately constructed data.\n    byIndex = true;\n  }\n  // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.\n  // That put stack logic in List is for using conveniently in echarts extensions, but it\n  // might not be a good way.\n  if (stackedDimInfo) {\n    // Use a weird name that not duplicated with other names.\n    // Also need to use seriesModel.id as postfix because different\n    // series may share same data store. The stack dimension needs to be distinguished.\n    stackResultDimension = '__\\0ecstackresult_' + seriesModel.id;\n    stackedOverDimension = '__\\0ecstackedover_' + seriesModel.id;\n    // Create inverted index to fast query index by value.\n    if (stackedByDimInfo) {\n      stackedByDimInfo.createInvertedIndices = true;\n    }\n    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;\n    var stackedDimType = stackedDimInfo.type;\n    var stackedDimCoordIndex_1 = 0;\n    each(dimensionDefineList, function (dimensionInfo) {\n      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {\n        stackedDimCoordIndex_1++;\n      }\n    });\n    var stackedOverDimensionDefine = {\n      name: stackResultDimension,\n      coordDim: stackedDimCoordDim_1,\n      coordDimIndex: stackedDimCoordIndex_1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length\n    };\n    var stackResultDimensionDefine = {\n      name: stackedOverDimension,\n      // This dimension contains stack base (generally, 0), so do not set it as\n      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.\n      coordDim: stackedOverDimension,\n      coordDimIndex: stackedDimCoordIndex_1 + 1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length + 1\n    };\n    if (schema) {\n      if (store) {\n        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);\n        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);\n      }\n      schema.appendCalculationDimension(stackedOverDimensionDefine);\n      schema.appendCalculationDimension(stackResultDimensionDefine);\n    } else {\n      dimensionDefineList.push(stackedOverDimensionDefine);\n      dimensionDefineList.push(stackResultDimensionDefine);\n    }\n  }\n  return {\n    stackedDimension: stackedDimInfo && stackedDimInfo.name,\n    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,\n    isStackedByIndex: byIndex,\n    stackedOverDimension: stackedOverDimension,\n    stackResultDimension: stackResultDimension\n  };\n}\nfunction isLegacyDimensionsInput(dimensionsInput) {\n  return !isSeriesDataSchema(dimensionsInput.schema);\n}\nexport function isDimensionStacked(data, stackedDim) {\n  // Each single series only maps to one pair of axis. So we do not need to\n  // check stackByDim, whatever stacked by a dimension or stacked by index.\n  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension');\n}\nexport function getStackedDimension(data, targetDim) {\n  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { parseDate, numericToNumber } from '../../util/number.js';\nimport { createHashMap, trim, hasOwn, isString, isNumber } from 'zrender/lib/core/util.js';\nimport { throwError } from '../../util/log.js';\n/**\n * Convert raw the value in to inner value in List.\n *\n * [Performance sensitive]\n *\n * [Caution]: this is the key logic of user value parser.\n * For backward compatibility, do not modify it until you have to!\n */\nexport function parseDataValue(value,\n// For high performance, do not omit the second param.\nopt) {\n  // Performance sensitive.\n  var dimType = opt && opt.type;\n  if (dimType === 'ordinal') {\n    // If given value is a category string\n    return value;\n  }\n  if (dimType === 'time'\n  // spead up when using timestamp\n  && !isNumber(value) && value != null && value !== '-') {\n    value = +parseDate(value);\n  }\n  // dimType defaults 'number'.\n  // If dimType is not ordinal and value is null or undefined or NaN or '-',\n  // parse to NaN.\n  // number-like string (like ' 123 ') can be converted to a number.\n  // where null/undefined or other string will be converted to NaN.\n  return value == null || value === '' ? NaN\n  // If string (like '-'), using '+' parse to NaN\n  // If object, also parse to NaN\n  : Number(value);\n}\n;\nvar valueParserMap = createHashMap({\n  'number': function (val) {\n    // Do not use `numericToNumber` here. We have `numericToNumber` by default.\n    // Here the number parser can have loose rule:\n    // enable to cut suffix: \"120px\" => 120, \"14%\" => 14.\n    return parseFloat(val);\n  },\n  'time': function (val) {\n    // return timestamp.\n    return +parseDate(val);\n  },\n  'trim': function (val) {\n    return isString(val) ? trim(val) : val;\n  }\n});\nexport function getRawValueParser(type) {\n  return valueParserMap.get(type);\n}\nvar ORDER_COMPARISON_OP_MAP = {\n  lt: function (lval, rval) {\n    return lval < rval;\n  },\n  lte: function (lval, rval) {\n    return lval <= rval;\n  },\n  gt: function (lval, rval) {\n    return lval > rval;\n  },\n  gte: function (lval, rval) {\n    return lval >= rval;\n  }\n};\nvar FilterOrderComparator = /** @class */function () {\n  function FilterOrderComparator(op, rval) {\n    if (!isNumber(rval)) {\n      var errMsg = '';\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'rvalue of \"<\", \">\", \"<=\", \">=\" can only be number in filter.';\n      }\n      throwError(errMsg);\n    }\n    this._opFn = ORDER_COMPARISON_OP_MAP[op];\n    this._rvalFloat = numericToNumber(rval);\n  }\n  // Performance sensitive.\n  FilterOrderComparator.prototype.evaluate = function (lval) {\n    // Most cases is 'number', and typeof maybe 10 times faseter than parseFloat.\n    return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);\n  };\n  return FilterOrderComparator;\n}();\nvar SortOrderComparator = /** @class */function () {\n  /**\n   * @param order by default: 'asc'\n   * @param incomparable by default: Always on the tail.\n   *        That is, if 'asc' => 'max', if 'desc' => 'min'\n   *        See the definition of \"incomparable\" in [SORT_COMPARISON_RULE].\n   */\n  function SortOrderComparator(order, incomparable) {\n    var isDesc = order === 'desc';\n    this._resultLT = isDesc ? 1 : -1;\n    if (incomparable == null) {\n      incomparable = isDesc ? 'min' : 'max';\n    }\n    this._incomparable = incomparable === 'min' ? -Infinity : Infinity;\n  }\n  // See [SORT_COMPARISON_RULE].\n  // Performance sensitive.\n  SortOrderComparator.prototype.evaluate = function (lval, rval) {\n    // Most cases is 'number', and typeof maybe 10 times faseter than parseFloat.\n    var lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);\n    var rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);\n    var lvalNotNumeric = isNaN(lvalFloat);\n    var rvalNotNumeric = isNaN(rvalFloat);\n    if (lvalNotNumeric) {\n      lvalFloat = this._incomparable;\n    }\n    if (rvalNotNumeric) {\n      rvalFloat = this._incomparable;\n    }\n    if (lvalNotNumeric && rvalNotNumeric) {\n      var lvalIsStr = isString(lval);\n      var rvalIsStr = isString(rval);\n      if (lvalIsStr) {\n        lvalFloat = rvalIsStr ? lval : 0;\n      }\n      if (rvalIsStr) {\n        rvalFloat = lvalIsStr ? rval : 0;\n      }\n    }\n    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;\n  };\n  return SortOrderComparator;\n}();\nexport { SortOrderComparator };\nvar FilterEqualityComparator = /** @class */function () {\n  function FilterEqualityComparator(isEq, rval) {\n    this._rval = rval;\n    this._isEQ = isEq;\n    this._rvalTypeof = typeof rval;\n    this._rvalFloat = numericToNumber(rval);\n  }\n  // Performance sensitive.\n  FilterEqualityComparator.prototype.evaluate = function (lval) {\n    var eqResult = lval === this._rval;\n    if (!eqResult) {\n      var lvalTypeof = typeof lval;\n      if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === 'number' || this._rvalTypeof === 'number')) {\n        eqResult = numericToNumber(lval) === this._rvalFloat;\n      }\n    }\n    return this._isEQ ? eqResult : !eqResult;\n  };\n  return FilterEqualityComparator;\n}();\n/**\n * [FILTER_COMPARISON_RULE]\n * `lt`|`lte`|`gt`|`gte`:\n * + rval must be a number. And lval will be converted to number (`numericToNumber`) to compare.\n * `eq`:\n * + If same type, compare with `===`.\n * + If there is one number, convert to number (`numericToNumber`) to compare.\n * + Else return `false`.\n * `ne`:\n * + Not `eq`.\n *\n *\n * [SORT_COMPARISON_RULE]\n * All the values are grouped into three categories:\n * + \"numeric\" (number and numeric string)\n * + \"non-numeric-string\" (string that excluding numeric string)\n * + \"others\"\n * \"numeric\" vs \"numeric\": values are ordered by number order.\n * \"non-numeric-string\" vs \"non-numeric-string\": values are ordered by ES spec (#sec-abstract-relational-comparison).\n * \"others\" vs \"others\": do not change order (always return 0).\n * \"numeric\" vs \"non-numeric-string\": \"non-numeric-string\" is treated as \"incomparable\".\n * \"number\" vs \"others\": \"others\" is treated as \"incomparable\".\n * \"non-numeric-string\" vs \"others\": \"others\" is treated as \"incomparable\".\n * \"incomparable\" will be seen as -Infinity or Infinity (depends on the settings).\n * MEMO:\n *   Non-numeric string sort makes sense when we need to put the items with the same tag together.\n *   But if we support string sort, we still need to avoid the misleading like `'2' > '12'`,\n *   So we treat \"numeric-string\" sorted by number order rather than string comparison.\n *\n *\n * [CHECK_LIST_OF_THE_RULE_DESIGN]\n * + Do not support string comparison until required. And also need to\n *   avoid the misleading of \"2\" > \"12\".\n * + Should avoid the misleading case:\n *   `\" 22 \" gte \"22\"` is `true` but `\" 22 \" eq \"22\"` is `false`.\n * + JS bad case should be avoided: null <= 0, [] <= 0, ' ' <= 0, ...\n * + Only \"numeric\" can be converted to comparable number, otherwise converted to NaN.\n *   See `util/number.ts#numericToNumber`.\n *\n * @return If `op` is not `RelationalOperator`, return null;\n */\nexport function createFilterComparator(op, rval) {\n  return op === 'eq' || op === 'ne' ? new FilterEqualityComparator(op === 'eq', rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, createHashMap, assert, map } from 'zrender/lib/core/util.js';\nimport { VISUAL_DIMENSIONS } from '../../util/types.js';\nvar DimensionUserOuput = /** @class */function () {\n  function DimensionUserOuput(encode, dimRequest) {\n    this._encode = encode;\n    this._schema = dimRequest;\n  }\n  DimensionUserOuput.prototype.get = function () {\n    return {\n      // Do not generate full dimension name until fist used.\n      fullDimensions: this._getFullDimensionNames(),\n      encode: this._encode\n    };\n  };\n  /**\n   * Get all data store dimension names.\n   * Theoretically a series data store is defined both by series and used dataset (if any).\n   * If some dimensions are omitted for performance reason in `this.dimensions`,\n   * the dimension name may not be auto-generated if user does not specify a dimension name.\n   * In this case, the dimension name is `null`/`undefined`.\n   */\n  DimensionUserOuput.prototype._getFullDimensionNames = function () {\n    if (!this._cachedDimNames) {\n      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];\n    }\n    return this._cachedDimNames;\n  };\n  return DimensionUserOuput;\n}();\n;\nexport function summarizeDimensions(data, schema) {\n  var summary = {};\n  var encode = summary.encode = {};\n  var notExtraCoordDimMap = createHashMap();\n  var defaultedLabel = [];\n  var defaultedTooltip = [];\n  var userOutputEncode = {};\n  each(data.dimensions, function (dimName) {\n    var dimItem = data.getDimensionInfo(dimName);\n    var coordDim = dimItem.coordDim;\n    if (coordDim) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert(VISUAL_DIMENSIONS.get(coordDim) == null);\n      }\n      var coordDimIndex = dimItem.coordDimIndex;\n      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;\n      if (!dimItem.isExtraCoord) {\n        notExtraCoordDimMap.set(coordDim, 1);\n        // Use the last coord dim (and label friendly) as default label,\n        // because when dataset is used, it is hard to guess which dimension\n        // can be value dimension. If both show x, y on label is not look good,\n        // and conventionally y axis is focused more.\n        if (mayLabelDimType(dimItem.type)) {\n          defaultedLabel[0] = dimName;\n        }\n        // User output encode do not contain generated coords.\n        // And it only has index. User can use index to retrieve value from the raw item array.\n        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);\n      }\n      if (dimItem.defaultTooltip) {\n        defaultedTooltip.push(dimName);\n      }\n    }\n    VISUAL_DIMENSIONS.each(function (v, otherDim) {\n      var encodeArr = getOrCreateEncodeArr(encode, otherDim);\n      var dimIndex = dimItem.otherDims[otherDim];\n      if (dimIndex != null && dimIndex !== false) {\n        encodeArr[dimIndex] = dimItem.name;\n      }\n    });\n  });\n  var dataDimsOnCoord = [];\n  var encodeFirstDimNotExtra = {};\n  notExtraCoordDimMap.each(function (v, coordDim) {\n    var dimArr = encode[coordDim];\n    encodeFirstDimNotExtra[coordDim] = dimArr[0];\n    // Not necessary to remove duplicate, because a data\n    // dim canot on more than one coordDim.\n    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);\n  });\n  summary.dataDimsOnCoord = dataDimsOnCoord;\n  summary.dataDimIndicesOnCoord = map(dataDimsOnCoord, function (dimName) {\n    return data.getDimensionInfo(dimName).storeDimIndex;\n  });\n  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;\n  var encodeLabel = encode.label;\n  // FIXME `encode.label` is not recommended, because formatter cannot be set\n  // in this way. Use label.formatter instead. Maybe remove this approach someday.\n  if (encodeLabel && encodeLabel.length) {\n    defaultedLabel = encodeLabel.slice();\n  }\n  var encodeTooltip = encode.tooltip;\n  if (encodeTooltip && encodeTooltip.length) {\n    defaultedTooltip = encodeTooltip.slice();\n  } else if (!defaultedTooltip.length) {\n    defaultedTooltip = defaultedLabel.slice();\n  }\n  encode.defaultedLabel = defaultedLabel;\n  encode.defaultedTooltip = defaultedTooltip;\n  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);\n  return summary;\n}\nfunction getOrCreateEncodeArr(encode, dim) {\n  if (!encode.hasOwnProperty(dim)) {\n    encode[dim] = [];\n  }\n  return encode[dim];\n}\n// FIXME:TS should be type `AxisType`\nexport function getDimensionTypeByAxis(axisType) {\n  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n}\nfunction mayLabelDimType(dimType) {\n  // In most cases, ordinal and time do not suitable for label.\n  // Ordinal info can be displayed on axis. Time is too long.\n  return !(dimType === 'ordinal' || dimType === 'time');\n}\n// function findTheLastDimMayLabel(data) {\n//     // Get last value dim\n//     let dimensions = data.dimensions.slice();\n//     let valueType;\n//     let valueDim;\n//     while (dimensions.length && (\n//         valueDim = dimensions.pop(),\n//         valueType = data.getDimensionInfo(valueDim).type,\n//         valueType === 'ordinal' || valueType === 'time'\n//     )) {} // jshint ignore:line\n//     return valueDim;\n// }","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// TODO: this module is only for compatibility with echarts-gl\nimport linkSeriesData from './linkSeriesData.js';\nexport default linkSeriesData;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n/**\n * Link lists and struct (graph or tree)\n */\nimport { curry, each, assert, extend, map, keys } from 'zrender/lib/core/util.js';\nimport { makeInner } from '../../util/model.js';\nvar inner = makeInner();\nfunction linkSeriesData(opt) {\n  var mainData = opt.mainData;\n  var datas = opt.datas;\n  if (!datas) {\n    datas = {\n      main: mainData\n    };\n    opt.datasAttr = {\n      main: 'data'\n    };\n  }\n  opt.datas = opt.mainData = null;\n  linkAll(mainData, datas, opt);\n  // Porxy data original methods.\n  each(datas, function (data) {\n    each(mainData.TRANSFERABLE_METHODS, function (methodName) {\n      data.wrapMethod(methodName, curry(transferInjection, opt));\n    });\n  });\n  // Beyond transfer, additional features should be added to `cloneShallow`.\n  mainData.wrapMethod('cloneShallow', curry(cloneShallowInjection, opt));\n  // Only mainData trigger change, because struct.update may trigger\n  // another changable methods, which may bring about dead lock.\n  each(mainData.CHANGABLE_METHODS, function (methodName) {\n    mainData.wrapMethod(methodName, curry(changeInjection, opt));\n  });\n  // Make sure datas contains mainData.\n  assert(datas[mainData.dataType] === mainData);\n}\nfunction transferInjection(opt, res) {\n  if (isMainData(this)) {\n    // Transfer datas to new main data.\n    var datas = extend({}, inner(this).datas);\n    datas[this.dataType] = res;\n    linkAll(res, datas, opt);\n  } else {\n    // Modify the reference in main data to point newData.\n    linkSingle(res, this.dataType, inner(this).mainData, opt);\n  }\n  return res;\n}\nfunction changeInjection(opt, res) {\n  opt.struct && opt.struct.update();\n  return res;\n}\nfunction cloneShallowInjection(opt, res) {\n  // cloneShallow, which brings about some fragilities, may be inappropriate\n  // to be exposed as an API. So for implementation simplicity we can make\n  // the restriction that cloneShallow of not-mainData should not be invoked\n  // outside, but only be invoked here.\n  each(inner(res).datas, function (data, dataType) {\n    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);\n  });\n  return res;\n}\n/**\n * Supplement method to List.\n *\n * @public\n * @param [dataType] If not specified, return mainData.\n */\nfunction getLinkedData(dataType) {\n  var mainData = inner(this).mainData;\n  return dataType == null || mainData == null ? mainData : inner(mainData).datas[dataType];\n}\n/**\n * Get list of all linked data\n */\nfunction getLinkedDataAll() {\n  var mainData = inner(this).mainData;\n  return mainData == null ? [{\n    data: mainData\n  }] : map(keys(inner(mainData).datas), function (type) {\n    return {\n      type: type,\n      data: inner(mainData).datas[type]\n    };\n  });\n}\nfunction isMainData(data) {\n  return inner(data).mainData === data;\n}\nfunction linkAll(mainData, datas, opt) {\n  inner(mainData).datas = {};\n  each(datas, function (data, dataType) {\n    linkSingle(data, dataType, mainData, opt);\n  });\n}\nfunction linkSingle(data, dataType, mainData, opt) {\n  inner(mainData).datas[dataType] = data;\n  inner(data).mainData = mainData;\n  data.dataType = dataType;\n  if (opt.struct) {\n    data[opt.structAttr] = opt.struct;\n    opt.struct[opt.datasAttr[dataType]] = data;\n  }\n  // Supplement method.\n  data.getLinkedData = getLinkedData;\n  data.getLinkedDataAll = getLinkedDataAll;\n}\nexport default linkSeriesData;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { makeInner, getDataItemValue, queryReferringComponents, SINGLE_REFERRING } from '../../util/model.js';\nimport { createHashMap, each, isArray, isString, isObject, isTypedArray } from 'zrender/lib/core/util.js';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_ARRAY_ROWS, SOURCE_FORMAT_OBJECT_ROWS, SERIES_LAYOUT_BY_ROW, SOURCE_FORMAT_KEYED_COLUMNS } from '../../util/types.js';\n// The result of `guessOrdinal`.\nexport var BE_ORDINAL = {\n  Must: 1,\n  Might: 2,\n  Not: 3 // Other cases\n};\n\nvar innerGlobalModel = makeInner();\n/**\n * MUST be called before mergeOption of all series.\n */\nexport function resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  innerGlobalModel(ecModel).datasetMap = createHashMap();\n}\n/**\n * [The strategy of the arrengment of data dimensions for dataset]:\n * \"value way\": all axes are non-category axes. So series one by one take\n *     several (the number is coordSysDims.length) dimensions from dataset.\n *     The result of data arrengment of data dimensions like:\n *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |\n * \"category way\": at least one axis is category axis. So the the first data\n *     dimension is always mapped to the first category axis and shared by\n *     all of the series. The other data dimensions are taken by series like\n *     \"value way\" does.\n *     The result of data arrengment of data dimensions like:\n *     | ser_shared_x | ser0_y | ser1_y | ser2_y |\n *\n * @return encode Never be `null/undefined`.\n */\nexport function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {\n  var encode = {};\n  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);\n  // Currently only make default when using dataset, util more reqirements occur.\n  if (!datasetModel || !coordDimensions) {\n    return encode;\n  }\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var ecModel = seriesModel.ecModel;\n  var datasetMap = innerGlobalModel(ecModel).datasetMap;\n  var key = datasetModel.uid + '_' + source.seriesLayoutBy;\n  var baseCategoryDimIndex;\n  var categoryWayValueDimStart;\n  coordDimensions = coordDimensions.slice();\n  each(coordDimensions, function (coordDimInfoLoose, coordDimIdx) {\n    var coordDimInfo = isObject(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {\n      name: coordDimInfoLoose\n    };\n    if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {\n      baseCategoryDimIndex = coordDimIdx;\n      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);\n    }\n    encode[coordDimInfo.name] = [];\n  });\n  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n    categoryWayDim: categoryWayValueDimStart,\n    valueWayDim: 0\n  });\n  // TODO\n  // Auto detect first time axis and do arrangement.\n  each(coordDimensions, function (coordDimInfo, coordDimIdx) {\n    var coordDimName = coordDimInfo.name;\n    var count = getDataDimCountOnCoordDim(coordDimInfo);\n    // In value way.\n    if (baseCategoryDimIndex == null) {\n      var start = datasetRecord.valueWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.valueWayDim += count;\n      // ??? TODO give a better default series name rule?\n      // especially when encode x y specified.\n      // consider: when multiple series share one dimension\n      // category axis, series name should better use\n      // the other dimension name. On the other hand, use\n      // both dimensions name.\n    }\n    // In category way, the first category axis.\n    else if (baseCategoryDimIndex === coordDimIdx) {\n      pushDim(encode[coordDimName], 0, count);\n      pushDim(encodeItemName, 0, count);\n    }\n    // In category way, the other axis.\n    else {\n      var start = datasetRecord.categoryWayDim;\n      pushDim(encode[coordDimName], start, count);\n      pushDim(encodeSeriesName, start, count);\n      datasetRecord.categoryWayDim += count;\n    }\n  });\n  function pushDim(dimIdxArr, idxFrom, idxCount) {\n    for (var i = 0; i < idxCount; i++) {\n      dimIdxArr.push(idxFrom + i);\n    }\n  }\n  function getDataDimCountOnCoordDim(coordDimInfo) {\n    var dimsDef = coordDimInfo.dimsDef;\n    return dimsDef ? dimsDef.length : 1;\n  }\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * Work for data like [{name: ..., value: ...}, ...].\n *\n * @return encode Never be `null/undefined`.\n */\nexport function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {\n  var encode = {};\n  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);\n  // Currently only make default when using dataset, util more reqirements occur.\n  if (!datasetModel) {\n    return encode;\n  }\n  var sourceFormat = source.sourceFormat;\n  var dimensionsDefine = source.dimensionsDefine;\n  var potentialNameDimIndex;\n  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n  var idxResult = function () {\n    var idxRes0 = {};\n    var idxRes1 = {};\n    var guessRecords = [];\n    // 5 is an experience value.\n    for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {\n      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);\n      guessRecords.push(guessResult);\n      var isPureNumber = guessResult === BE_ORDINAL.Not;\n      // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,\n      // and then find a name dim with the priority:\n      // \"BE_ORDINAL.Might|BE_ORDINAL.Must\" > \"other dim\" > \"the value dim itself\".\n      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {\n        idxRes0.v = i;\n      }\n      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {\n        idxRes0.n = i;\n      }\n      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {\n        return idxRes0;\n      }\n      // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),\n      // find the first BE_ORDINAL.Might as the value dim,\n      // and then find a name dim with the priority:\n      // \"other dim\" > \"the value dim itself\".\n      // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be\n      // treated as number.\n      if (!isPureNumber) {\n        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {\n          idxRes1.v = i;\n        }\n        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {\n          idxRes1.n = i;\n        }\n      }\n    }\n    function fulfilled(idxResult) {\n      return idxResult.v != null && idxResult.n != null;\n    }\n    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;\n  }();\n  if (idxResult) {\n    encode.value = [idxResult.v];\n    // `potentialNameDimIndex` has highest priority.\n    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;\n    // By default, label uses itemName in charts.\n    // So we don't set encodeLabel here.\n    encode.itemName = [nameDimIndex];\n    encode.seriesName = [nameDimIndex];\n  }\n  return encode;\n}\n/**\n * @return If return null/undefined, indicate that should not use datasetModel.\n */\nexport function querySeriesUpstreamDatasetModel(seriesModel) {\n  // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n  var thisData = seriesModel.get('data', true);\n  if (!thisData) {\n    return queryReferringComponents(seriesModel.ecModel, 'dataset', {\n      index: seriesModel.get('datasetIndex', true),\n      id: seriesModel.get('datasetId', true)\n    }, SINGLE_REFERRING).models[0];\n  }\n}\n/**\n * @return Always return an array event empty.\n */\nexport function queryDatasetUpstreamDatasetModels(datasetModel) {\n  // Only these attributes declared, we by default reference to `datasetIndex: 0`.\n  // Otherwise, no reference.\n  if (!datasetModel.get('transform', true) && !datasetModel.get('fromTransformResult', true)) {\n    return [];\n  }\n  return queryReferringComponents(datasetModel.ecModel, 'dataset', {\n    index: datasetModel.get('fromDatasetIndex', true),\n    id: datasetModel.get('fromDatasetId', true)\n  }, SINGLE_REFERRING).models;\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n */\nexport function guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n}\n// dimIndex may be overflow source data.\n// return {BE_ORDINAL}\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result;\n  // Experience value.\n  var maxLoop = 5;\n  if (isTypedArray(data)) {\n    return BE_ORDINAL.Not;\n  }\n  // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n  var dimName;\n  var dimType;\n  if (dimensionsDefine) {\n    var dimDefItem = dimensionsDefine[dimIndex];\n    if (isObject(dimDefItem)) {\n      dimName = dimDefItem.name;\n      dimType = dimDefItem.type;\n    } else if (isString(dimDefItem)) {\n      dimName = dimDefItem;\n    }\n  }\n  if (dimType != null) {\n    return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;\n  }\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var dataArrayRows = data;\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = dataArrayRows[dimIndex];\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {\n        var row = dataArrayRows[startIndex + i];\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var dataObjectRows = data;\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n    for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {\n      var item = dataObjectRows[i];\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    var dataKeyedColumns = data;\n    if (!dimName) {\n      return BE_ORDINAL.Not;\n    }\n    var sample = dataKeyedColumns[dimName];\n    if (!sample || isTypedArray(sample)) {\n      return BE_ORDINAL.Not;\n    }\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var dataOriginal = data;\n    for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {\n      var item = dataOriginal[i];\n      var val = getDataItemValue(item);\n      if (!isArray(val)) {\n        return BE_ORDINAL.Not;\n      }\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n  function detectValue(val) {\n    var beStr = isString(val);\n    // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `Number('')` (or any whitespace) is `0`.\n    if (val != null && Number.isFinite(Number(val)) && val !== '') {\n      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;\n    } else if (beStr && val !== '-') {\n      return BE_ORDINAL.Must;\n    }\n  }\n  return BE_ORDINAL.Not;\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { setAsPrimitive, map, isTypedArray, assert, each, retrieve2 } from 'zrender/lib/core/util.js';\nimport { createSource, cloneSourceShallow } from '../Source.js';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../../util/types.js';\nimport { querySeriesUpstreamDatasetModel, queryDatasetUpstreamDatasetModels } from './sourceHelper.js';\nimport { applyDataTransform } from './transform.js';\nimport DataStore from '../DataStore.js';\nimport { DefaultDataProvider } from './dataProvider.js';\n/**\n * [REQUIREMENT_MEMO]:\n * (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.\n * (1) Keep support the feature: `metaRawOption` can be specified both on `series` and\n * `root-dataset`. Them on `series` has higher priority.\n * (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might\n * confuse users: whether those props indicate how to visit the upstream source or visit\n * the transform result source, and some transforms has nothing to do with these props,\n * and some transforms might have multiple upstream.\n * (3) Transforms should specify `metaRawOption` in each output, just like they can be\n * declared in `root-dataset`.\n * (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.\n * That is for reducing complexity in transforms.\n * PENDING: Whether to provide transposition transform?\n *\n * [IMPLEMENTAION_MEMO]:\n * \"sourceVisitConfig\" are calculated from `metaRawOption` and `data`.\n * They will not be calculated until `source` is about to be visited (to prevent from\n * duplicate calcuation). `source` is visited only in series and input to transforms.\n *\n * [DIMENSION_INHERIT_RULE]:\n * By default the dimensions are inherited from ancestors, unless a transform return\n * a new dimensions definition.\n * Consider the case:\n * ```js\n * dataset: [{\n *     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * dataset: [{\n *     dimension: ['Product', 'Sales', 'Prise'],\n *     source: [ ['Cookies', 321, 44.21], ...]\n * }, {\n *     transform: { type: 'filter', ... }\n * }]\n * ```\n * The two types of option should have the same behavior after transform.\n *\n *\n * [SCENARIO]:\n * (1) Provide source data directly:\n * ```js\n * series: {\n *     encode: {...},\n *     dimensions: [...]\n *     seriesLayoutBy: 'row',\n *     data: [[...]]\n * }\n * ```\n * (2) Series refer to dataset.\n * ```js\n * series: [{\n *     encode: {...}\n *     // Ignore datasetIndex means `datasetIndex: 0`\n *     // and the dimensions defination in dataset is used\n * }, {\n *     encode: {...},\n *     seriesLayoutBy: 'column',\n *     datasetIndex: 1\n * }]\n * ```\n * (3) dataset transform\n * ```js\n * dataset: [{\n *     source: [...]\n * }, {\n *     source: [...]\n * }, {\n *     // By default from 0.\n *     transform: { type: 'filter', config: {...} }\n * }, {\n *     // Piped.\n *     transform: [\n *         { type: 'filter', config: {...} },\n *         { type: 'sort', config: {...} }\n *     ]\n * }, {\n *     id: 'regressionData',\n *     fromDatasetIndex: 1,\n *     // Third-party transform\n *     transform: { type: 'ecStat:regression', config: {...} }\n * }, {\n *     // retrieve the extra result.\n *     id: 'regressionFormula',\n *     fromDatasetId: 'regressionData',\n *     fromTransformResult: 1\n * }]\n * ```\n */\nvar SourceManager = /** @class */function () {\n  function SourceManager(sourceHost) {\n    // Cached source. Do not repeat calculating if not dirty.\n    this._sourceList = [];\n    this._storeList = [];\n    // version sign of each upstream source manager.\n    this._upstreamSignList = [];\n    this._versionSignBase = 0;\n    this._dirty = true;\n    this._sourceHost = sourceHost;\n  }\n  /**\n   * Mark dirty.\n   */\n  SourceManager.prototype.dirty = function () {\n    this._setLocalSource([], []);\n    this._storeList = [];\n    this._dirty = true;\n  };\n  SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {\n    this._sourceList = sourceList;\n    this._upstreamSignList = upstreamSignList;\n    this._versionSignBase++;\n    if (this._versionSignBase > 9e10) {\n      this._versionSignBase = 0;\n    }\n  };\n  /**\n   * For detecting whether the upstream source is dirty, so that\n   * the local cached source (in `_sourceList`) should be discarded.\n   */\n  SourceManager.prototype._getVersionSign = function () {\n    return this._sourceHost.uid + '_' + this._versionSignBase;\n  };\n  /**\n   * Always return a source instance. Otherwise throw error.\n   */\n  SourceManager.prototype.prepareSource = function () {\n    // For the case that call `setOption` multiple time but no data changed,\n    // cache the result source to prevent from repeating transform.\n    if (this._isDirty()) {\n      this._createSource();\n      this._dirty = false;\n    }\n  };\n  SourceManager.prototype._createSource = function () {\n    this._setLocalSource([], []);\n    var sourceHost = this._sourceHost;\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n    var hasUpstream = !!upSourceMgrList.length;\n    var resultSourceList;\n    var upstreamSignList;\n    if (isSeries(sourceHost)) {\n      var seriesModel = sourceHost;\n      var data = void 0;\n      var sourceFormat = void 0;\n      var upSource = void 0;\n      // Has upstream dataset\n      if (hasUpstream) {\n        var upSourceMgr = upSourceMgrList[0];\n        upSourceMgr.prepareSource();\n        upSource = upSourceMgr.getSource();\n        data = upSource.data;\n        sourceFormat = upSource.sourceFormat;\n        upstreamSignList = [upSourceMgr._getVersionSign()];\n      }\n      // Series data is from own.\n      else {\n        data = seriesModel.get('data', true);\n        sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n        upstreamSignList = [];\n      }\n      // See [REQUIREMENT_MEMO], merge settings on series and parent dataset if it is root.\n      var newMetaRawOption = this._getSourceMetaRawOption() || {};\n      var upMetaRawOption = upSource && upSource.metaRawOption || {};\n      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;\n      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);\n      // Note here we should not use `upSource.dimensionsDefine`. Consider the case:\n      // `upSource.dimensionsDefine` is detected by `seriesLayoutBy: 'column'`,\n      // but series need `seriesLayoutBy: 'row'`.\n      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);\n      // We share source with dataset as much as possible\n      // to avoid extra memory cost of high dimensional data.\n      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;\n      resultSourceList = needsCreateSource ? [createSource(data, {\n        seriesLayoutBy: seriesLayoutBy,\n        sourceHeader: sourceHeader,\n        dimensions: dimensions\n      }, sourceFormat)] : [];\n    } else {\n      var datasetModel = sourceHost;\n      // Has upstream dataset.\n      if (hasUpstream) {\n        var result = this._applyTransform(upSourceMgrList);\n        resultSourceList = result.sourceList;\n        upstreamSignList = result.upstreamSignList;\n      }\n      // Is root dataset.\n      else {\n        var sourceData = datasetModel.get('source', true);\n        resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];\n        upstreamSignList = [];\n      }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      assert(resultSourceList && upstreamSignList);\n    }\n    this._setLocalSource(resultSourceList, upstreamSignList);\n  };\n  SourceManager.prototype._applyTransform = function (upMgrList) {\n    var datasetModel = this._sourceHost;\n    var transformOption = datasetModel.get('transform', true);\n    var fromTransformResult = datasetModel.get('fromTransformResult', true);\n    if (process.env.NODE_ENV !== 'production') {\n      assert(fromTransformResult != null || transformOption != null);\n    }\n    if (fromTransformResult != null) {\n      var errMsg = '';\n      if (upMgrList.length !== 1) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'When using `fromTransformResult`, there should be only one upstream dataset';\n        }\n        doThrow(errMsg);\n      }\n    }\n    var sourceList;\n    var upSourceList = [];\n    var upstreamSignList = [];\n    each(upMgrList, function (upMgr) {\n      upMgr.prepareSource();\n      var upSource = upMgr.getSource(fromTransformResult || 0);\n      var errMsg = '';\n      if (fromTransformResult != null && !upSource) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Can not retrieve result by `fromTransformResult`: ' + fromTransformResult;\n        }\n        doThrow(errMsg);\n      }\n      upSourceList.push(upSource);\n      upstreamSignList.push(upMgr._getVersionSign());\n    });\n    if (transformOption) {\n      sourceList = applyDataTransform(transformOption, upSourceList, {\n        datasetIndex: datasetModel.componentIndex\n      });\n    } else if (fromTransformResult != null) {\n      sourceList = [cloneSourceShallow(upSourceList[0])];\n    }\n    return {\n      sourceList: sourceList,\n      upstreamSignList: upstreamSignList\n    };\n  };\n  SourceManager.prototype._isDirty = function () {\n    if (this._dirty) {\n      return true;\n    }\n    // All sourceList is from the some upstream.\n    var upSourceMgrList = this._getUpstreamSourceManagers();\n    for (var i = 0; i < upSourceMgrList.length; i++) {\n      var upSrcMgr = upSourceMgrList[i];\n      if (\n      // Consider the case that there is ancestor diry, call it recursively.\n      // The performance is probably not an issue because usually the chain is not long.\n      upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {\n        return true;\n      }\n    }\n  };\n  /**\n   * @param sourceIndex By default 0, means \"main source\".\n   *                    In most cases there is only one source.\n   */\n  SourceManager.prototype.getSource = function (sourceIndex) {\n    sourceIndex = sourceIndex || 0;\n    var source = this._sourceList[sourceIndex];\n    if (!source) {\n      // Series may share source instance with dataset.\n      var upSourceMgrList = this._getUpstreamSourceManagers();\n      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);\n    }\n    return source;\n  };\n  /**\n   *\n   * Get a data store which can be shared across series.\n   * Only available for series.\n   *\n   * @param seriesDimRequest Dimensions that are generated in series.\n   *        Should have been sorted by `storeDimIndex` asc.\n   */\n  SourceManager.prototype.getSharedDataStore = function (seriesDimRequest) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(isSeries(this._sourceHost), 'Can only call getDataStore on series source manager.');\n    }\n    var schema = seriesDimRequest.makeStoreSchema();\n    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);\n  };\n  SourceManager.prototype._innerGetDataStore = function (storeDims, seriesSource, sourceReadKey) {\n    // TODO Can use other sourceIndex?\n    var sourceIndex = 0;\n    var storeList = this._storeList;\n    var cachedStoreMap = storeList[sourceIndex];\n    if (!cachedStoreMap) {\n      cachedStoreMap = storeList[sourceIndex] = {};\n    }\n    var cachedStore = cachedStoreMap[sourceReadKey];\n    if (!cachedStore) {\n      var upSourceMgr = this._getUpstreamSourceManagers()[0];\n      if (isSeries(this._sourceHost) && upSourceMgr) {\n        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);\n      } else {\n        cachedStore = new DataStore();\n        // Always create store from source of series.\n        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);\n      }\n      cachedStoreMap[sourceReadKey] = cachedStore;\n    }\n    return cachedStore;\n  };\n  /**\n   * PENDING: Is it fast enough?\n   * If no upstream, return empty array.\n   */\n  SourceManager.prototype._getUpstreamSourceManagers = function () {\n    // Always get the relationship from the raw option.\n    // Do not cache the link of the dependency graph, so that\n    // there is no need to update them when change happens.\n    var sourceHost = this._sourceHost;\n    if (isSeries(sourceHost)) {\n      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);\n      return !datasetModel ? [] : [datasetModel.getSourceManager()];\n    } else {\n      return map(queryDatasetUpstreamDatasetModels(sourceHost), function (datasetModel) {\n        return datasetModel.getSourceManager();\n      });\n    }\n  };\n  SourceManager.prototype._getSourceMetaRawOption = function () {\n    var sourceHost = this._sourceHost;\n    var seriesLayoutBy;\n    var sourceHeader;\n    var dimensions;\n    if (isSeries(sourceHost)) {\n      seriesLayoutBy = sourceHost.get('seriesLayoutBy', true);\n      sourceHeader = sourceHost.get('sourceHeader', true);\n      dimensions = sourceHost.get('dimensions', true);\n    }\n    // See [REQUIREMENT_MEMO], `non-root-dataset` do not support them.\n    else if (!this._getUpstreamSourceManagers().length) {\n      var model = sourceHost;\n      seriesLayoutBy = model.get('seriesLayoutBy', true);\n      sourceHeader = model.get('sourceHeader', true);\n      dimensions = model.get('dimensions', true);\n    }\n    return {\n      seriesLayoutBy: seriesLayoutBy,\n      sourceHeader: sourceHeader,\n      dimensions: dimensions\n    };\n  };\n  return SourceManager;\n}();\nexport { SourceManager };\n// Call this method after `super.init` and `super.mergeOption` to\n// disable the transform merge, but do not disable transform clone from rawOption.\nexport function disableTransformOptionMerge(datasetModel) {\n  var transformOption = datasetModel.option.transform;\n  transformOption && setAsPrimitive(datasetModel.option.transform);\n}\nfunction isSeries(sourceHost) {\n  // Avoid circular dependency with Series.ts\n  return sourceHost.mainType === 'series';\n}\nfunction doThrow(errMsg) {\n  throw new Error(errMsg);\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_ARRAY_ROWS } from '../../util/types.js';\nimport { normalizeToArray } from '../../util/model.js';\nimport { createHashMap, bind, each, hasOwn, map, clone, isObject, extend, isNumber } from 'zrender/lib/core/util.js';\nimport { getRawSourceItemGetter, getRawSourceDataCounter, getRawSourceValueGetter } from './dataProvider.js';\nimport { parseDataValue } from './dataValueHelper.js';\nimport { log, makePrintable, throwError } from '../../util/log.js';\nimport { createSource, detectSourceFormat } from '../Source.js';\n/**\n * TODO: disable writable.\n * This structure will be exposed to users.\n */\nvar ExternalSource = /** @class */function () {\n  function ExternalSource() {}\n  ExternalSource.prototype.getRawData = function () {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n  /**\n   * @return If dimension not found, return null/undefined.\n   */\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n  /**\n   * dimensions defined if and only if either:\n   * (a) dataset.dimensions are declared.\n   * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).\n   * If dimensions are defined, `dimensionInfoAll` is corresponding to\n   * the defined dimensions.\n   * Otherwise, `dimensionInfoAll` is determined by data columns.\n   * @return Always return an array (even empty array).\n   */\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n  /**\n   * Only support by dimension index.\n   * No need to support by dimension name in transform function,\n   * because transform function is not case-specific, no need to use name literally.\n   */\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return parseDataValue(rawVal, dimInfo);\n  };\n  return ExternalSource;\n}();\nexport { ExternalSource };\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var errMsg = '';\n  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {\n    // For the logic simplicity in transformer, only 'culumn' is\n    // supported in data transform. Otherwise, the `dimensionsDefine`\n    // might be detected by 'row', which probably confuses users.\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform.';\n    }\n    throwError(errMsg);\n  }\n  // [MEMO]\n  // Create a new dimensions structure for exposing.\n  // Do not expose all dimension info to users directly.\n  // Because the dimension is probably auto detected from data and not might reliable.\n  // Should not lead the transformers to think that is reliable and return it.\n  // See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n  if (dimsDef) {\n    each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt);\n      // Users probably do not specify dimension name. For simplicity, data transform\n      // does not generate dimension name.\n      if (name != null) {\n        // Dimension name should not be duplicated.\n        // For simplicity, data transform forbids name duplication, do not generate\n        // new name like module `completeDimensions.ts` did, but just tell users.\n        var errMsg_1 = '';\n        if (hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg_1 = 'dimension name \"' + name + '\" duplicated.';\n          }\n          throwError(errMsg_1);\n        }\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  }\n  // If dimension definitions are not defined and can not be detected.\n  // e.g., pure data `[[11, 22], ...]`.\n  else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      // Do not generete name or anything others. The consequence process in\n      // `transform` or `series` probably have there own name generation strategry.\n      dimensions.push({\n        index: i\n      });\n    }\n  }\n  // Implement public methods:\n  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n    extSource.getRawData = bind(getRawData, null, internalSource);\n  }\n  extSource.cloneRawData = bind(cloneRawData, null, internalSource);\n  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = getRawSourceValueGetter(sourceFormat);\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n    var dimDef = dimensions[dimIndex];\n    // When `dimIndex` is `null`, `rawValueGetter` return the whole item.\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n    }\n    throwError(errMsg);\n  }\n  return upstream.data;\n}\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`cloneRawData` is not supported in source format ' + sourceFormat;\n    }\n    throwError(errMsg);\n  }\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(data[i].slice());\n    }\n    return result;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(extend({}, data[i]));\n    }\n    return result;\n  }\n}\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  }\n  // Keep the same logic as `List::getDimension` did.\n  if (isNumber(dim)\n  // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\nfunction cloneAllDimensionInfo(dimensions) {\n  return clone(dimensions);\n}\nvar externalTransformMap = createHashMap();\nexport function registerExternalTransform(externalTransform) {\n  externalTransform = clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n    throwError(errMsg);\n  }\n  var typeParsed = type.split(':');\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n    throwError(errMsg);\n  }\n  // Namespace 'echarts:xxx' is official namespace, where the transforms should\n  // be called directly via 'xxx' rather than 'echarts:xxx'.\n  var isBuiltIn = false;\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\nexport function applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n    throwError(errMsg);\n  }\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);\n    // piped transform only support single input, except the fist one.\n    // piped transform only support single output, except the last one.\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n  return sourceList;\n}\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint,\n// If `pipeIndex` is null/undefined, no piped transform.\npipeIndex) {\n  var errMsg = '';\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n    throwError(errMsg);\n  }\n  if (!isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n    throwError(errMsg);\n  }\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n    throwError(errMsg);\n  }\n  // Prepare source\n  var extUpSourceList = map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: clone(transOption.config)\n  }));\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      log(printStrArr);\n    }\n  }\n  return map(resultList, function (result, resultIndex) {\n    var errMsg = '';\n    if (!isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n      throwError(errMsg);\n    }\n    if (!result.data) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be not be null or undefined';\n      }\n      throwError(errMsg);\n    }\n    var sourceFormat = detectSourceFormat(result.data);\n    if (!isSupportedSourceFormat(sourceFormat)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be array rows or object rows.';\n      }\n      throwError(errMsg);\n    }\n    var resultMetaRawOption;\n    var firstUpSource = upSourceList[0];\n    /**\n     * Intuitively, the end users known the content of the original `dataset.source`,\n     * calucating the transform result in mind.\n     * Suppose the original `dataset.source` is:\n     * ```js\n     * [\n     *     ['product', '2012', '2013', '2014', '2015'],\n     *     ['AAA', 41.1, 30.4, 65.1, 53.3],\n     *     ['BBB', 86.5, 92.1, 85.7, 83.1],\n     *     ['CCC', 24.1, 67.2, 79.5, 86.4]\n     * ]\n     * ```\n     * The dimension info have to be detected from the source data.\n     * Some of the transformers (like filter, sort) will follow the dimension info\n     * of upstream, while others use new dimensions (like aggregate).\n     * Transformer can output a field `dimensions` to define the its own output dimensions.\n     * We also allow transformers to ignore the output `dimensions` field, and\n     * inherit the upstream dimensions definition. It can reduce the burden of handling\n     * dimensions in transformers.\n     *\n     * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n     */\n    if (firstUpSource && resultIndex === 0\n    // If transformer returns `dimensions`, it means that the transformer has different\n    // dimensions definitions. We do not inherit anything from upstream.\n    && !result.dimensions) {\n      var startIndex = firstUpSource.startIndex;\n      // We copy the header of upstream to the result, because:\n      // (1) The returned data always does not contain header line and can not be used\n      // as dimension-detection. In this case we can not use \"detected dimensions\" of\n      // upstream directly, because it might be detected based on different `seriesLayoutBy`.\n      // (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.\n      // So the original detected header should be add to the result, otherwise they can not be read.\n      if (startIndex) {\n        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);\n      }\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: startIndex,\n        dimensions: firstUpSource.metaRawOption.dimensions\n      };\n    } else {\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: 0,\n        dimensions: result.dimensions\n      };\n    }\n    return createSource(result.data, resultMetaRawOption, null);\n  });\n}\nfunction isSupportedSourceFormat(sourceFormat) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;\n}"],"names":["inner","makeInner","dimTypeShort","float","int","ordinal","number","time","SeriesDataSchema","opt","this","dimensions","_dimOmitted","dimensionOmitted","source","_fullDimCount","fullDimensionCount","_updateDimOmitted","prototype","isDimensionOmitted","_dimNameMap","ensureSourceDimNameMap","getSourceDimensionIndex","dimName","retrieve2","get","getSourceDimension","dimIndex","dimensionsDefine","makeStoreSchema","dimCount","willRetrieveDataByName","shouldRetrieveDataByName","makeHashStrict","shouldOmitUnusedDimensions","dimHash","dims","fullDimIdx","seriesDimIdx","property","type","ordinalMeta","seriesDimDef","storeDimIndex","name","sourceDimDef","push","isCalculationCoord","replace","uid","hash","seriesLayoutBy","startIndex","join","makeOutputDimensionNames","result","name_1","appendCalculationDimension","dimDef","isSeriesDataSchema","schema","createDimNameMap","dimsDef","dataDimNameMap","createHashMap","i","length","dimDefItemRaw","userDimName","isObject","set","innerSource","dimNameMap","createDimensions","prepareSeriesDataSchema","isSourceInstance","createSourceFromSeriesDataOption","sysDims","coordDimensions","coordDimNameMap","resultList","getDimCount","dimensionsCount","omitUnusedDimensions","canOmitUnusedDimensions","isUsingSourceDimensionsDef","encodeDef","encodeDefine","encodeDefaulter","encodeDefMap","indicesMap","CtorInt32Array","getResultItem","dimIdx","idx","dimDefItem","resultItem","SeriesDimensionDefine","displayName","newIdx","each","dataDimsRaw","coordDim","dataDims","normalizeToArray","slice","isString","validDataDims","resultDimIdxOrName","resultDimIdx","applyDim","availDimIdx","coordDimIndex","VISUAL_DIMENSIONS","otherDims","sysDimItemRaw","sysDimItemDimsDef","sysDimItemOtherDims","sysDimItem","extend","defaults","sysDimItemDimsDefItem","defaultTooltip","generateCoord","generateCoordCount","fromZero","extra","ifNoNameFillWithCoordName","sort","item0","item1","genCoordDimName","isExtraCoord","guessOrdinal","BE_ORDINAL","Must","itemName","seriesName","removeDuplication","duplicationMap","dim","dimOriginalName","count","optDimCount","Math","max","dimensionsDetectedCount","map","hasKey","_a","_b","_c","providerMethods","mountMethods","DefaultDataProvider","sourceParam","dimSize","_source","data","_data","sourceFormat","SOURCE_FORMAT_TYPED_ARRAY","_offset","_dimSize","getSource","getItem","out","appendData","newData","clean","protoInitialize","proto","pure","persistent","internalField","provider","methods","getMethodMapKey","getItemForTypedArray","countForTypedArray","fillStorage","fillStorageForTypedArray","rawItemGetter","getRawSourceItemGetter","bind","rawCounter","getRawSourceDataCounter","offset","start","end","storage","extent","dimExtent","min","Infinity","arr","val","appendDataSimply","SOURCE_FORMAT_ARRAY_ROWS","SERIES_LAYOUT_BY_COLUMN","SERIES_LAYOUT_BY_ROW","Error","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","newCol","key","oldCol","SOURCE_FORMAT_ORIGINAL","getItemSimply","rawData","rawSourceItemGetterMap","item","row","process","col","method","countSimply","rawSourceDataCounterMap","getRawValueSimply","dataItem","rawSourceValueGetterMap","value","getDataItemValue","Array","getRawSourceValueGetter","retrieveRawValue","dataIndex","getRawDataItem","store","getStore","getDimensionIndex","getDimensionProperty","enableDataStack","seriesModel","dimensionsInput","dimensionDefineList","byIndex","stackedCoordDimension","isLegacyDimensionsInput","stackedByDimInfo","stackedDimInfo","stackResultDimension","stackedOverDimension","mayStack","dimensionInfo","index","id","createInvertedIndices","stackedDimCoordDim_1","stackedDimType","stackedDimCoordIndex_1","stackedOverDimensionDefine","stackResultDimensionDefine","ensureCalculationDimension","stackedDimension","stackedByDimension","isStackedByIndex","isDimensionStacked","stackedDim","getCalculationInfo","getStackedDimension","targetDim","parseDataValue","dimType","isNumber","parseDate","NaN","Number","valueParserMap","parseFloat","trim","getRawValueParser","ORDER_COMPARISON_OP_MAP","lt","lval","rval","lte","gt","gte","FilterOrderComparator","op","errMsg","throwError","_opFn","_rvalFloat","numericToNumber","evaluate","SortOrderComparator","order","incomparable","isDesc","_resultLT","_incomparable","lvalFloat","rvalFloat","lvalNotNumeric","isNaN","rvalNotNumeric","lvalIsStr","rvalIsStr","FilterEqualityComparator","isEq","_rval","_isEQ","_rvalTypeof","eqResult","lvalTypeof","createFilterComparator","hasOwn","DimensionUserOuput","encode","dimRequest","_encode","_schema","fullDimensions","_getFullDimensionNames","_cachedDimNames","summarizeDimensions","summary","notExtraCoordDimMap","defaultedLabel","defaultedTooltip","userOutputEncode","dimItem","getDimensionInfo","getOrCreateEncodeArr","mayLabelDimType","v","otherDim","encodeArr","dataDimsOnCoord","encodeFirstDimNotExtra","dimArr","concat","dataDimIndicesOnCoord","encodeLabel","label","encodeTooltip","tooltip","userOutput","hasOwnProperty","getDimensionTypeByAxis","axisType","linkSeriesData","mainData","datas","main","datasAttr","linkAll","TRANSFERABLE_METHODS","methodName","wrapMethod","curry","transferInjection","cloneShallowInjection","CHANGABLE_METHODS","changeInjection","assert","dataType","res","isMainData","linkSingle","struct","update","cloneShallow","getLinkedData","getLinkedDataAll","keys","structAttr","Might","Not","innerGlobalModel","resetSourceDefaulter","ecModel","datasetMap","makeSeriesEncodeForAxisCoordSys","datasetModel","querySeriesUpstreamDatasetModel","baseCategoryDimIndex","categoryWayValueDimStart","encodeItemName","encodeSeriesName","coordDimInfoLoose","coordDimIdx","coordDimInfo","getDataDimCountOnCoordDim","datasetRecord","categoryWayDim","valueWayDim","pushDim","dimIdxArr","idxFrom","idxCount","coordDimName","makeSeriesEncodeForNameBased","potentialNameDimIndex","idxResult","idxRes0","idxRes1","guessRecords","len","guessResult","doGuessOrdinal","isPureNumber","n","fulfilled","nameDimIndex","thisData","queryReferringComponents","SINGLE_REFERRING","models","queryDatasetUpstreamDatasetModels","maxLoop","isTypedArray","dataArrayRows","sample","detectValue","dataObjectRows","dataKeyedColumns","dataOriginal","isArray","beStr","isFinite","SourceManager","sourceHost","_sourceList","_storeList","_upstreamSignList","_versionSignBase","_dirty","_sourceHost","dirty","_setLocalSource","sourceList","upstreamSignList","_getVersionSign","prepareSource","_isDirty","_createSource","resultSourceList","upSourceMgrList","_getUpstreamSourceManagers","hasUpstream","isSeries","upSource","upSourceMgr","newMetaRawOption","_getSourceMetaRawOption","upMetaRawOption","metaRawOption","sourceHeader","needsCreateSource","createSource","_applyTransform","sourceData","upMgrList","transformOption","fromTransformResult","doThrow","upSourceList","upMgr","applyDataTransform","datasetIndex","componentIndex","cloneSourceShallow","upSrcMgr","sourceIndex","getSharedDataStore","seriesDimRequest","_innerGetDataStore","storeDims","seriesSource","sourceReadKey","storeList","cachedStoreMap","cachedStore","DataStore","initData","getSourceManager","model","disableTransformOptionMerge","option","transform","setAsPrimitive","mainType","ExternalSource","getRawData","cloneRawData","cloneAllDimensionInfo","retrieveValue","retrieveValueFromItem","convertValue","rawVal","dimInfo","createExternalSource","internalSource","externalTransform","extSource","sourceHeaderCount","dimsByName","dimDefExt","errMsg_1","__isBuiltIn","rawValueGetter","rawItem","upstream","isSupportedSourceFormat","clone","externalTransformMap","registerExternalTransform","typeParsed","split","isBuiltIn","rawTransOption","infoForPrint","pipedTransOption","pipeLen","transOption","applySingleDataTransform","pipeIndex","transType","extUpSourceList","upstreamList","config","resultIndex","resultMetaRawOption","detectSourceFormat","firstUpSource"],"sourceRoot":""}